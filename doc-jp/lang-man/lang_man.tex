%%
%% Toolbox Language Manual
%% $Id: lang_man.tex,v 1.16 2006/04/19 10:26:51 vdmtools Exp $
%% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF compatibility code. 

\makeatletter
\newif\ifpdflatex@
\ifx\pdftexversion\@undefined
\pdflatex@false
%\message{Not using pdf}
\else
\pdflatex@true
%\message{Using pdf}
\fi

\newcommand{\latexpdf}[2]{
  \ifpdflatex@ #1
  \else #2
  \fi
}

\newcommand{\latexorpdf}[2]{
  \ifpdflatex@ #2
  \else #1
  \fi
}

#ifdef A4Format
\newcommand{\pformat}{a4paper}
#endif A4Format
#ifdef LetterFormat
\newcommand{\pformat}{letterpaper}
#endif LetterFormat

\makeatother

\newcommand{\RuleTarget}[1]{\hypertarget{rule:#1}{}}
\newcommand{\Ruledef}[2]
{
  \RuleTarget{#1}\Rule{#1}{#2}%
  }
\newcommand{\Ruleref}[1]{
  \hyperlink{rule:#1}{#1}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\latexorpdf{
\documentclass[\pformat,12pt]{jarticle}
}{
% pdftex option is used by graphic[sx],hyperref,toolbox.sty
\documentclass[\pformat,pdftex,12pt]{jarticle}
}

\usepackage{toolbox}
\usepackage{vdmsl-2e}
\usepackage{makeidx}
\usepackage{alltt}
%\usepackage{epsfig}
%\usepackage{here}
\usepackage{array}
\usepackage{longtable}
\usepackage{ifthen}
% plainpages=false: avoid warning
%   destination with the same identifier already exists
%   but it do not seem to work a the first pages

%\ifnum 42146=\euc"A4A2 \AtBeginDvi{\special{pdf:tounicode EUC-UCS2}}\else
%\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}\fi
\usepackage{atbegshi}
\ifnum
  42146=\euc"A4A2 \AtBeginShipoutFirst{\special{pdf:tounicode EUC-UCS2}}
\else
  \AtBeginShipoutFirst{\special{pdf:tounicode 90ms-RKSJ-UCS2}}
\fi

\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}

#ifdef VDMPP
\usepackage{vpp}
#endif VDMPP

\newcommand{\vdmslpp}[2]{%
#ifdef VDMSL
#1
#endif VDMSL
#ifdef VDMPP
#2
#endif VDMPP
}

\newcommand{\vdmsl}{VDM-SL}
\newcommand{\vdmpp}{VDM++}
\newcommand{\Index}[1]{#1\index{#1}}
#ifdef VDMPP
%\usepackage{latexsym}
%\usepackage{epsf}
\newcommand{\vppsmall}{\small\tt}
\newcommand{\tr}[1]{{\bf\underline{#1}}}



\newcommand{\insertfig}[4]{ % Filename, epsheight, epswidth, caption,  label
\begin{figure}[htb]
\begin{center}
\includegraphics[width=#2]{#1} 
\end{center}
\caption{{\em #3}} #4
\end{figure}
}

\newcommand{\insertfignw}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\includegraphics{#1} 
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\newcommand{\insertfignwrot}[3]{ % Filename, caption,  label
\begin{figure}[h]
\begin{center}
\scalebox{1}%
{\rotatebox{270}{%
\includegraphics{#1}}}
\end{center}
\caption{{\em #2}} #3
\end{figure}
}

\makeindex
#endif VDMPP

% The use of VDMSL/VDMPP ifdef's have basicly been exchanged with the
% use of LaTeX ifthenelse's.  For this two LaTeX boolean value VDMSL and
% VDMpp have been defined  (Lowercase p's are used to avoid conflict with
% the VDMPP environment variable.  The typical use are:
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text}
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% The advantage of this as opposed to ifdef's is that within a general
% paragraph specific VDM-SL and VDM++ parts can be distinguished without
% problematic empty lines.
% 
% The values are initialised such that exactly one of the values is true
% and the other is false.  This should hopefully avoid strange behaviour
% due to possible preprossing errors.  The default case is VDM-SL.
\newboolean{VDMsl}
\setboolean{VDMsl}{true}
\newboolean{VDMpp}
\setboolean{VDMpp}{false}
#ifdef VDMSL
\setboolean{VDMsl}{true}
\setboolean{VDMpp}{false}
#endif VDMSL
#ifdef VDMPP
\setboolean{VDMpp}{true}
\setboolean{VDMsl}{false}
#endif VDMPP

%\latexpdf{\usepackage[pdftex,colorlinks=true,bookmarks=true]{hyperref}}{}

\newcommand{\MYEQUIV}{$\equiv$}
\newlength{\nonstandlen}
\newcommand{\nonstandard}[1]{%
#ifdef VDMSL
\setlength{\nonstandlen}{#1\baselineskip}%
  \marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{\fbox{{\footnotesize Non standard}}}}%
#endif VDMSL
}
\newenvironment{TypeSemantics}{\begin{longtable}[r]{|p{3.5cm}|p{9cm}|}\hline%
  演算子名称 & 意味記述 \\ \hline\hline \endhead}% 
  {\hline\end{longtable}}
  
%\renewcommand{\vdmpp}{{\small VDM}$^{++}$}

\makeatletter
% ------------- TOC manipulation ------------
\def\docglbldepth{1}
%\setcounter{secnumdepth}{\docglbldepth}
%\setcounter{tocdepth}{\docglbldepth}
\def\@pnumwidth{3.0em}
% more space for for >10 subsections
%\def\l@section{\@dottedtocline{1}{1.5em}{3.1em}}
\def\l@subsection{\@dottedtocline{2}{1.5em}{2.8em}}
%\def\l@subsubsection{\@dottedtocline{3}{4.3em}{3.6em}}
%\def\l@paragraph{\@dottedtocline{4}{7.9em}{4.1em}}
%\def\l@subparagraph{\@dottedtocline{5}{10em}{5em}}
\makeatother

\makeindex
%\latexpdf{\pdfinfo{
% /Title (The IFAD VDM-SL Language)
% /Author (The VDM Tool Group, The Institute of Applied Computer Science)
%}}{}


\begin{document}
%\latexpdf{\pdfcatalog{/PageMode /UseOutlines} openaction goto page 1 {/Fit}}{}


#ifdef VICEMAN
\vdmtoolsmanualscsk{VDM++ 言語マニュアル VICE編}{2.0 beta}
#else
#ifdef VDMSL
\vdmtoolsmanualscsk{VDM-SL 言語マニュアル}{2.0}
#endif VDMSL
#ifdef VDMPP
\vdmtoolsmanualscsk{VDM++ 言語マニュアル}{2.0}
#endif VDMPP
#endif VICEMAN


\newcommand{\Lit}[1]{`{\tt #1}\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\index{#1}\ \ \= = \ \ \= #2  ; %    Adds production rule to index
    
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{`{\sf #1}\Quote}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}
\newlength{\kwlen}
\newcommand{\Keyw}[1]{\settowidth{\kwlen}{\tt #1}\makebox[\kwlen][l]{\sf
    #1}}
\newcommand{\keyw}[1]{{\sf #1}}
\newcommand{\id}[1]{{\tt #1}}
\newcommand{\metaiv}[1]{\begin{alltt}\input{#1}\end{alltt}}

\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\MAP}[2]{\kw{map }#1\kw{ to }#2}
\newcommand{\INMAP}[2]{\kw{inmap }#1\kw{ to }#2}
\newcommand{\SEQ}[1]{\kw{seq of }#1}
\newcommand{\NSEQ}[1]{\kw{seq1 of }#1}
\newcommand{\SET}[1]{\kw{set of }#1}
\newcommand{\PROD}[2]{#1 * #2}
\newcommand{\TO}[2]{$#1 \To #2$}
\newcommand{\FUN}[2]{#1 \To #2}
\newcommand{\PUBLIC}{\ifthenelse{\boolean{VDMpp}}{public\mbox{}}{\mbox{}}}
\newcommand{\PRIVATE}{\ifthenelse{\boolean{VDMpp}}{private}{\mbox{}}}
\newcommand{\PROTECTED}{\ifthenelse{\boolean{VDMpp}}{protected}{\mbox{}}}


% No line numbering
%\nolinenumbering
%\setindent{outer}{\parindent}
%\setindent{inner}{0.0em}


\section{導入}

#ifdef VDMPP

{\vdmpp} は、技術分野~\cite{Fitzgerald&98}において特有の並列性、実時間をともなうオブジェクト指向システムを、記述することを意図した形式仕様記述言語である。
この言語は \vdmsl~\cite{ISOVDM96}を基にして、Smalltalk-80 やJavaといった
言語に現存するクラスやオブジェクトの概念を加えての拡張がなされてきた。
この両者の結合により、オブジェクト指向形式仕様記述の発展が促されている。
#ifdef VICEMAN
VICEは、「VDM++ In Constrained Environments」の略である。
そして、このVDMの改良が適切なモデルとリアルタイム分散組込みシステムに使われる。 \cite{Verhoef&06b}
#endif VICEMAN

\subsection{本書について}

本書は{\vdmpp}の言語参照マニュアルである。
{\vdmpp}言語構文の構成を文法法則を用いて定義している。
各々の言語構造の意味はまず非形式な方法で説明され、次にいくつかの小さな例題が与えられる。
「順読み」を想定するよりは「検索」利用を目的に記述されているため、チュートリアルではなくマニュアルである。
読者には、オブジェクト指向プログラミング／デザインという概念に親しみ身近に感じられるようになられることを期待する。
本書ではUnicode具象構文(交換具象構文)を用いることとし、すべての予約語を特別なキーワード・フォントで示す。
これは本書が、Unicode記号を入力とする {\vdmpp} Toolbox の言語マニュアルだからである。
数学的な具象構文は、Toolboxを用いることで自動的に生成することができるので、更にみかけのよい構文をつくることが可能となる。

\subsection{言語の歴史}

{\vdmpp}は、1992年以来現在に至るまでも未だ開発途上にある；その最初の記述については\cite{Durr92a}を参照。
かつては AFRODITE\footnote{AFRODITE は欧州連合の支援のもとに行われたESPRIT計画に含まれる(EP6500).}プロジェクトの一部として、飛躍的な発展をとげてきた。
したがって、{\vdmpp}はAFRODITEプロジェクトの中での開発に基盤を置く。 
言語開発過程においては、数多くの大規模なケーススタディからのフィードバックおよび言語評価がなされてきている。
その {\vdmpp} 言語を支えるのが  {\vdmpp} Toolboxである。
このToolboxでは、構文チェッカー、静的意味チェッカー、インタープリタ\footnote{加えて,清書機能、デバッグ機能、テストカバレージサポートを提供するが、これらは基本構成要素である。}、C++コード生成、それにUMLリンクの機能を持つ。
一般的にはISO/VDM-SLは実行不可能な言語なので、インタープリタはこの言語の一部分をサポートしているに過ぎない。
本書では特に、VDM-SLの意味とインタープリタにおいて用いられる意味との違いに焦点をあてる。
そのため本書では、{\vdmpp} Toolboxにおけるインタープリタを引用する場合をすべて「インタープリタ」と記述する。

\subsection{本書の構成}

第 ~\ref{conformance} 章では、本書に示された言語および関連する \vdmpp\ Toolboxが、いかにVDM-SL標準に準拠しているかを述べる。
第 ~\ref{syntax-notation} 章では、構文構造の記述に用いられるBNF記法を紹介する。
 \vdmpp\ 表記法については、第 ~\ref{typedef} 章から 第 ~\ref{ch:thread} 章までで述べる。
第 ~\ref{diff} 章では、ISO/VDM-SL と  \vdmpp\ との相違点をリストアップし、
第 ~\ref{static} 章では、\vdmpp\ の静的意味について簡単に説明する。
言語の全構文は 付録 ~\ref{app-a} に、語彙の仕様は 付録 ~\ref{app-b} に、演算子の優先順位は 付録 ~\ref{app-c} に示す。
付録 ~\ref{sec:diff} では、数学構文とASCII具象構文の記号の違いをリスト(一覧表)に示す。
標準ライブラリの詳細と使用法は、付録 ~\ref{stdlib} にて示す。
最後には、本書中の全構文規則定義に対しての索引が与えられている。
#endif VDMPP

#ifdef VDMSL
この文書では、モジュール拡張を行なった、基本的には標準ISO/VDM-SL \cite{ISOVDM96}である、VDM-SL言語の構文と意味定義を述べる
\footnote{その他にもいくつかの拡張が含まれている。}。
また,全ての構文上正しい{\vdmsl}仕様記述は{\vdmsl}内でも正しいことに注意する。
私たちは、明確に、理解しやすい方法で言語を提供しようとしているが、
この文書は完全な{\vdmsl}の参照マニュアルではない。
言語の説明のより詳しいところは、文献\footnote{VDM-SLにおける証明が\cite{Jones90a}と\cite{Bicarregui&94}で最もよく扱われるにもかかわらず、より多くの参考書は、
\cite{Fitzgerald&98}で与えられる}を参照している。
VDM-SL記法がVDM-SL標準の表記法と異なっているところは全て、言うまでもなく、意味定義を入念に説明する。

VDM-SL言語はVDM-SL Toolboxによってサポートされた言語である。
(\cite{UserMan-SCSK})
このToolboxは構文チェッカー、静的な意味定義チェッカー、インタープリタ\footnote{Toolboxは清書機能、デバック機能、
テスト適用範囲のサポートを提供するのに加わっているが、これらは基本的なコンポーネントである。} 、
およびC++へのコードジェネレータを含んでいる。
一般的に、ISO/VDM-SLが非実行可能な言語であるので、インタープリタは言語の部分集合だけをサポートする。
この文書は特にVDM-SL の意味定義がインタープリタで使用され
る意味定義と異なっている部分に焦点をあてていく。この文書内では、VDM-SL Toolboxからイン
タープリタについて言及するときは、いつも、「インタープリ
タ」という用語を使用していく。そして、ある言語の構成要素の意味定義がVDM-SL標準
と全く同じであるときは、”VDM-SL”について言及していく

その結果、ASCII(また、置き換えと呼ばれる) 具象構文を使用するが、
私たちは特別なキーワード字体ですべての予約語を表示していく。こうする理由は、
その文書ではASCII記法が入力として使用されているVDM-SL Toolboxの言語マニュアルとして機能するからである。
数学的な具象構文は、Toolboxによって、自動的に生成することができ、より見やすい構文を作り出すことができる。

セクション~\ref{conformance}は、その言語がどうここで紹介されるのか、また、対応しているVDM-SL Toolbox
がどのようにVDM-SL標準に一致するのかを示す。

セクション~\ref{syntax-notation}は構文の構成要素の記述に使用されるBNF記法を紹介する。VDM-SL
の表記法はセクション~\ref{typedef}からセクション~\ref{top-level}で述べられる。セクション~\ref{diff}は
ISO/VDM-SLとVDM-SLの違いに関する全リストを提供する。さらにセクション~\ref{static}はVDM-SLの静的な意味定義の短い説明を含む。

付録~\ref{app-a}では、完全な言語の構文、付録~\ref{app-b}では語彙詳細、付録~\ref{app-c}では演算子の優先順位を紹介する。
付録~\ref{sec:diff}では数学の構文シンボルとASCII 具象構文の違いをリストで紹介する。
付録~\ref{stdlib}では、標準 ライブラリの詳細と使用方法を提供する。
最終的には、文書内における全ての構文ルールの存在を定義するインデックスを提供する。

#endif VDMSL

\section{準拠事項}
\label{conformance}

標準規格であるVDM-SLには、いくつかの準拠レベルを記載する準拠事項の節がある。
最も低レベルでの準拠事項は構文一致である。
\vdmslpp{\vdmsl}{\vdmpp} Toolboxでは、\vdmslpp{標準}{標準のもの、例外は第\ref{diff}章にて記述される}の構文記述に従った仕様記述を受け入れる。
加えて、準拠条項に従えば排除されるべき多くの拡張記述(第\ref{diff}章参照)についても受け入れる。

準拠事項レベル1では、恐らくの正しさに対する静的意味を扱う(第~\ref{static}章参照)。
ここでは、恐らくは良形である標準記述を対象にし、他に多く存在するさまざまな記述は極力排除することとした
\footnote{例えば述語が存在する集合の理解において、標準記述では(恐らくは良形であることのチェックでは)
要素式に対する検査をまったく行わない。なぜなら、述語はfalseとなる可能性がある
(したがって全式が空集合を表すことになる可能性がある)からである。
読者はこの例を実際試すことにも興味をもつであろうと確信する。}。

準拠事項レベル2およびこれ以降のレベル(最終レベル以外)では、絶対的な良形であることの静的意味チェックと、静的意味に加えられるいくつかのおこりうる拡張チェックについて扱う。
絶対的に良形であることの検査機能はToolboxが持っている。
しかしながら、実際例においてはこれが最も価値あるものとは考えない。
なぜなら「現実にある」例に対し、ほとんどすべての記述がこの検査をパスすることはないからである。

準拠最終レベルでは動的意味を扱う。
ここで、標準の動的意味(これは実行可能でない)からどのように逸脱しているかについては、添付書類を用いた詳細の提供が求められている。
本書では、どのような構成要素がToolboxにて翻訳されるか、ほんの少しの構成要素において逸脱するものが何であるかを説明し、この要求に事実上答える。
このようにこの準拠レベルは、\vdmslpp{VDM-SL}{\vdmpp}Toolboxの存在で条件が満たされている。

まとめれば、 \vdmslpp{VDM-SL}{\vdmpp}はきわめて標準準拠に近いと言うことができるが、これを保証するに十分な時間は未だ費やされていない。

\section{具象構文表記法}
\label{syntax-notation}

本書の中で、一部の言語構文については常にBNF表記を用いる。
使用されるBNF表記法には、以下に示すような特殊記号が用いられる:

\newcommand{\singleQuote}{\texttt{\symbol{34}}}
\begin{tabular}{l@{\hspace{1cm}}p{10cm}}
  , &  連結記号 \\
  = &  定義記号 \\
  \dsepl & 定義分離記号(選択枝)\\
  \OptPt{} & オプションの構文項目を囲む \\
  \SeqPt{} & 0回以上出現する構文項目を囲む \\
  \Lit{ } & シングル引用リテラルは終端記号を囲むのに使用される \\
    メタ識別子 & 非終端記号は小文字(空白も含む)で記される \\
  ;  & 1つの規則の終わりを表わす終了記号\\
  (\ ) & グループ化に用いられる、つまり``a, (b\dsepl c)'' は
    ``a, b\dsepl a, c''と等しい。 \\
  -- & 終端記号の集合からの減算を表す(つまり ``character -- (\Lit{\singleQuote})'' はダブル引用リテラルを除くすべての文字を表す。)
\end{tabular}

\section{データ型定義}
\label{typedef}

伝統的なプログラミング言語と同様に、\vdmslpp{\vdmsl}{\vdmpp}においてもデータ型を定義し適切な名称を与えることができる。
例えば次のような等式が与えられたとする:

\begin{alltt}
  Amount = \keyw{nat}
\end{alltt}
ここでは``{\tt Amount(合計)}''という名のデータ型を定義し、この型に属する値は自然数であると述べている(\keyw{nat(自然数)} は以下に記述される基本型の1つである)。
\vdmslpp{\vdmsl}{\vdmpp}の型体系で全般に共通する1つは、今この点について述べることは重要だが、相等と不等とはどのような値間にも用いることができるということである。 
プログラミング言語においてはしばしば、演算対象が同じ型であることを要求される。
\vdmslpp{\vdmsl}{\vdmpp}では合併型(以下に示す)と呼ばれる構造があるので、これには当てはまらない。

この節では、データ型定義の構文について述べる。
加えて、ある型に属する値はどのように構成され操作されうるのか(組込み演算子を用いて)について述べる。
最初に基本データ型を示し、次に合成型へと進めよう。

\subsection{基本データ型}

以下にいくつかの基本型を提示する。
その各々は次を含む:

\begin{itemize}
\item 構成の名称
\item 構成の記号
\item そのデータに属する特殊な値
\item そのデータ型に属する値のための組込み演算子。
\item 組込み演算子の意味定義。
\item 組込み演算子の使用例
  \footnote{これらの例題中では、メタ記号`$\equiv$'を用いて与えられた例題が何と同等であるかを示す。}
\end{itemize}
組込み演算子の各々については、その意味定義の記述と共に、名称、記号、そして演算子の型が与えられる(ただし相等と不等の意味については、通常の意味に従うので、記述されていない。)
意味定義の記述において、識別子は例えば\ {\tt a}, {\tt b}, {\tt x}, {\tt y}他 といったもので、対応する演算子型の定義で使用されるものを参照している。

基本型とは、言語により定義されていて、それ以上単純な値には分解することができない異なる値をもっている型とされる。
主要な基本型として5つ：ブール型、数値型、文字型、トークン型、引用型 が挙げられる。
以下にこの基本型について1つずつ説明していこう。

\subsubsection{ブール型}\label{bool}

一般的に \vdmslpp{\vdmsl}{\vdmpp} では、その中で計算が終了しなかったり結果を出せなかったりするかもしれないシステムを対象とすることも許されている。
このような潜在的な未定義状態を取り扱うために、\vdmslpp{\vdmsl}{\vdmpp} では3値論理：値は「true(真)」、「false(偽)」、「bottom/undefined(未定義)」のいずれかであるとする、を取り入る。
インタプリターの意味定義は、演算対象の順番に重きをおかないLPF (Logic of Partial Functions、部分関数の論理) の3値論理(\cite{Jones90a}参照)をもつものではないという意味において、 \vdmsl\ のものとは異なる。
それでも、論理積\keyw{and}、論理和\keyw{or}、それに含意演算子は、最初の演算対象のみで結果を決定するのに十分であるならば、次の演算対象をあえて評価しようとはしない、という条件つきの意味定義をもつ。
ある意味で、インタプリターの論理の意味定義は3値であると、VDM-SLに関してはまだ考えることができるであろう。
しかしながら、未定義値は無限大ループやランタイムエラーになる可能性がある。

\begin{description}
\item[名称:] \Index{ブール}
\item[記号:] \Index{\keyw{bool}}
\item[値:] \Index{\keyw{true}}, \Index{\keyw{false}}
\item[演算子:] 下記の{\tt a} と {\tt b} は任意のブール式を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称       & 型                       \\ \hline
    {\tt \keyw{not} b}& 否定   & \TO{\keyw{bool}}{\keyw{bool}} \\
    {\tt a \keyw{and} b}& 論理積& \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a \keyw{or} b}& 論理和 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a => b}& 含意 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <=> b}& 同値 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a = b} & 相等 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    {\tt a <> b}& 不等 & \TO{\PROD{\keyw{bool}}{\keyw{bool}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{not}}\index{Negation}\index{\keyw{and}}\index{Conjunction}%
\index{\keyw{or}}\index{Disjunction}%
\index{\texttt{=>}}\index{Implication}\index{\texttt{<=>}}\index{Biimplication}%
\index{\texttt{=}!boolean equality}\index{Equality!boolean type}\index{\texttt{<>}!boolean inequality}\index{Inequality!boolean type}


\item[演算子の意味定義:] 意味定義では、ブール値を扱う場合の {\tt <=>} と {\tt =} は等しい。 
\keyw{and}、 \keyw{or}、および {\tt=>}においては条件つきの意味定義がある。
$\perp$によって定義されていない項目 (たとえば定義域外のキーをもつ写像に適用される)を表示しよう。
ブール演算子に対する真理値表は次のとおり%
  \footnote{標準 VDM-SL ではこれらの真理値表は({\tt =>}以外は)対称性をもつことに注目しよう。}:
     
  \begin{tabular}{ll}
    否定 {\tt \keyw{not} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      {\tt \keyw{not} b}  & \keyw{false}  & \keyw{true} & $\perp$ \\ \hline
    \end{tabular}\\
    \mbox{} & \\
    論理積 {\tt a \keyw{and} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{false} & \keyw{false} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    論理和 {\tt a \keyw{or} b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{true} & \keyw{true} \\
      \keyw{false} & \keyw{true} & \keyw{false} & $\perp$ \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    含意 {\tt a => b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $a \backslash b $   & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{true} & \keyw{true} & \keyw{true} \\
      $\perp$& $\perp$&$\perp$&$\perp$\\\hline
    \end{tabular}\\
    \mbox{} & \\
    同値 {\tt a <=> b} &
    \begin{tabular}{|l|l|l|l|}\hline
      $ a \backslash b$    & \keyw{true}  & \keyw{false} & $\perp$ \\ \hline
      \keyw{true}  & \keyw{true}  & \keyw{false} & $\perp$ \\
      \keyw{false} & \keyw{false} & \keyw{true}  & $\perp$ \\
      $\perp$&$\perp$ &$\perp$ & $\perp$ \\ \hline
    \end{tabular}\\
  \end{tabular}     

\item[例題:] 
   {\tt a = \keyw{true}} で {\tt b = \keyw{false}} と仮定すると次のとおり:
  
  \begin{tabular}{lcl}
    {\tt \keyw{not} a} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{and} b} & $\equiv$ & \keyw{false} \\
    {\tt b \keyw{and} $\perp$} & $\equiv$ & \keyw{false} \\
    {\tt a \keyw{or} b} & $\equiv$ & \keyw{true} \\
    {\tt a \keyw{or} $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a => b} & $\equiv$ & \keyw{false} \\
    {\tt b => b} & $\equiv$ & \keyw{true} \\
    {\tt b => $\perp$} & $\equiv$ & \keyw{true} \\
    {\tt a <=> b} & $\equiv$ & \keyw{false} \\
    {\tt a = b} & $\equiv$ & \keyw{false} \\
    {\tt a <> b} & $\equiv$ & \keyw{true} \\
    {\tt $\perp$ \keyw{or} \keyw{not} $\perp$} & $\equiv$ & $\perp$\\
    {\tt (b \keyw{and} $\perp$) \keyw{or} ($\perp$ \keyw{and}
    \keyw{false})} & $\equiv$ & $\perp$
  \end{tabular}
\end{description}

\subsubsection{数値型}\label{numeric}

数値型には5つの基本型：正の自然数、自然数、整数、有理数、そして実数がある。
3つを除きどの数値演算子も、演算対象として5つの型の混在を許す。
例外である3つとは、整数除算、法算、剰余算、である。

5つの数値型は階層構造をなし、\Index{\keyw{実数(real)}}が最も一般的な型で{\keyw{有理数(rat)}}\footnote{\vdmslpp{\vdmsl}{\vdmpp}\ Toolboxの見地からすれば \keyw{実数(real)} と \keyw{有理数(rat)} は違いがない。コンピューター上では有理数しか表現できないからである。}、\Index{\keyw{整数(int)}}、\Index{\keyw{自然数(nat)}}、\Index{\keyw{正の自然数(nat1)}}と続く。 

\vspace{1ex}
\begin{tabular}{|l|l|} \hline
  型 & 値 \\ \hline
  \keyw{nat1}& {\tt 1, 2, 3, \ldots}\\
  \keyw{nat} & {\tt 0, 1, 2, \ldots}\\
  \keyw{int} & {\tt \ldots, -2, -1, 0, 1, \ldots}\\
  \keyw{real} & {\tt \ldots, -12.78356, \ldots, 0, \ldots, 3, \ldots, 1726.34, \ldots}\\ \hline
\end{tabular}

\mbox{}\\
この表より、\keyw{int}ならばどのような数でも自動的に\keyw{real}であるが、\keyw{nat}であるとは限らないということがわかる。
言い換えると、正の自然数は自然数の一部であり、その自然数は整数の、その整数は有理数の、有理数は最終的には実数の一部である、と表現することができる。
次の表でいくつかの数が属する型を示す：

\vspace{1ex}
\begin{tabular}{|c|l|} \hline
  数 & 型 \\ \hline
  {\tt 3}      & \keyw{real, rat, int, nat, nat1} \\
  {\tt 3.0}    & \keyw{real, rat, int, nat, nat1} \\
  {\tt 0}      & \keyw{real, rat, int, nat} \\
  {\tt -1}     & \keyw{real, rat, int}\\
  {\tt 3.1415} & \keyw{real, rat} \\ \hline
\end{tabular}

\mbox{}\\
すべての数が必然的に \keyw{real}型 (そして\keyw{rat}型)であることに注意。

\begin{description}
\item[名称:] 実数, 有理数, 整数, 自然数、そして 正の自然数
\item[記号:] \keyw{real}, \keyw{rat}, \keyw{int}, \keyw{nat},
  \keyw{nat1}
\item[値:] {\tt \ldots, -3.89, \ldots, -2, \ldots, 0, \ldots, 4,
    \ldots, 1074.345, \ldots}
\item[演算子:]  以下における{\tt x} と {\tt y} は数式を表すとする。  
 これらの型について仮定はなされない。

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称 & 型 \\ \hline
    {\tt -x}& 負符号 & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{abs} x}& 絶対値 & \TO{\keyw{real}}{\keyw{real}} \\
    {\tt \keyw{floor} x}& 底値  & \TO{\keyw{real}}{\keyw{int}} \\
    {\tt x + y}& 加算 & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x - y}& 減算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x * y}& 乗算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x / y}& 除算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x \keyw{div} y}& 整数除算& \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{rem} y}& 剰余算& \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x \keyw{mod} y}& 法算 & \TO{\PROD{\keyw{int}}{\keyw{int}}}{\keyw{int}} \\
    {\tt x**y}& べき算& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{real}} \\
    {\tt x < y}& より小さい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x > y}& より大きい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <= y}& より小さいか等しい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x >= y}& より大きいか等しい& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x = y}& 相等 & \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    {\tt x <> y}& 不等& \TO{\PROD{\keyw{real}}{\keyw{real}}}{\keyw{bool}} \\
    \hline     
  \end{tabular}%
\index{\texttt{-}}\index{Unary minus}\index{\keyw{abs}}\index{Absolute value}%
\index{\keyw{floor}}\index{Floor}\index{\texttt{+}}\index{Sum}\index{Difference!numeric}%
\index{\texttt{*}}\index{Product}\index{\texttt{/}}\index{Division}%
\index{\keyw{div}}\index{Integer division}\index{\keyw{mod}}\index{Remainder}%
\index{\keyw{mod}}\index{Modulus}\index{\texttt{**}!numeric power}\index{Power}%
\index{\texttt{<}}\index{Less than}\index{\texttt{>}}\index{Greater than}%
\index{\texttt{<=}}\index{Less or equal}\index{\texttt{>=}}\index{Greater or equal}%
\index{\texttt{=}!numeric equality}\index{Equality!numeric type}\index{\texttt{<>}!numeric inequality}\index{Inequality!numeric type}

  演算対象として書かれた型は、許される限りでの最も広範な型である。
 例えば負符号は5つのすべての型 (\keyw{nat1}, \keyw{nat}, \keyw{int} \keyw{rat} そして \keyw{real})を演算対象とする、ことを示している。
     
\item[演算子の意味:] 演算子であるマイナス符号、総和、差、積、商、小さい、大きい、等しいか小さい、等しいか大きい、相等関係、不等関係はこのような演算の通常の意味をもつ。

 \vspace{1ex}
 \begin{TypeSemantics}
    底値 &  {\tt x}と等しいかより小さい整数のうちで最大のもの \\ \hline

    絶対値 &  {\tt x}の絶対値、つまり {\tt x >= 0} ならば\ {\tt   x} そのままで{\tt x < 0}ならば {\tt -x}となる \\ \hline

    冪 &  {\tt x} を {\tt y}回乗じたもの \\ \hline
  \end{TypeSemantics}

  \vspace{1ex}
 整数商、剰余、そして法　が負の数にどのように作用するかについては、しばしば混乱がおきる。 
事実  {\tt -14 \keyw{div} 3}に対して有効な答えが２つある:  Toolboxにおいてと同様{\tt -4} (the intuitive)となるか、たとえば\ Standard ML  \cite{Paulson91}においてと同様に{\tt -5}となるかである。
したがってこれらの演算については詳細に説明しておくべきであろう。

  整数除算は {\sf floor} と実数除算を用いて定義される:

  \begin{alltt}
    x/y <  0:   x \keyw{div} y = -\keyw{floor}(\keyw{abs}(-x/y))
    x/y >= 0:   x \keyw{div} y =  \keyw{floor}(\keyw{abs}(x/y))
  \end{alltt}

 右辺の \keyw{floor}と \keyw{abs}の順により違いが生じ、その順を交換することで上記の例題は{\tt -5} となる。 
これは \keyw{floor} は常により小さい（か等しい）整数に従うからである、たとえば\ {\tt \keyw{floor} (14/3)} は {\tt    4}である一方  {\tt \keyw{floor} (-14/3)} は {\tt -5}である。

剰余 {\tt x \keyw{rem} y} と　法 {\tt x \keyw{mod} y} は、
 {\tt x} と {\tt y} の符号が同じであれば同じ値となるが、そうでない場合は異なる値となり、 \keyw{rem}は{\tt x}の符号を\keyw{mod}は{\tt y}の符号をとる。
剰余と法の公式は次のとおり:
  \begin{alltt}
    x \keyw{rem} y = x - y * (x \keyw{div} y)
    x \keyw{mod} y = x - y * \keyw{floor}(x/y)
  \end{alltt}
 そのため, {\tt -14 \keyw{rem} 3} は {\tt -2} に等しく、 {\tt -14
    \keyw{mod} 3} は {\tt 1}に等しい。 
実数軸をたどり、 {\tt -14} から進め {\tt 3}づつジャンプすることで、これらの結果を確認することができる。 
剰余はたどった負の数の最後の値であるが、それは{\tt x}にあたる最初の引数が負であるからであり、一方の法はたどった正の数の最初の値であるが、それは {\tt y} にあたる２番目の引数が正であるからである。

\item[例題:]  {\tt a = 7, b = 3.5, c = 3.1415, d = -3, e = 2} とすると:

  \begin{longtable}{lcl}
    {\tt - a}&$\equiv$& -7                     \\
    {\tt \keyw{abs} a}&$\equiv$& 7                    \\
    {\tt \keyw{abs} d}&$\equiv$& 3                    \\
    {\tt \keyw{floor} a <= a}&$\equiv$& \keyw{true}   \\
    {\tt a + d}&$\equiv$& $4$                  \\
    {\tt a * b}&$\equiv$& $24.5$               \\
    {\tt a / b}&$\equiv$& $2$                \\
    {\tt a \keyw{div} e}&$\equiv$& $3$                \\
    {\tt a \keyw{div} d}&$\equiv$& $-2$               \\
    {\tt a \keyw{mod} e}&$\equiv$& $1$                \\
    {\tt a \keyw{mod} d}&$\equiv$& $-2$               \\
    {\tt -a \keyw{mod} d}&$\equiv$& $-1$               \\
    {\tt a \keyw{rem} e}&$\equiv$& $1$                \\
    {\tt a \keyw{rem} d}&$\equiv$& $1$                \\
    {\tt -a \keyw{rem} d}&$\equiv$& $-1$              \\
    {\tt 3**2 + 4**2 = 5**2} &$\equiv$ &\keyw{true}   \\
    {\tt b < c}&$\equiv$& \keyw{false}                \\
    {\tt b > c}&$\equiv$& \keyw{true}                 \\
    {\tt a <= d}&$\equiv$& \keyw{false}               \\
    {\tt b >= e}&$\equiv$& \keyw{true}                \\
    {\tt a = e}&$\equiv$& \keyw{false}                \\
    {\tt a = 7.0}&$\equiv$& \keyw{true}               \\
    {\tt c <> d}&$\equiv$& \keyw{true}                \\
    {\tt \keyw{abs} c < 0} & $\equiv$ & \keyw{false}  \\
    {\tt (a \keyw{div} e) * e} & $\equiv$ & 6       
  \end{longtable}
\end{description}

\subsubsection{文字型}

文字型は、VDM 文字集合(~\pageref{charSetTable}ページの表~\ref{charSetTable}を参照)中の単一の文字すべてを含む。

\begin{description}
\item[名称:] \Index{文字}
\item[記号:] \Index{\keyw{char}}
\item[値:] {\tt 'a', 'b',} \ldots, {\tt '1', '2',} \ldots {\tt
                '+', '-'} \ldots
\item[演算子:]  次の{\tt c1} と {\tt c2} は任意の文字を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子       & 名称      & 型 \\ \hline
    {\tt c1 = c2}  & 相等     & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    {\tt c1 <> c2} & 不等 & \TO{\PROD{\keyw{char}}{\keyw{char}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!char equality}\index{Equality!char}\index{\texttt{<>}!char inequality}\index{Inequality!char}


\item[例題:] 
 \mbox{}

  \begin{tabular}{lcl}
    {\tt 'a' = 'b'} &$\equiv$& \keyw{false}\\
    {\tt '1' = 'c'} &$\equiv$& \keyw{false}\\
    {\tt 'd' <> '7'} &$\equiv$& \keyw{true}\\
    {\tt 'e' = 'e'} &$\equiv$& \keyw{true}\\
  \end{tabular}
\end{description}

\subsubsection{引用型}

引用型は、パスカルのようなプログラミング言語においては列挙型に相当する。
しかしながら\vdmslpp{\vdmsl}{\vdmpp}\ においては、中括弧の中に様々な引用リテラルを書く代わりに引用型というシングル引用リテラルからなるものを用いて、それらを合併型の一部をなすものとする。
%Quote literals are recognized
%by being a sequence of $\const{distinguished letters}$ (which cannot be
%used for any other purpose).

\begin{description}
\item[名称:] \Index{引用}
\item[記号:] たとえば {\tt <QuoteLit>}\index{\texttt{<>}!引用値}
\item[値:] {\tt <RED>, <CAR>, <QuoteLit>,} \ldots
\item[演算子:] 以下の \texttt{q} と \texttt{r} が、列挙型{\tt T}に属する任意の引用値を表していると仮定すると: 

  \begin{tabular}{|l|l|l|}\hline
    演算子     & 名称      & 型 \\ \hline
    {\tt q = r}  & 相等     & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt q <> r} & 不等 & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!quote equality}\index{Equality!quote type}\index{\texttt{<>}!quote inequality}\index{Inequality!quote}


\item[例題:]  \texttt{T} を次に定義された型とする:

  \begin{tabular}{l}
    {\tt T = <France> | <Denmark> | <SouthAfrica> | <SaudiArabia>} \\
  \end{tabular}

  ここで {\tt a = <France>}であるならば次のとおり:

  \begin{tabular}{lcl}
     {\tt <France> = <Denmark>} & $\equiv$ & \keyw{false}\\
     {\tt <SaudiArabia> <> <SouthAfrica>} & $\equiv$ & \keyw{true}\\
     {\tt a <> <France>} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsubsection{トークン型}

トークン型は、トークンと呼ばれる異なる値の可算無限集合からなる。
トークンに対して実行される操作は、相等と不等のみである。
 \vdmslpp{\vdmsl,}{\vdmpp,}におけるトークンは、\keyw{mk\_token}を用いて任意の式を囲む記述ができるのにもかかわらず、単独に表現することはできない。
これが、トークン型を含む仕様のテストを可能にする方法である。
しかしながら\vdmsl\ 標準に似せるためには、これらのトークン値はどんなパターンマッチングによっても分解できず、相等または不等の比較以外どのような演算にも用いることはできない。

\begin{description}
\item[名称:] \Index{トークン}
\item[記号:] \Index{\keyw{token}}
\item[値:] \index{\keyw{mk\_}!token value}{\tt \keyw{mk\_token}(5)},
  {\tt \keyw{mk\_token}(\{9, 3\})}, {\tt
    \keyw{mk\_token}([\keyw{true}, \{\}])}, \ldots%\index
\item[演算子:] 以下の {\tt s} と {\tt  t} は任意のトークン値を表す:

  \begin{tabular}{|l|l|l|}\hline
    演算子     & 名称      & 型 \\ \hline
    {\tt s = t}  & 相等     & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    {\tt s <> t} & 不等 & \TO{\PROD{\keyw{token}}{\keyw{token}}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!token equality}\index{Equality!token type}\index{\texttt{<>}!token inequality}\index{Inequality!token type}

\item[例題:] 次においてたとえば {\tt s = \keyw{mk\_token}(6)} 、 {\tt t
    = \keyw{mk\_token}(1)} とすると:

  \begin{tabular}{lcl}
    {\tt s = t} &$\equiv$& \keyw{false} \\
    {\tt s <> t} &$\equiv$& \keyw{true} \\
    {\tt s = \keyw{mk\_token}(6)} & $\equiv$& \keyw{true} \\
  \end{tabular}
\end{description}

\subsection{合成型}

以下に合成型について記述する。 
各々は次を含む：
\begin{itemize}
\item 合成型定義の構文
\item 構成要素をどのように用いるか示す等式
\item この型に属する値をどのように構成するか示す例題
ほとんどの場合に、基本構成子式の構文が与えられている前の節への参照が示される。
\item この型に属する値に対する演算子 \footnote{これらの演算子は、第~\ref{unandbin}節で全演算子が与えられるなかの単項式か2項式に用いられている。}
\item 演算子の意味定義
\item 演算子の使用例
\end{itemize}
演算子の各々に対し、名称、記号、演算子の型がその意味定義と共に与えられる (ただし相等と不等については、通常の意味に従うとして除かれる)。 
意味定義記述において、識別子はたとえば \ {\tt m}, {\tt m1}, {\tt s}, {\tt s1} 他 というような、対応する演算子型定義で用いられたものを参照する。

\subsubsection{集合型}
\label{sets}

集合とは、値を順番をつけずに集めたものであり、それらはすべて同じ型のもので\footnote{ただし合併型を用いれば、2つの値に共通な型を見つけ出すのは常に可能であることに注意 (第~\ref{unions}節参照)。}、全体は1つとして扱われる。
\vdmslpp{\vdmsl}{\vdmpp}\ におけるすべての集合は有限である、なぜならばもともと有限個の要素しか含められないからだ。 
集合型の要素は任意の合成型でありうるし、例えば集合自身の集合であってもよい。

以下の記述には次の合意を用いる：{\tt A}は任意の型、 {\tt S} は集合型、 {\tt s}、 {\tt s1}、 {\tt s2} は集合値、 {\tt ss} は集合値の集合、 {\tt e}、 {\tt e1}、 {\tt e2}、 {\tt en} は集合の要素、 {\tt bd1,} {\tt bd2}、 \ldots、{\tt bdm} は集合または型を示す識別子を束ねたもの、そして {\tt P} は論理述語である。

\begin{description}
\item[構文:] 
  \Rule{型}{
   \Ruleref{集合型} \dsep
    \ldots
    }
  
  \Rule{集合型}{\Lop{set of}, \Ruleref{型}}

\item[等式:] {\tt S = \keyw{set of} A}\index{\keyw{set of}}

\item[構成子:] \mbox{}

  \begin{description}
  \item[集合列挙:] \verb|{e1, e2, ..., en}|  は列挙された要素の集合を構成する。
空集合は {\tt \{\}}と表記される。
  
  \item[集合内包:] \verb+{e | bd1, bd2, ..., bdm & P}+
    は、述語{\tt P}が\keyw{true}となるすべての束縛について式{\tt e} を評価することにより集合を定義する。
    束縛は集合束縛と型束縛のどちらかとなる\footnote{型束縛は実行可能ではないので一般的にはインタープリタで実行されない (これについては第~\ref{bind}節を参照)。}。  
集合束縛 {\tt bdn} は {\tt pat1, \ldots, patp \keyw{in set} s}という形式をもつが、ここでの{\tt pati}はパターン (通常は単純な識別子である)であり、 {\tt s} は1つの式で構成される集合である。 
型束縛も、\keyw{in set}がコロンに換わり {\tt s}が型式となるという意味において、同様のものである。 
  \end{description}
  すべての集合式に対する構文と意味定義は、第~\ref{setexpr}節に与えられる
\index{\texttt{\{\}}!set enumeration}\index{\texttt{\{"|\}}!set comprehension}\index{\texttt{\&}!set comprehension}
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt e \keyw{in set} s1} & 帰属 & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt e \keyw{not in set} s1} & 非帰属 & \TO{\PROD{A}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{union} s2}& 合併 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{inter} s2}& 共通部分 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 {\tt \char'134} s2}& 差 & \TO{\PROD{\SET{A}}{\SET{A}}}{\SET{A}} \\
    {\tt s1 \keyw{subset} s2}& 包含 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 \keyw{psubset} s2} & 真包含 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 = s2}& 相等 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt s1 <> s2}& 不等 & \TO{\PROD{\SET{A}}{\SET{A}}}{\keyw{bool}} \\
    {\tt \keyw{card} s1}& 濃度 & \TO{\SET{A}}{\keyw{nat}} \\
    {\tt \keyw{dunion} ss}& 分配的合併& \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{dinter} ss}&分配的共通部分 & \TO{\SET{\SET{A}}}{\SET{A}} \\
    {\tt \keyw{power} s1}&有限べき集合 & \TO{\SET{A}}{\SET{\SET{A}}} \\
    \hline
  \end{tabular}%
\index{\keyw{in set}}\index{Membership}\index{\keyw{not in set}}\index{Not membership}%
\index{\keyw{union}}\index{Union}\index{\keyw{inter}}\index{Intersection}%
\index{\texttt{\char'134}}\index{Difference!set}\index{\keyw{subset}}\index{Subset}%
\index{\keyw{psubset}}\index{Proper subset}\index{\texttt{=}!set equality}\index{Equality!set type}%
\index{\texttt{<>}!set inequality}\index{Inequality!set type}\index{\keyw{card}}\index{Cardinality}%
\index{\keyw{dunion}}\index{Distributed union}\index{\keyw{dinter}}\index{Distributed intersection}%
\index{\keyw{power}}\index{Finite power set}

  {\tt A, \SET{A}}型と {\tt \SET{\SET{A}}}型は単に型の構造を表すだけではないことに注意。 
たとえば、任意の集合 {\tt s1} と {\tt s2}の合併を行った場合、結果の集合の型は2つの集合型の合併型とすることができる。
これについての例は第 \ref{unions}節に与えられる。
      
\item[演算子の意味:] \mbox{}

\begin{TypeSemantics}
帰属関係 &  {\tt e} が集合 {\tt s1}の要素であるかどうか検査する \\ \hline
非帰属関係 &  {\tt e} が集合 {\tt s1}の要素でないことを検査する \\ \hline
合併 & 集合 {\tt s1} と {\tt s2}の合併、つまり\  {\tt s1} と {\tt s2}の両方の要素をすべて含む集合である。 \\ \hline
共通部分 & 集合 {\tt s1} と {\tt s2}の共通部分、つまり\  {\tt s1} と{\tt s2}の両方にある要素を含む集合である。 \\ \hline
差 &  {\tt s2}に含まれていない{\tt s1}の要素をすべて含む集合。 {\tt s2} は{\tt s1}の部分集合である必要はない。 \\ \hline
包含関係 &  {\tt s1}が {\tt s2}の部分集合であるかどうかを検査する、つまり\  {\tt s1} のすべての要素が {\tt s2}の要素であるかどうかである。どの集合もそれ自身の部分集合であることには注意。 \\ \hline
真包含関係 &  {\tt s1} が {\tt s2}の真部分集合であることを検査する、つまり\ 部分集合でありしかも {\tt s2$\backslash$s1} が空集合でないことである。 \\ \hline
濃度 &  {\tt s1}の要素の数。 \\ \hline
分配的合併 & 結果の集合は{\tt ss}のすべての要素(それら自身が集合である)の合併である、つまり{\tt ss}のすべての要素／集合のすべての要素を含む。 \\ \hline
分配的共通部分 & 結果の集合はすべての要素の共通部分であり、つまり\ {\tt ss}のすべての要素／集合の中の要素を含むということ。 {\tt ss}は空集合であってはならない。 \\ \hline
有限べき集合 & {\tt s1}のべき集合である、つまり\  {\tt s1}のすべての部分集合の集合である。 \\ \hline
\end{TypeSemantics}

\item[例題:]%
  {\tt s1 = \{<France>,<Denmark>,<SouthAfrica>,<SaudiArabia>\}}、{\tt s2 = \{2, 4, 6, 8, 11\}} 、 {\tt s3 = \{\}} であるときには以下のとおり: 

  \begin{longtable}{lcl}
    {\tt <England> \keyw{in set} s1} & $\equiv$ & \keyw{false}\\
    {\tt 10 \keyw{not in set} s2}    & $\equiv$ & \keyw{true}\\
    {\tt s2 \keyw{union} s3}         & $\equiv$ & \texttt{\{2, 4, 6, 8, 11\}}\\
    \texttt{s1 \keyw{inter} s3}      & $\equiv$ & \texttt{\{\}}\\
    \texttt{(s2 \char'134 \ \{2,4,8,10\}) union \{2,4,8,10\} = s2} &
    $\equiv$ & \keyw{false}\\
    \texttt{s1 \keyw{subset} s3} & $\equiv$ & \keyw{false}\\
    \texttt{s3 \keyw{subset} s1} & $\equiv$ & \keyw{true}\\
    \texttt{s2 \keyw{psubset} s2} & $\equiv$ & \keyw{false}\\
    \texttt{s2 <> s2 \keyw{union} \{2, 4\}} & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{card} s2 \keyw{union} \{2, 4\}} & $\equiv$ & \texttt{5}\\
    \texttt{\keyw{dunion} \{s2, \{2,4\}, \{4,5,6\}, \{0,12\}\}} &
    $\equiv$ & \texttt{\{0,2,4,5,6,8,11,12\}}\\
    \texttt{\keyw{dinter} \{s2, \{2,4\}, \{4,5,6\}\}} & $\equiv$ &
    \texttt{\{4\}}\\
    \texttt{\keyw{dunion} \keyw{power} \{2,4\}} & $\equiv$ &
    \texttt{\{2,4\}}\\
    \texttt{\keyw{dinter} \keyw{power} \{2,4\}} & $\equiv$ & \texttt{\{\}}
  \end{longtable}
\end{description}

\subsubsection{列型}
\label{sequences}

列値とは ある型の要素を順にならべた集まりで{\tt 1, 2, \ldots, n}によって索引づけられるもの；ここでは {\tt n}がこの列の長さとなる。 
列型とはある型の要素を有限個連続させた型であり、空列を含む場合(空列を含む列型)と含まない場合(空列を含まない列型)のいずれかとなる。
列型の要素には任意の混在が許されている; たとえばそれらが連続したものであればよいわけである。

以下はこの合意が用いられる: {\tt A}は任意の型であり、{\tt L}は列型であり、 {\tt S}は集合型であり、  {\tt l}, {\tt  l1}, {\tt l2} は列値であり、 {\tt ll}は列値の列である。 
{\tt e1}, {\tt e2} および {\tt en} はこれらの列の要素、 {\tt i}は自然数、 {\tt P} は述語、 {\tt e}は任意の式である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{列型} \dsep
    \ldots
    }

  \Rule{列型}{\Ruleref{空列を含む列型} \dsep
    \Ruleref{空列を含まない列型}}

  \Rule{空列を含む列型}{\Lop{seq of}, \Ruleref{型}}
  
  \Rule{空列を含まない列型}{\Lop{seq1 of}, \Ruleref{型}}
\item[等式:] {\tt L = \keyw{seq of} A} または {\tt L = \keyw{seq1 of} A}%
\index{\keyw{seq of}}\index{\keyw{seq1 of}}

%                 $L = \seqof*{A}$ or
%                 $L = \seqof+{A}$ where the notation has been adopted
%                 from regular expressions. Thus $\seqof*{A}$ means the type 
%                 containing sequences of $A$ elements (also the empty
%                 sequence), while $\seqof+{A}$ means the type containing
%                 non-empty sequences of $A$ elements. 

\item[構成子:] \mbox{}

  \begin{description}
  \item[列列挙:] \verb+[e1, e2,..., en]+ は、列挙された要素によって列を構成する。 
空列は \verb+[]+と表現する。 
テキストリテラルは文字の列挙の簡約記法である (たとえば\ {\tt "csk" = ['c','s','k']})

  \item[列内包:] {\tt [e | id \keyw{in set} S \& P]}
    は、述語{\tt P}が  \keyw{true}となるようなすべての束縛に対して式 {\tt e}を評価することで列を構成する。
式 {\tt e} は識別子 {\tt id}を用いる。 
{\tt S} は数の集合であり、 {\tt id} は通常の順で数とマッチする (最小の数を最初として)
  \end{description}
  すべての列式の構文と意味定義については、第~\ref{seqexpr}節で述べる。%
\index{\texttt{[]}!sequence enumeration}\index{\texttt{["|]}!sequence comprehension}\index{\texttt{\&}!sequence comprehension}

      
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt \keyw{hd} l} & 先頭 & \TO{\NSEQ{A}}{A} \\
    {\tt \keyw{tl} l} & 尾部 & \TO{\NSEQ{A}}{\SEQ{A}} \\
    {\tt \keyw{len} l} & 長さ & \TO{\SEQ{A}}{\keyw{nat}} \\
    {\tt \keyw{elems} l} & 要素集合 & \TO{\SEQ{A}}{\SET{A}} \\
    {\tt \keyw{inds} l} & 索引集合 & \TO{\SEQ{A}}{\SET{\keyw{nat1}}} \\
    {\tt l1 \char'136\ l2} & 連結 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\SEQ{A}} \\
    {\tt \keyw{conc} ll} & 分配的連結 & \TO{\SEQ{\SEQ{A}}}{\SEQ{A}}\\
    {\tt l ++ m} & 列修正 & \TO{\PROD{\SEQ{A}}{\MAP{\keyw{nat1}}{A}}}{\SEQ{A}}\\
    {\tt l(i)} & 列適用 & \TO{\PROD{\SEQ{A}}{\keyw{nat1}}}{A} \\
    {\tt l1 = l2} & 相等 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    {\tt l1 <> l2} & 不等 & \TO{\PROD{(\SEQ{A})}{(\SEQ{A})}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\keyw{hd}}\index{Head}\index{\keyw{tl}}\index{Tail}%
\index{\keyw{len}}\index{Length}\index{\keyw{elems}}\index{Elements}%
\index{\keyw{inds}}\index{Indexes}\index{\texttt{\char'136}}\index{Concatenation}%
\index{\keyw{conc}}\index{Distributed concatenation}%
\index{\texttt{++}!sequence modification}\index{Sequence modification}%
\index{\texttt{()}!sequence apply}\index{Sequence application}%
\index{\texttt{=}!sequence equality}\index{Equality!sequence type}\index{\texttt{<>}!sequence inequality}\index{Inequality!sequence type}%


 型{\tt A}は任意の型であって、連結や分配的連結の演算子に対する演算対象は、同じ型({\tt A}) である必要はない。 
結果列の型は、複数の演算対象の型の合併型となる。
第 \ref{unions}節に例題が与えられている。

\item[演算子の意味定義:] \mbox{}

\begin{TypeSemantics}
先頭 & {\tt l}の最初の要素。 {\tt l} は空列であってはならない。 \\ \hline
尾部 &  {\tt l}から最初の要素を取り除いた部分列。 {\tt l} は空列であってはならない。\\ \hline
長さ &  {\tt l}の長さ。 \\ \hline
要素集合 & {\tt l}の要素すべてを含む集合。 \\ \hline
索引集合 &  {\tt l}の索引すべてを含む集合。 \mbox{\tt \{1,...,len l\}}。 \\ \hline
連結 & {\tt l1} と {\tt l2}の連結、つまり順に、 {\tt l1} の列要素のあとに{\tt l2}の列要素を続けた列。 \\ \hline
分配的連結 &  {\tt ll}の列要素(これら自体が列である)が連結された列: 最初と第２の列要素を連結し、次に第３の列要素を連結し、等々。 \\ \hline
列修正 &  列索引が{\tt m}の定義域にある{\tt l} の列要素は、その索引が写像された先の値域値に修正される。 {\tt dom m} は索引 {\tt l}の部分集合でなければならない。 \\ \hline
列適用 &  {\tt l}から始まる索引の要素。 {\tt i} は {\tt l}の索引集合になければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:]  \texttt{l1 = [3,1,4,1,5,9,2]}, \texttt{ l2 = [2,7,1,8]}, \newline
    \texttt{ l3 = [<England>, <Rumania>, <Colombia>,
    <Tunisia>]} とすると以下のとおり： 

  \begin{longtable}{lcl}
    \texttt{\keyw{len} l1}        & $\equiv$ & \texttt{7}\\
    \texttt{\keyw{hd} (l1\char'136 l2)}    & $\equiv$ & \texttt{3}\\
    \texttt{\keyw{tl} (l1\char'136 l2)}    & $\equiv$ &
      \texttt{[1,4,1,5,9,2,2,7,1,8]}\\
    \texttt{l3(\keyw{len} l3)}    & $\equiv$ & \texttt{<Tunisia>}\\
    \texttt{"England"(2)}       & $\equiv$ & \texttt{'n'}\\
    \texttt{\keyw{conc} [l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{conc} [l1,l1,l2] = l1\char'136 l2} 
                                  & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{elems} l3}      & $\equiv$ & \{
      \parbox[t]{5cm}{\texttt{<England>, <Rumania>, }\\
                      \texttt{<Colombia>,<Tunisia>\}}}\\
    \texttt{(\keyw{elems} l1) \keyw{inter} (\keyw{elems} l2)} 
                                  & $\equiv$ & \texttt{\{1,2\}}\\
    \texttt{\keyw{inds} l1}       & $\equiv$ & \texttt{\{1,2,3,4,5,6,7\}}\\
    \texttt{(\keyw{inds} l1) \keyw{inter} (\keyw{inds} l2)}
                                  & $\equiv$ & \texttt{\{1,2,3,4\}}\\
    \texttt{l3 ++ \{2 |-> <Germany>,4 |-> <Nigeria>\}}
                                  & $\equiv$ & [
      \parbox[t]{5cm}{\texttt{<England>, <Germany>, }\\
                      \texttt{<Colombia>, <Nigeria>]}}
  \end{longtable}
\end{description}

\subsubsection{写像型}\label{maps}

 {\tt A}型から {\tt B}型への写像型とは、 {\tt A} (または {\tt A}の部分集合)の要素各々を {\tt B}の1つの要素と結合する型のことである。 
写像の値とは、この2つの要素の組を順不同で集めたものと考えることができる。
各々の組の最初の要素をキーと呼ぶが、これは各組で最初の要素を用いて2番目の要素 (情報部分と呼ばれる) を得ることができるからである。
よって1つの写像におけるキー要素は、すべて異なるものでなければならない。
すべてのキー要素の集合をこの写像の定義域と呼び、一方すべての情報値の集合を値域と呼ぶ。
\vdmslpp{\vdmsl}{\vdmpp}\ におけるすべての写像とは有限のものである。
写像型の定義域と値域の要素には任意の合成が許されていて、たとえば要素を写像とすることもできる。

特別な写像としては1対1写像がある。 
1対1写像とは、値域の要素で2つ以上の定義域の要素と結合するものはない写像のことである。
この1対1写像では、写像を逆にすることが可能である。

以下では次のとおりに用いる: {\tt m}, {\tt m1}、および{\tt m2} は、任意の{\tt A}型からもう1つの任意の{\tt B}型への写像を表し、{\tt ms} は写像値の集合であり。
 {\tt a}, {\tt a1}, {\tt a2}、および{\tt an}は {\tt A}から取り出した要素である一方、 {\tt b}, {\tt b1}, {\tt b2} および{\tt bn}は{\tt B}から取り出した要素である。{\tt P}は論理述語である。
{\tt  e1}、{\tt e2} は任意の式であり、 {\tt s}は任意の集合である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{写像型} \dsep
    \ldots
    }
  
  \Rule{写像型}{\Ruleref{一般写像型} \dsep
    \Ruleref{1対1写像型}}
  
  \Rule{一般写像型}{\Lop{map}, \Ruleref{型}, \Lop{to}, \Ruleref{型}}
  
  \Rule{1対1写像型}{\Lop{inmap}, \Ruleref{型}, \Lop{to}, \Ruleref{型}}

\item[等式:] {\tt M = \keyw{map} A \keyw{to} B} または {\tt M =
    \keyw{inmap} A \keyw{to} B}\index{\keyw{map to}}\index{\keyw{inmap to}}

\item[構成子:] \mbox{}

  \begin{description}
  \item[写像列挙:] 
{\tt \{a1 |-> b1, a2 |-> b2, \ldots, an |-> bn\}}
    は、列挙された写からなる写像を構成する。 
空写像は {\tt \{|->\}}と表す。

  \item[写像内包:] {\tt \{ed |-> er | bd1, \ldots, bdn \& P\}}は、述語{\tt P}が \keyw{true}と判断するすべてのありうる束縛上で、式{\tt ed} と {\tt er}を評価することによって写像を構成する。
  \end{description}
すべての写像式の構文と意味定義については、第~\ref{mapexpr}節で述べる。%
\index{\texttt{\{\}}!map enumeration}\index{\texttt{\{"|\}}!map comprehension}\index{\texttt{\&}!map comprehension}


\item[演算子:]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline 
    {\tt \keyw{dom} m} & 定義域 & \TO{(\MAP{A}{B})}{\SET{A}} \\
    {\tt \keyw{rng} m} & 値域 & \TO{(\MAP{A}{B})}{\SET{B}} \\
    {\tt m1 \keyw{munion} m2} & 併合 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m1 ++ m2} & 上書 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt \keyw{merge} ms} & 分配的併合 & \TO{\SET{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <: m} & 定義域限定 & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt s <-: m} & 定義域削減 & \TO{\PROD{(\SET{A})}{(\MAP{A}{B})}}{\MAP{A}{B}} \\
    {\tt m :> s} & 値域限定 & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m :-> s} & 値域削減 & \TO{\PROD{(\MAP{A}{B})}{(\SET{B})}}{\MAP{A}{B}} \\
    {\tt m(d)} & 写像適用 & \TO{\PROD{(\MAP{A}{B})}{A}}{B} \\
    {\tt m1 \keyw{comp} m2} & 写像合成 & \TO{\PROD{(\MAP{B}{C})}{(\MAP{A}{B})}}{\MAP{A}{C}} \\
    {\tt m ** n} & 写像反復 & \TO{\PROD{(\MAP{A}{A})}{\keyw{nat}}}{\MAP{A}{A}} \\
    {\tt m1 = m2} & 相等 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt m1 <> m2} & 不等 & \TO{\PROD{(\MAP{A}{B})}{(\MAP{A}{B})}}{\keyw{bool}} \\
    {\tt \keyw{inverse} m} & 逆写像 & \TO{\INMAP{A}{B}}{\INMAP{B}{A}} \\
    \hline
  \end{tabular}%
\index{\keyw{dom}}\index{Domain}\index{\keyw{rng}}\index{Range}%
\index{\keyw{munion}}\index{Merge}\index{\texttt{++}!map override}\index{Override}%
\index{\keyw{merge}}\index{Distribute merge}\index{\texttt{<:}}\index{Domain restrict to}%
\index{\texttt{<-:}}\index{Domain restrict by}\index{\texttt{:>}}\index{Range restrict to}%
\index{\texttt{:->}}\index{Range restrict by}\index{\texttt{()}!map apply}\index{Map apply}%
\index{\keyw{comp}!map composition}\index{Map composition}\index{\texttt{**}}\index{Map iteration}%
\index{\texttt{=}!map equality}\index{Equality!map type}\index{\texttt{<>}!map inequality}\index{Inequality!map type}%
\index{\keyw{inverse}}\index{Map inverse}

\item[演算子の意味定義:] ２つの写像 {\tt m1} と {\tt m2} は、{\tt dom m1} と {\tt dom m2}に共通の要素が両写像により同じ値に写像されるならば、両立している。

\vspace{1ex}
\begin{TypeSemantics}
定義域 & {\tt m}の定義域 (キーの集合)。 \\ \hline
値域 & {\tt m}の値域 (情報値の集合)。  \\ \hline
併合 &  {\tt m1} と {\tt m2}が結合した写像で、結果の写像は  {\tt m1}と同様に{\tt dom m1}の要素に、 また{\tt m2}と同様に {\tt dom m2} の要素に、写像を行う。２つの写像は両立していなければならない。 \\ \hline
上書 &  {\tt m1} に {\tt m2}を上書または併合する、つまり\  {\tt m1} と {\tt m2}は必ずしも両立する必要はないということを除けば、併合と似ている。
共通の要素はいずれも {\tt m2} によるものとして写像される(したがって {\tt m2} は{\tt m1}を上書する)。 \\ \hline
分配的併合 &  {\tt ms}に含まれるすべての写像を併合することにより構成される写像。 {\tt ms}に含まれる写像は両立していなければならない。 \\ \hline
定義域限定 & {\tt m}の要素のうちでキーが{\tt s}に含まれるもの、から構成される写像をつくりだす。{\tt s}は {\tt dom m}の部分集合である必要はない。 \\ \hline
値域限定 & {\tt m}の要素のうちで情報値が {\tt s}に含まれるもの、から構成される写像をつくりだす。 {\tt s}は {\tt rng m}の部分集合である必要はない。 \\ \hline
写像の適用 & キーが {\tt d}である写像の情報値。 {\tt d} は {\tt m}の定義域に含まれていなければならない。 \\ \hline
写像の合成 &  {\tt  m2} の要素に {\tt m1} の要素を合成してつくった写像。結果は {\tt m2}と同じ定義域をもった１つの写像である。 あるキーに対応する情報値は、最初に{\tt m2} をキーに適用しその後 {\tt m1} をその結果に適用することによって見つけられるものである。{\tt rng m2}は {\tt  dom m1}の部分集合でなければならない。 \\ \hline
写像の反復 &  {\tt m} からそれ自体を{\tt n}回繰り返すことで構成された写像。 {\tt n = 0} は{\tt dom m}の各々の要素がそれ自体への写像である同一写像； {\tt n = 1} は{\tt m} 自体である。{\tt n > 1}に対して、 {\tt m}の値域は {\tt dom m}の集合でなければならない。\\ \hline
逆写像 & {\tt m}の逆写像。 {\tt m} は１対１写像でなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:] 次を仮定すると

  {\ttfamily\selectfont
  \begin{tabular}{l}
    m1 = \{ <France> |-> 9, <Denmark> |-> 4, \\
          \mbox{\hspace{3em}}  <SouthAfrica> |-> 2, <SaudiArabia> |-> 1\}, \\
    m2 = \{ 1 |-> 2, 2 |-> 3, 3 |-> 4, 4 |-> 1 \}, \\
    Europe = \{ <France>, <England>, <Denmark>, <Spain> \}
  \end{tabular}}

  以下のとおり：

  \begin{longtable}{lcl}
    \texttt{\keyw{dom} m1}           & $\equiv$ & 
       \texttt{\{}\parbox[t]{5.3cm}{%
           \texttt{<France>, <Denmark>,}\\
           \texttt{<SouthAfrica>, <SaudiArabia>\}}}\\
    \\
    \texttt{\keyw{rng} m1}           & $\equiv$ & \texttt{\{1,2,4,9\}}\\
    \\
    \texttt{m1 \keyw{munion} \{<England> |-> 3\}}
                                     & $\equiv$ & 
       \texttt{\{}%
       \parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4,\\
          <England> |-> 3, \\ 
          <SaudiArabia> |-> 1,\\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 ++ \{\parbox[t]{4cm}{\ttfamily\selectfont
       <France> |-> 8,\\ <England> |-> 4\}}}
                                     & $\equiv$ &
       \texttt{\{}%
           \parbox[t]{5.3cm}{\ttfamily\selectfont
              <France> |-> 8, \\
              <Denmark> |-> 4,\\
              <SouthAfrica> |-> 2, 
              <SaudiArabia> |-> 1,\\
              <England> |-> 4\}}\\
    \\
    
    \texttt{\keyw{merge}\{}
         \parbox[t]{5.7cm}{\ttfamily\selectfont
                 \{<France> |-> 9, \\
                   \mbox{\hspace{0.0cm}} <Spain> |-> 4\} \\
                 \{<France> |-> 9, \\
                    \mbox{\hspace{0.0cm}} <England> |-> 3, \\
                    \mbox{\hspace{0.0cm}} <UnitedStates> |-> 1\}\}}
                                     & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont%
         <France> |-> 9, \\
         <England> |-> 3, \\
         <Spain> |-> 4,\\
         <UnitedStates> |-> 1\}}\\ \\
    \\
    \texttt{Europe <: m1}            & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4\}}\\
    \\
    \texttt{Europe <-: m1}           & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <SouthAfrica> |-> 2,\\
          <SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 :> \{2,...,10\}}      & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
          <France> |-> 9, \\
          <Denmark> |-> 4, \\
          <SouthAfrica> |-> 2\}}\\
    \\
    \texttt{m1 :-> \{2,...,10\}}     & $\equiv$ &
       \texttt{\{<SaudiArabia> |-> 1\}}\\
    \\
    \texttt{m1 \keyw{comp} (\{"France" |-> <France>\})}
                                     & $\equiv$ & 
       \texttt{\{"France" |-> 9\}}\\
    \\
    \texttt{m2 ** 3}                 & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 4, 2 |-> 1, \\
            3 |-> 2, 4 |-> 3 \}}\\
    \\
    \texttt{\keyw{inverse} m2}       & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            2 |-> 1, 3 |-> 2, \\
            4 |-> 3, 1 |-> 4 \}}\\
    \\
    \texttt{m2 \keyw{comp} (\keyw{inverse} m2)} & $\equiv$ &
       \texttt{\{}\parbox[t]{5.3cm}{\ttfamily\selectfont
            1 |-> 1, 2 |-> 2,\\
            3 |-> 3, 4 |-> 4 \}}
  \end{longtable}
\end{description}



\subsubsection{組型}\label{tuples}

組型の値を組と呼ぶ。
組とは固定長のリストであり、組のｉ番目の要素は組型のｉ番目の要素に属さなければならない。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{組型} \dsep
    \ldots
    }

  \Rule{組型}{
    \Ruleref{型}, \Lop{{\tt *}}, \Ruleref{型}, \SeqPt{\Lop{{\tt *}}, \Ruleref{型}}
    }

  組型は少なくとも2つの部分型から構成される。

\item[等式：] {\tt T = A1 * A2 * \ldots\ * An}\index{\texttt{*}!組型}

\item[構成子：] 組構成子： {\tt \keyw{mk\_}(a1, a2,
%    \ldots, an)}\index{\keyw{mk\_}!tuple constructor}
    \ldots, an)}\index{\keyw{mk\_}!組構成子}

     組構成子についての構文と意味定義は第~\ref{tupexpr}節で述べられる。 
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    \texttt{t.\#n}   & 選択     & \TO{\PROD{T}{\keyw{nat}}}{Ti}\\
    {\tt t1 = t2}  & 相等   & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{T}{T}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!tuple equality}\index{Equality!tuple}\index{\texttt{<>}!tuple inequality}\index{Inequality!tuple}


  組に対して有効な演算子は、構成要素選択、相等、不等、のみである。
組構成要素は、選択演算子を用いたり組パターンとマッチングさせることで、アクセスすることもできる。
組選択演算子についての意味定義の詳細および使用例は、第 \ref{app-expr}節に述べる。 

\item[例題:]  {\tt a = \keyw{mk\_}(1, 4, 8)}, {\tt b =
    \keyw{mk\_}(2, 4, 8)} とすると以下のとおり:

  \begin{tabular}{lcl}
    {\tt a = b}     &$\equiv$& \keyw{false}\\
    {\tt a <> b}    &$\equiv$& \keyw{true}\\
    {\tt a = \keyw{mk\_}(2,4)} &$\equiv$& \keyw{false}\\
  \end{tabular}
\end{description}

\subsubsection{レコード型}\label{records}

レコード型は、プログラミング言語においての構造体に相当する。
したがってこの型の要素は、前述の組型の節で述べられた組にいくぶんか似ている。
レコード型と組型の違いは、レコードの異なる構成要素は相応の選択関数を用いることで、直接選択することができることである。 
さらに加えて、レコードは操作するとき用いられるべき識別子によってタグ付けされる。一般的な使い方として、タグを与えるためにはただ1つの項目からなるレコードも定義される。
組とのもうひとつの違いとなるが、組は少なくとも2つの実体をもつ必要があるが、レコードは空でもよい。

\vdmslpp{\vdmsl,}{\vdmpp,} \keyw{is\_} は名称に対する予約接頭辞であって{\it is式}の中で使用される。 
これは、あるレコード値がどのレコード型に属するのか決定するために用いられる、組込演算子である。
しばしば合併型の部分型同士を区別することに用いられるため、更なる説明が第~\ref{unions}節になされている。 
\keyw{is\_}演算子は、レコード型を決定するのに加え、ある値が基本型のひとつであるかどうかの決定も行うことができる。
 
以下では次の約束に従う： {\tt A}はレコード型、 {\tt A1, \ldots, Am}は任意の型、 {\tt r}, {\tt r1}, {\tt r2}はレコード値、 {\tt i1, \ldots, im}はレコード値 {\tt r}からの選択子、 {\tt e1, \ldots, em}は任意の式である。

\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{レコード型} \dsep
    \ldots
    }
  
  \Rule{レコード型}{
    \Lop{compose}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト},
    \Lop{end}
    }
  
  \Rule{項目リスト}{\SeqPt{\Ruleref{項目}}}
  
  \Rule{項目}{\OptPt{\Ruleref{識別子}, \Lit{:}}, \Ruleref{型}
  \dsep  \OptPt{\Ruleref{識別子}, \Lit{:-}}, \Ruleref{型}
  }
  
  または省略型表記法で
  
  \Rule{レコード型}{
    \Ruleref{識別子}, \Lit{::}, \Ruleref{項目リスト}}
  
  この識別子が表すものは型名かタグ名である。

\item[等式:]
\mbox{}\label{a-type}
  \begin{alltt}
    A :: selfirst : A1
         selsec   : A2
  \end{alltt}%
\index{\texttt{::}}

	または

  \begin{alltt}
    A :: selfirst :  A1
         selsec   :- A2
  \end{alltt}%
\index{\texttt{:-}}

	または

  \begin{alltt}
    A :: A1 A2
  \end{alltt}

  2番目の表記では、 {\it 比較対象外\/} 項目
  \index{equality abstraction field} が第2項 {\tt selsec}に対し用いられる。
この負符号は、等号演算子を使ってレコード比較を行うときにこの項が無視されることを指定している。
最後の表記法では {\tt A} の項目はひとつひとつに名称が付けられていないため、パターンマッチングによってのみ(組についてそうだったように)アクセスを行うことができる。
  
省略型表記である {\tt ::} は前の2例でも使われ、タグ名が型名と等しいというものだが、この表記法は最もよく用いられている。
 より一般的である \keyw{compose} 表記法は、次のようにレコード型がそれより複雑な型の構成要素として直接記述されなければならない場合に、典型的に用いられる:

  \begin{alltt}
    T = \keyw{map} S \keyw{to compose} A \keyw{of} A1 A2 \keyw{end}
  \end{alltt}
しかしながら、レコード型は型定義においてのみ用いることができるもので、例えば関数や操作に対するシグネチャにおいてではないことは明記しておくべきであろう。

レコード型は、合併型定義における代案(~\ref{unions}を参照)として、典型的に用いられる:

  \begin{alltt}
   MasterA = A | B | ...
  \end{alltt}
ここで \texttt{A} と \texttt{B} は、自身がレコード型として定義されている。
この状態で、 \keyw{is\_} 前置詞を代案と区別するために用いることができる。

\item[構成子:]
レコード構成子: {\tt \keyw{mk\_}A(a, b)} において、 {\tt a} は型 {\tt A1} に属し {\tt b} は型 {\tt A2}に属す。

 すべてのレコード式に対する構文と意味定義は第~\ref{recexpr}節で与えられる。
%\index{\keyw{mk\_}!record constructor}
\index{\keyw{mk\_}!レコード構成子}

\item[演算子:] 
 \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    {\tt r.i} & 項目選択 & \TO{\PROD{A}{Id}}{Ai} \\
    {\tt r1 = r2} & 相等  & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt r1 <> r2} & 不等  & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt \keyw{is\_}A(r1)} & Ｉｓ & \TO{\PROD{Id}{MasterA}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{.}!record field selector}\index{Field select}%
\index{\texttt{=}!record equality}\index{Equality!record}\index{\texttt{<>}!record inequality}\index{Inequality!record}

\item[演算子の意味定義:]  \mbox{}

\begin{TypeSemantics}
項目選択 & レコード値 {\tt r}の中で項目名が {\tt i} である項目の値。
{\tt r} は {\tt i} という名の項目をもっていなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:] \texttt{Score} は以下のように定義される
\begin{alltt}\label{scoredef}
   Score :: team : Team
            won : \keyw{nat}
            drawn : \keyw{nat}
            lost : \keyw{nat}
            points : \keyw{nat};
   Team = <Brazil> | <France> | ...
\end{alltt}
さらに次の通りとする 

\begin{tabular}{l}
\texttt{sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9)}, \\
\texttt{sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4)},\\
\texttt{sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2)} そして \\
\texttt{sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1)}
\end{tabular}

\noindent%
このとき

  \begin{tabular}{lcl}
    \texttt{sc1.team}            & $\equiv$ & \texttt{<France>}\\
    \texttt{sc4.points}          & $\equiv$ & \texttt{1}\\
    \texttt{sc2.points > sc3.points} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_}Score(sc4)} 
                                 & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(sc3)}
                                 & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_int}(sc1.won)}
                                 & $\equiv$ & \keyw{true}\\
    \texttt{sc4 = sc1}           & $\equiv$ & \keyw{false}\\
    \texttt{sc4 <> sc2}          & $\equiv$ & \keyw{true}  
  \end{tabular}

  `{\tt :}'の代わりに`{\tt :-}'を用いて記述する比較対象外項目は、たとえばプログラム言語の抽象構文における低水準モデルにおいて役立つことがある。
例としては、識別子の一意性に影響を与えることなく、それらの識別子の型に位置情報項目を加えたい場合などである。

\begin{alltt}
  Id :: name :  seq of char
        pos  :- nat
\end{alltt}

この効果は{\tt pos}項が相等比較において無視されることにあり、たとえば次の例はtrueと評価されるであろう：

\begin{alltt}
  mk_Id("x",7) = mk_Id("x",9)
\end{alltt}

特にこのことは、以下の形の写像の典型的な環境において検索を行う場合に役に立つはずである:

\begin{alltt}
  Env = map Id to Val
\end{alltt}

このような写像は指定の識別子に対し最大1つの索引を含み、写像検索は {\tt pos}項目から独立したものとなる。

そのうえ、比較対象外項目は集合式に影響を与える。
たとえば、 
\begin{alltt}
  \{mk_Id("x",7),mk_Id("y",8),mk_Id("x",9)\}
\end{alltt}

は次と等しくなる

\begin{alltt}
  \{mk_Id("x",?),mk_Id("y",8)\}
\end{alltt}

ここにおける疑問符は7から9までを表している。

最後に比較対象外項目に対する有効なパターンとしては、don't careあるいは識別子パターンに限定されていることには注意しよう。
比較対象外項目は2つの値を比較するときに無視されるものであり、それ以上複雑なパターンを用いることに対しては意味をなさないからである。
\end{description}

\subsubsection{合併型と選択型}\label{unions}

合併型は集合論理における和に相当する、つまり合併型として定義される型はその合併型の構成要素各々からすべての要素を含むことになる。
合併型の中で互いに素であるとはいえない複数の型を用いることは、あまりよくない使用法だが可能ではある。 
しかし通常は、属する型として可能な複数の型から1つを考える場合には合併型が用いられる。 
合併型を構成する型としてしばしばレコード型がある。
\keyw{is\_}演算子を用いることで、合併型のある値がこういった型のいずれに属するものであるのかを決定することが可能である。

選択型 {\tt [T]} とは合併型{\tt T | \keyw{nil}}に対してのいわゆる省略であり、 この\keyw{nil} は値が存在しないことを表記するために用いられるものである。
ただし集合 {\tt \{\keyw{nil}\}}をひとつの型として用いることはできないので、 \keyw{nil}を含む型のみが選択型となりうる。 


\begin{description}
\item[構文:] 
  \Rule{型}{
    \Ruleref{合併型} \dsep
    \Ruleref{選択型} \dsep
    \ldots
    }
  
  \Rule{合併型}{
    \Ruleref{型}, \Lit{|}, \Ruleref{型}, \SeqPt{\Lit{|}, \Ruleref{型}}
    }
  
  \Rule{選択型}{\Lit{[}, \Ruleref{型}, \Lit{]}}

\item[等式:] {\tt B = A1 | A2 | \ldots\ | An}%
\index{\texttt{|}!union type}\index{\texttt{[]}!optional type}

\item[構成子:] なし

\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!union equality}\index{Equality!union type}%
\index{\texttt{<>}!union inequality}\index{Inequality!union type}%
\index{\texttt{=}!optional equality}\index{Equality!optional type}%
\index{\texttt{<>}!optional inequality}\index{Inequality!optional type}


\item[例題:] この例題中で 
  {\tt Const}, {\tt Var}, {\tt Infix} および {\tt Cond} は省略 {\tt ::} 記法を用いて定義されたレコード型であることから、{\tt Expr} は合併型である。

  \begin{alltt}\label{exprdef}
    Expr  = Const | Var | Infix | Cond;
    Const :: \keyw{nat} | \keyw{bool};
    Var   :: id:Id
             tp: [<Bool> | <Nat>];
    Infix :: Expr * Op * Expr;
    Cond  :: test : Expr
             cons : Expr
             altn : Expr
  \end{alltt}    
  また {\tt expr = \keyw{mk\_}Cond(\keyw{mk\_}Var("b",<Bool>),%
    \keyw{mk\_}Const(3),}\\ {\tt \keyw{mk\_}Var("v",\keyw{nil}))} とすると:

  \begin{tabular}{lcl}\label{exprIsExs}
    {\tt \keyw{is\_}Cond(expr)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Const(expr.cons)} &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Var(expr.altn)}   &$\equiv$& \keyw{true}\\
    {\tt \keyw{is\_}Infix(expr.test)}  &$\equiv$& \keyw{false}\\
  \end{tabular}

  合併型を用いることで、今までで定義してきた演算子の使用を拡張することができる。たとえば \texttt{=}を \texttt{\keyw{bool} | \keyw{nat}}上でのテストと解釈することで次を得る。
 
 \begin{tabular}{lcl}
    \texttt{1 = \keyw{false}}    & $\equiv$ & \keyw{false}
  \end{tabular}

  同様に、集合の合併や列の連結の代わりに合併型を用いることができる:
  
  \begin{tabular}{lcl}
     \texttt{ \{1,2\} \keyw{union} \{\keyw{false},\keyw{true}\}}
                                 & $\equiv$ & 
        \texttt{\{1,2, \keyw{false},\keyw{true}\}}\\
     \texttt{ ['a','b']\char'136 [<c>,<d>]}
                                 & $\equiv$ &
        \texttt{['a','b', <c>,<d>]}
  \end{tabular}

集合合併においては、 \texttt{\keyw{nat} | \keyw{bool}}型の集合上での合併を考える；一方列連結に対しては、 \texttt{\keyw{char} | <c> | <d>}型の列を操作している。 \end{description}

#ifdef VDMPP
\subsubsection{オブジェクト参照型}

オブジェクト参照型が標準\vdmsl\ の型に加えられた。 
したがって純粋なオブジェクト指向原則に従わせようとすれば、オブジェクト参照型(およびそのオブジェクト)の使用を制限する直接的な方法は存在しない；クラスを超えたさらなる構造化機能はいまだ予見すらなされていない。
これらの原則から考えれば、型構成子(レコード、写像、集合、等々)と結合されるオブジェクト参照型の使用には十分な注意を払うべきであるといえる。

オブジェクト参照型の値はオブジェクトへの{\em 参照}とみなすことができる。
たとえばもし、あるインスタンス変数 (第\ref{sec:ivars}節参照) がオブジェクト参照型として定義されるならば、このインスタンス変数が定義されているクラスは、オブジェクト参照型の中のクラスの「クライアント」となる；つまり{\em クライアント関係} がこの2つのクラス間に確立する。

オブジェクト参照型はクラス名によって表示される。
オブジェクト参照型に含まれるクラス名は、その仕様の中で定義された1つのクラスの名称でなければならない。

この型の値に対して定義された演算子は、相等 (\Lit{=}) と不等 (\Lit{<>}) のみである。 
相等は、値ではなく参照に基づくものとなる。
このことは、もし \texttt{o1} と \texttt{o2} が2つの異なるオブジェクトであるならば、たまたま同じ内容であったとしても、\texttt{o1 = o2} はfalseとなるということである。

\begin{description}
\item[構成子] オブジェクト参照はnew式 (第 \ref{sec:creation}節参照)を用いて構成される。

\item[演算子]\mbox{}

  \begin{tabular}{|l|l|l|}\hline
    演算子 & 名称 & 型 \\ \hline
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}

\item[例題]
オブジェクト参照の使用例として二分木のクラス定義である:
\begin{alltt}\label{TreeDef}
class Tree

  types

    \PROTECTED tree = <Empty> | node;
    
    \PUBLIC node :: lt: Tree
                   nval : int
                   rt : Tree

 instance variables
    \PROTECTED root: tree := <Empty>;
end Tree
\end{alltt}
ここではnode型を定義するが、これはnode値で構成されていて、lt,rtオブジェクトを参照するものである。
#ifdef VDMPP
アクセス指定子についての詳細は第\ref{ch:interface}節に述べられている。
#endif VDMPP
\end{description}

#endif VDMPP

\subsubsection{関数型}

\vdmslpp{\vdmsl}{\vdmpp}では関数型もまた型定義に用いることができる。
型{\tt A} (実際は型のリスト) から型 {\tt B}への関数型というのは、型 {\tt A} の各々の要素に対して {\tt B}の要素を結びつける型である。
関数の値は、プログラム言語においての関数と同じもので他に副作用をおよぼすことのない(つまりグローバル変数を使用していない)ものとして考えることができる。

このような用い方は、関数が値として用いられるという意味で上級向けの使用法と考えることができる(したがって初読ではこの節はとばしていただいてもよい)。
関数値は、ラムダ式 (以下を参照)によって生成されることもあるし、第~\ref{functiondef}節に述べる関数定義による場合もある。 
関数値は、関数を引数としたりまた戻り値にすることができるという意味で、高階なものとなり得る。
この方法を用いれば、最初のパラメーターの組が与えられると新しい関数が1つ返されるというように、関数はカリー化されることが可能である (次の例題を参照)。

%Type definitions may not be recursive {\it through} function types, though
%they may be recursive {\it over} them. That is, no chain of
%definitions derived from a set of recursive type definitions from a
%type back to itself may pass through a function type operator (see the
%next subsection for more information about recursive type
%definitions). Thus, a type definition like {\tt A = A -> A |
%\keyw{bool}} is illegal while a type definition like: {\tt A = A * A |
%(\keyw{nat} -> \keyw{nat})} is legal.

\begin{description}
\item[構文:]
  \Rule{型}{
    \Ruleref{関数型} \dsep
    \ldots
    }
  
  \Rule{関数型}{
    \Ruleref{部分関数型} \dsep
    \Ruleref{全関数型}
    }

  \Rule{部分関数型}{
    \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}}
  
  \Rule{全関数型}{
    \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}}
  
  \Rule{任意の型}{\Ruleref{型} \dsepl \Lit{(},\Lit{)}} 
  
\item[等式:] {\tt F = A +> B}\footnote{全関数矢印は全定義関数のシグネチャにおいてのみ用いることができ、型定義においては用いることはできないことに注意したい。} または {\tt F = A -> B}%
\index{\texttt{->}}\index{\texttt{+>}}

\item[構成子:] 伝統的な関数定義に加えて、関数を構成する唯一の方法がラムダ式によるものである: {\tt \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& body}
ここにおける {\tt patj} はパターン、 {\tt Tj} は型式、そして{\tt body} は本体式で全パターンよりパターン識別子を用いることが許されている。

  ラムダ式に対する構文や意味定義は、第~\ref{lambda}節にある。
\item[演算子:] \mbox{}

  \begin{tabular}{|l|l|l|} \hline
    演算子 & 名称 & 型 \\ \hline
    {\tt f(a1,\ldots,an)} & 関数適用 & \TO{A1 * \cdots * An}{B} \\
    {\tt f1 \keyw{comp} f2}& 関数合成 & \TO{\PROD{(\FUN{B}{C})}{(\FUN{A}{B})}}{(\FUN{A}{C})} \\
    {\tt f ** n} & 関数反復 & \TO{\PROD{(\FUN{A}{A})}{\keyw{nat}}}{(\FUN{A}{A})} \\
    {\tt t1 = t2} & 相等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    {\tt t1 <> t2} & 不等 & \TO{\PROD{A}{A}}{\keyw{bool}} \\
    \hline
  \end{tabular}%
\index{\texttt{=}!function equality}\index{Equality!function type}\index{\texttt{<>}!function inequality}\index{Inequality!function type}%
\index{\keyw{comp}!function composition}\index{Function composition}%
\index{\texttt{**}!function iteration}\index{Function iteration}%
\index{\texttt{()}!function apply}\index{Function apply}
  
 型値間での相等と不等については、最大の注意を払うべきである。
 \vdmslpp{\vdmsl}{\vdmpp}\ においてこれは、数学上の相等 (または不等)に相等するが、一般関数と同様に無限値に対して計算不能となる。
このように、インタプリターでの相等は関数値の抽象構文上のものである ( 以下の{\tt
    inc1}と {\tt inc2}を参照)。

\item[演算子の意味定義:]  \mbox{}

\begin{TypeSemantics}
関数適用 & 関数 {\tt f}を {\tt a$_j$}の値に適用した結果。
第 \protect\ref{app-expr}章の適用式の定義を参照のこと。 \\ \hline
関数合成 & 最初に {\tt f2}を適用して次はその結果に {\tt f1} を適用することと同等な関数。
{\tt f1}はカリー化されてもよいが，{\tt f2}はいけない。 \\ \hline
関数繰り返し & {\tt  f}を{\tt n}回適用することと同等な関数。 {\tt n = 0} の場合はそのパラメーター値をそのまま返す恒等関数となる。 {\tt n = 1} の場合はその関数自身となる。 {\tt n > 1}の場合、 {\tt f} の戻り値はそれ自身のパラメーター型に含まれるものでなければならない。 \\ \hline
\end{TypeSemantics}

\item[例題:]  以下に関数の値を定義してみよう:
  \begin{alltt}
    f1 = \keyw{lambda} x : \keyw{nat} \& \keyw{lambda} y : \keyw{nat} \& x + y
    f2 = \keyw{lambda} x : \keyw{nat} \& x + 2
    inc1 = \keyw{lambda} x : \keyw{nat} \& x + 1
    inc2 = \keyw{lambda} y : \keyw{nat} \& y + 1
  \end{alltt}
  ここで次のことが導かれる:
  
  \begin{tabular}{lcl}
    {\tt f1(5)} &$\equiv$& {\tt \keyw{lambda} y :\keyw{nat} \& 5 + y}\\
    {\tt f2(4)} &$\equiv$& {\tt 6}\\
    {\tt f1 \keyw{comp} f2}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \&
      \keyw{lambda} y :\keyw{nat} \& (x + 2) + y}\\
    {\tt f2 ** 4}&$\equiv$& {\tt \keyw{lambda} x :\keyw{nat} \& x + 8}\\
    {\tt inc1 = inc2}&$\equiv$& \keyw{false}\\
  \end{tabular}
  
 相等判定は、\vdmslpp{\vdmsl}{\vdmpp}の意味定義に基づいての期待される結果に従うものではないことに注意したい。 
このように、関数といった無限値に対する相等の使用には{\bf 十分}注意深くなる必要がある。
\end{description}

%\subsection{Recursive Types}
%
%In the data type equations given so far we have only used the equations in
%a hierarchical manner (the data type identifiers occurring on the
%right-hand-side in the equations have already been defined).  However,
%there are occasions when it is appropriate to use a collection of
%equations which are mutually recursive. 
%
%Without going into the mathematical details about how such recursive
%equations are solved, it will shortly be explained what they denote and how
%their usage must be restricted. We define that the semantics of such a
%collection of mutually recursive equations is that the data types become
%the set of all those values which can be constructed by using the equations
%a finite number of times. Thus, types containing infinite values cannot be
%constructed by means of recursive definitions.
%
%In order to achieve this, the recursive equations need to fulfill two
%requirements:
%\begin{enumerate}
%\item There must exist at least one alternative in a union type which is
%  fully defined elsewhere (a so-called base case).
%
%\item It must not be possible for a data value to belong to two different
%  alternatives in a union type. Thus, for recursive equations the
%  alternatives in union types must be disjunct.
%\end{enumerate}
%If these two requirements are fulfilled then the recursive type definitions
%are interpreted as the collection of finite values which are constructed by
%a finite number of steps in this process.
%
%To illustrate the use of recursive type definitions here is an example
%modelling a forest using recursive type definitions.
%
%\begin{alltt}
%  Forest = Forest * Node * Forest;
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent It is clear that the first requirement (1) cannot be fulfilled,
%because there is no base case for the forest type. Thus, these type
%definitions only specify infinite forests, and thus are not valid in
%\vdmslpp{\vdmsl}{\vdmpp}.
%
%Let us try to repair this by letting a node be the base case in the
%first definition:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent However, these two definitions do not fulfill the second
%requirement. This can be seen from the fact that a forest can be a node, and 
%that node in turn can be a forest, etc. In this case it is not possible to say
%which alternative a given value belongs to. Thus, these definitions are
% not valid in \vdmslpp{\vdmsl}{\vdmpp}\ either.
%
%Now let us try to repair it by letting the base case be empty (i.e.\ 
%a nil value):
%
%\begin{alltt}
%  Forest = [Forest * Node * Forest];
%  Node = \keyw{nat} | Forest
%\end{alltt}
%
%\noindent These definitions are valid, but they specify something slightly
%different than the intention behind the definitions above. With these
%definitions an empty forest exists, and this is not the case for the
%definitions above.
%
%Finally we try to repair it by means of tagging:
%
%\begin{alltt}
%  Forest = Node | (Forest * Node * Forest);
%  Node :: \keyw{nat} | Forest
%\end{alltt}
%
%\noindent By making {\tt Node} a composite type, the definitions are valid,
%because the second requirement is also fulfilled here, due to tagging of
%the node. With these definitions an empty forest will not exist.
%
\subsection{不変条件}

もし先に述べた等式によって指定されたデータ型が許されるべきでない値を含むような場合、それは1つの不変条件により1つの型の値に制限することができる。
結果として、その型はもともとの値の部分集合に制限されるということである。
このように、述語の手段によって、定義された型の条件にかなう値はこの式がtrueとなる値に制限されるのである。

不変条件の使用についての一般的構成は次の通り:

\begin{alltt}
  Id = Type
  \keyw{inv} pat == expr
\end{alltt}

\noindent 
 ここで {\tt pat}は{\tt Id}型に属する値にマッチングさせるパターンであり、{\tt expr}はtrueとなる式であり、パターン{\tt pat}から識別子のいくつかまたはすべてを含んでいる。

ある不変条件が定義された場合、1つの新しい (全) 関数がシグネチャと共に暗黙に生成される:
\begin{alltt}
  \keyw{inv\_}Id : Type +> \keyw{bool}
\end{alltt}

この関数は、他の不変条件、関数、あるいは操作の定義中で用いることも可能である。

たとえば、\pageref{scoredef}ページ上に定義されたレコード型\texttt{Score}を思い返してみよう。
不変条件を用いることで、得点数は勝つか引き分けたゲームの数と一致する、ということが保障できる:
\begin{alltt}
  Score :: team : Team
           won : nat
           drawn : nat
           lost : nat
           points : nat
  inv sc == sc.points = 3 * sc.won + sc.drawn;
\end{alltt}
この型に対して暗黙に作成される不変条件関数は次の通り:
\begin{alltt}
  \keyw{inv\_}Score : Score +> \keyw{bool}
  \keyw{inv\_}Score (sc) == 
    sc.points = 3 * sc.won + sc.drawn;
\end{alltt}

\section{アルゴリズム定義}
\label{algorithm}


\vdmslpp{\vdmsl}{\vdmpp}では、アルゴリズムが関数と操作の両方により定義できる。 
しかしながら、伝統的なプログラム言語における関数にただちに相当するというものではない。
\vdmslpp{\vdmsl}{\vdmpp}において関数と操作を区別するものは、ローカルおよびグローバル変数の使用である。
操作は、グローバル変数といくらかのローカル変数の両方を扱うことができる。
ローカル変数とグローバル変数の両者については後に述べられる。
関数は、グローバル変数にアクセスすることはできないしローカル変数を定義することも許されていないという意味で、純粋なものである。
このように、操作が命令的なものである一方で、関数は純粋に作用的なものである。

関数と操作は、陽に(明確なアルゴリズム定義によって)あるいは陰に(事前条件または事後条件によって)、両方法で定義することができる。
関数に対する明示的なアルゴリズム定義を式と呼ぶ一方、操作に対するそれは文と呼ぶ。事前条件は、関数や操作が評価される前に何を保持していなくてはならないかを指定するtrueの値をとる式である。
事前条件は、パラメーター値と(操作の場合は)グローバル変数のみを参照することができる。
%事前条件のみは(それが操作である場合に)パラメーター値やグローバル変数を参照することができる。
事後条件もまた、関数や操作が評価された後に何が保持されなければならないかを指定するtrueの値をとる式である。
事後条件は、結果識別子、パラメーター値、グローバル変数の現在値、そしてグローバル変数の旧値、を参照することができる。
グローバル変数の旧値とは、操作が評価される前の変数の値のことである。
関数ではグローバル変数の変更は許されていないが、操作だけはグローバル変数の旧値を参照することができる。

しかしながら、インタープリタにより関数と操作の両方の実行を可能にするためには、それらは明示的に定義されていなければならない\footnote{暗黙に指定された関数と演算は一般的に実行できない、というのもそれらの事後条件は出力を入力に明白に関係づける必要がないからである。出力が満たさなくてはならないプロパティを指定することで、しばしば済む。}。
\vdmslpp{VDM-SL}{\vdmpp}では、陽関数および操作定義に対して追加の事前または事後条件を指定することもできる。
陽関数および操作定義の事後条件において、結果の値は予約語 \keyw{RESULT}によって参照されなければならない。
 
\section{関数定義}\label{functiondef}

\vdmslpp{VDM-SL}{\vdmpp}では、1階関数と高階関数を定義することができる。 
高階関数とは、カリー化関数(結果として関数を返す関数)かまたは関数を引数にとる関数である。
さらには、1階のものも高階のものもいずれも多相であることが可能である。
一般的に、ある関数を定義するための構文は次の通り:

\Rule{関数定義}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}}, 
         \OptPt{\Lit{;}}
        }
  }

\ifthenelse{\boolean{VDMpp}}{
  \Rule{アクセス関数定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{関数定義}
  }}{}


\ifthenelse{\boolean{VDMpp}}{
  \Rule{アクセス}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Rule{関数定義}{
  \Ruleref{陽関数定義} \dsep
  \Ruleref{陰関数定義} \dsep
  \Ruleref{拡張陽関数定義}
  }

\Rule{陽関数定義}{
  \Ruleref{識別子}, 
\lfeed
  \OptPt{\Ruleref{型変数リスト}}, 
  \Lit{:}, \Ruleref{関数型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーターリスト}, \Lit{$==$}, \lfeed
  \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed

  \OptPt{\Lop{measure}, \Ruleref{名称}}
  }                                 

\Rule{陰関数定義}{
  \Ruleref{識別子}, 
  \OptPt{\Ruleref{型変数リスト}},\lfeed
  \Ruleref{パラメーター型}, \Ruleref{識別子型ペアリスト}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}
}

\Rule{拡張陽関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed
  \Ruleref{パラメーター型},\lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
}

\Rule{型変数リスト}{
  \Lit{[}, \Ruleref{型変数識別子}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{型変数識別子}}, \Lit{]}
  }

\Rule{識別子型ペアリスト}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{識別子}, \Lit{:}, \Ruleref{型}}
}

\Rule{パラメーター型}{
  \Lit{(}, \OptPt{\Ruleref{パターン型ペアリスト}}, \Lit{)}
  }

\Rule{パターン型ペアリスト}{
  \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{パターンリスト},\Lit{:}, \Ruleref{型}}
  }

\Rule{関数型}{
  \Ruleref{部分関数型} \dsep
  \Ruleref{全関数型}
  }

\Rule{部分関数型}{
  \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}
  }

\Rule{全関数型}{
  \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}
  }

\Rule{任意の型}{
  \Ruleref{型} \dsepl \Lit{(},\Lit{)}
  }

\Rule{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Rule{パターンリスト}{
  \Ruleref{パターン},\SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\Rule{関数本体}{
  \Ruleref{式} \dsep 
#ifdef VDMPP
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!functions}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!functions}
#endif VDMSL
  }

ここで、あるモデルが発展過程にある間は\keyw{is not yet specified}の指定が関数本体として用いられることが許されている%
#ifdef VDMSL
。
#endif VDMSL
#ifdef VDMPP
; \keyw{is subclass responsibility}の指定はこの関数本体の実行にはどのようなサブクラスでも責任を負わなければならないことを示す。
#endif VDMPP

#ifdef VDMPP
アクセスおよび\keyw{static} 指定子の詳細は、第 \ref{ch:interface}節に記述がある。
静的関数は静的でない操作や関数を呼び出すことは許されていない、また静的関数の定義において自身の式を用いることはできない、ということは注意しておこう。
#endif VDMPP

陽関数定義の簡単な例は関数\texttt{map\_inter}であり、これは自然数上の2つの両立する写像をもってきて、両者に共通する写を返すものである
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
関数結果についての主張を許すために選択事後条件をさらにまた用いることができることにも注意しよう:
\begin{alltt}
  map_inter: (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_inter (m1,m2) ==
    (\keyw{dom} m1 \keyw{inter} \keyw{dom} m2) <: m1
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} \keyw{RESULT} = \keyw{dom} m1 \keyw{inter} \keyw{dom} m2
\end{alltt}

同じ関数が暗黙的にまた定義されることも可能である:
\begin{alltt}
  map_inter2 (m1,m2: \keyw{map nat to nat}) m: \keyw{map nat to nat}
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} m = \keyw{dom} m1 \keyw{inter dom} m2 and
       \keyw{forall} d \keyw{in set dom} m & m(d) = m1(d);
\end{alltt}

拡張陽関数定義(標準ではない)の簡単な例は関数 \texttt{map\_disj} で、これは自然数上で2つの両立する写像を持ってきて、それらのどちらかの写像に対して唯一の写からなる写像を返す:

\begin{alltt}\label{mapdisj}
  map_disj (m1:\keyw{map nat to nat},m2:\keyw{map nat to nat}) res : \keyw{map nat to nat} ==
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m1 \keyw{munion}
    (\keyw{dom} m1 \keyw{inter dom} m2) <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
  \Keyw{post} \keyw{dom} res = (\keyw{dom} m1 \keyw{union dom} m2) \verb+\+ (\keyw{dom} m1 \keyw{inter dom} m2) 
       and
       \keyw{forall} d \keyw{in set dom} res & res(d) = m1(d) or res(d) = m2(d)
\end{alltt}
(ここにおいて事後条件をインタープリタに通す試みは、もしかすると実行時エラーを引き起こすかもしれない、というのは \texttt{m1(d)} と\texttt{m2(d)}は同時に両者が定義される必要はないからなのである。)

関数 {\tt map\_inter} と {\tt map\_disj} はインタプリターにより評価することが可能であるが、暗黙的関数である {\tt map\_inter2} は評価することができない。
しかしながら、これら3つの場合における事前条件と事後条件は他の関数のなかで使用することが可能である; たとえば\texttt{map\_inter2}の定義から、関数 \texttt{\keyw{pre\_}map\_inter2}と \texttt{\keyw{post\_}map\_inter2}を以下のシグネチャで得る:

\begin{alltt}
  \keyw{pre\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) +> \keyw{bool}
  \keyw{post\_}map_inter2 : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) *
                   (\keyw{map nat to nat}) +> \keyw{bool}
\end{alltt}
これらの種類の関数は自動的にインタープリタで作成され、他の定義においても用いることができる(この技術は引用とよばれる)。
一般的に、次のシグネチャをもつ関数 \texttt{f} に対して
\begin{alltt}
  f : T1 * ... * Tn -> Tr
\end{alltt}
関数に対する事前条件を定義することで、次のシグネチャの関数 \texttt{\keyw{pre\_}f}が生成される。
\begin{alltt}
  \keyw{pre\_}f : T1 * ... * Tn +> bool
\end{alltt}
そして関数に対する事後条件を定義することで、次のシグネチャの関数 \texttt{\keyw{post\_}f} が生成される。
\begin{alltt}
  \keyw{post\_}f : T1 * ... * Tn * Tr +> bool
\end{alltt}

関数は再帰 (自分自身の呼び出し) を使って定義することもできる。
再帰呼び出しを使う場合、\Lop{measure} 関数を追加することが推奨される。
これによって、実行が終了すること保証する証明課題を生成することができるようになる。
シンプルな階乗関数の例を以下に定義する:

\begin{alltt}
functions

fac: nat +> nat
fac(n) ==
  if n = 0
  then 1
  else n * fac(n - 1)
measure id
\end{alltt}
ここで、 \texttt{id}は以下のように定義されている:
\begin{alltt}
id: nat +> nat
id(n) == n
\end{alltt}

\subsection{多相関数}

関数はまた多相であることが可能である。
これは、複数の異なる型の値のもとに使用可能な包括的な関数を生成することができるということを意味する。
この目的のために、型引数 (または接頭辞{\tt @}記号をおき通常の識別子と同様に記述された型変数) が用いられる。
空のバッグをつくりだすための多相関数を考える:
\footnote{多相関数の例は\cite{Dawes91}から引用する。
バッグというのは、バッグの中での要素からその要素の重複度への写像をモデル化したものである。 
ここでの重複度は少なくも1以上であり、つまり要素がないならこの写像の役目は負えないので、0に写像されるものではない。}
\begin{alltt}
  empty_bag[@elem] : () +> (\keyw{map} @elem \keyw{to nat1})
  empty_bag() ==
    \{ |-> \}
\end{alltt}
上記の関数が使用できる以前のこととして、関数 {\tt empty\_bag}の、たとえば整数といったある型のインスタンス生成を行わなくてはならない:
\begin{alltt}
  emptyInt = empty_bag[int]
\end{alltt}
さぁこれで整数をいれるための新しいバッグをつくるために、関数 {\tt emptyInt} を使用することができる。
更なる多相関数の例としては:
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    \keyw{if} e \keyw{in set dom} m
    \Keyw{then} m(e)
    \Keyw{else} 0;

  plus_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> (\keyw{map} @elem \keyw{to nat1})
  plus_bag(e, m) ==
    m ++ \{ e |-> num_bag[@elem](e, m) + 1 \}
\end{alltt} 
もし事前条件や事後条件が多相関数に対して定義された場合は、対応する述語関数もまた多相である。
たとえばもし \texttt{num\_bag}が下記のように定義されていたとすると
\begin{alltt}
  num_bag[@elem] : @elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{nat}
  num_bag(e, m) ==
    m(e)
  \Keyw{pre} e \keyw{in set dom} m
\end{alltt}
事前条件は次のようになるであろう
\begin{alltt}
  \keyw{pre\_}num_bag[@elem] :@elem * (\keyw{map} @elem \keyw{to nat1}) +> \keyw{bool}
\end{alltt}


また、\keyw{measure}は機能が多相的に定義された時も使用されるべきである。
ただし、現在は \keyw{measure} を高階関数では使うことができない。

\subsection{高階関数}

関数は他の関数を引数として受け取ることが許される。
この簡単な例は、自然数の列となる関数\texttt{nat\_filter} であり、1つの述語をもち、この述語を満足させる部分列を返すものである:
\begin{alltt}
  nat_filter : (\keyw{nat} -> \keyw{bool}) * \keyw{seq of nat} -> \keyw{seq of nat}
  nat_filter (p,ns) ==
    [ns(i) | i \keyw{in set inds} ns & p(ns(i))];
\end{alltt}
このとき 
  \texttt{nat\_filter (\keyw{lambda} x:\keyw{nat} \& x \keyw{mod} 2 = 0, [1,2,3,4,5])} $\equiv$ \texttt{[2,4]}.
実際、このアルゴリズムは自然数に限ったものではない、したがってこの関数の多相版を定義してもよいであろう:
\begin{alltt}\label{filterdef}
  filter[@elem]: (@elem -> \keyw{bool}) * \keyw{seq of} @elem -> \keyw{seq of} @elem
  filter (p,l) ==
    [l(i) | i \keyw{in set inds} l & p(l(i))];
\end{alltt}
so \texttt{filter[\keyw{real}](\keyw{lambda} x:\keyw{real} \&
  \keyw{floor} x = x, [2.3,0.7,-2.1,3])} $\equiv$  \texttt{[3]}.

関数はまた結果として関数を返してもよい。
これの例は関数 \texttt{fmap}である:
\begin{alltt}
  fmap[@elem]: (@elem -> @elem) -> \keyw{seq} of @elem -> \keyw{seq} of @elem
  fmap (f)(l) ==
    \keyw{if} l = []
    \keyw{then} []
    else [f(\keyw{hd} l)]\verb+^+(fmap[@elem] (f)(\keyw{tl} l));
\end{alltt}
よって 
 \texttt{fmap[\keyw{nat}](\keyw{lambda} x:\keyw{nat} \& x * x)([1,2,3,4,5])} $\equiv$ 
\texttt{[ 1,4,9,16,25 ]}
\section{式}

この中の節では異なる種類の式の1つ1つについて述べていこう。
各々を次の方法で記述する:
\begin{itemize}
\item BNF構文記法
\item 非公式な意味定義記述
\item 使用の記述例
\end{itemize}

\subsection{let式}\label{let-exp}

\begin{description}
\item[構文:]
  \Rule{式}{
    \Ruleref{let式} \dsep
    \Ruleref{let be式} \dsep
    \ldots
    }

  \Rule{let式}{
    \Lop{let}, 
    \Ruleref{ローカル定義}
    \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
    \Lop{in}, \Ruleref{式}
    }

  \Rule{let be式}{ 
    \Lop{let}, \Ruleref{束縛},
    \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}}, \Lop{in}, \lfeed
    \Ruleref{式}
    } 

  \Rule{ローカル定義}{
    \Ruleref{値定義} \dsep
    \Ruleref{関数定義}
    }

  \Rule{値定義}{ 
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

  \noindent ここでの構成要素である ``関数定義'' は第~\ref{functiondef}節で述べられている。

\item[意味定義:] 単純な {\it let式} は次の形式をもつ:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} e
  \end{alltt}
ここで、 {\tt p1, \ldots, pn} はパターン、 {\tt e1, \ldots, en} はそれぞれの対応パターン {\tt pi}にマッチさせる式であって、{\tt e} は任意の型でよいが {\tt p1, \ldots, pn}の中のパターン識別子を含む式である。 
これは、パターン{\tt p1,\ldots, pn}が対応する式{\tt e1, \ldots, en}とマッチさせられる文脈中での、式 {\tt e}の値を示している。 

 ローカル関数定義を用いることで、より発展した形のlet式をつくることもできる。
そのようなことを行う意味は単に、このようなローカル定義関数のスコープはlet式の本体に制限されているということにある。

標準の \vdmsl\ においては、定義の収集が相互に再帰するものとなる可能性がある。
しかしながら\vdmslpp{\vdmsl}{\vdmpp}においては、このようなものがインタープリタでサポートされることはない。 
さらに、すべての構成子が使用される前に定義されているように、定義に順番付けがされていなければならない。
     
   {\it let-be-such-that 式}は次の形式をもつ:
  \begin{alltt}
    \keyw{let} b \keyw{be st} e1 \keyw{in} e2
  \end{alltt}%
ここでは、 {\tt b} は集合値(または型)に対する束縛で、 {\tt e1}は ブール式、 {\tt e2} は式だが何の型であってもよく、{\tt b}におけるパターンのパターン識別子を含むものである。
 {\tt \keyw{be st} e1} 部分はオプション。
この式は、{\tt b}のパターンが{\tt b}の集合要素かまたは{\tt b}の中の型の値とマッチさせる文脈中での式 {\tt e2}の値を示す
  \footnote{集合束縛のみはインタープリタによって実行できることを思い出そう。}。 {\tt \keyw{st} e1}式がある場合は、マッチングの文脈中で{\tt e1}がtrueとなる束縛のみが用いられる。

\item[例題:] {\it let式} は読みやすさの改善に役立つ、特に何回も使われる複雑な式は縮めることで改善される。
たとえば \pageref{mapdisj}ページの関数 \texttt{map\_disj}を改善することができる:\begin{alltt}
  map_disj : (\keyw{map nat to nat}) * (\keyw{map nat to nat}) -> \keyw{map nat to nat}
  map_disj (m1,m2) ==
    \keyw{let} inter_dom = \keyw{dom} m1 \keyw{inter dom} m2
    \keyw{in}
      inter_dom <-: m1 \keyw{munion}
      inter_dom <-: m2
  \Keyw{pre} \keyw{forall} d \keyw{in set dom} m1 \keyw{inter dom} m2 & m1(d) = m2(d)
\end{alltt}
また複雑な構造体を構成要素に分解する上でも便利である。
たとえば、前に定義したレコード型 \texttt{Score} (\pageref{scoredef}ページ) を使用することで、あるスコアがもうひとつより大きいかどうかをテストすることができる:
  \begin{alltt}
    \keyw{let} \keyw{mk\_}Score(-,w1,-,-,p1) = sc1,
       \keyw{mk\_}Score(-,w2,-,-,p2) = sc2
    \keyw{in} (p1 > p2) \keyw{or} (p1 = p2 \keyw{and} w1 > w2)
  \end{alltt}
この特別な例では、2つのスコアから2番目と5番目の構成要素を抽出している。
 don't careパターン(\pageref{patterns}ページ)が、この式本体で行われた処理と残りの構成要素が無関係であることを示するために用いられていることに注目しよう。
  {\it let-be-such-that式} は、1つの集合から1つの要素を選ぶ意味のない選択を減らすために、特に集合上での再帰定義の形式化において用いられる。
これについての例は、列のfilter関数 (\pageref{filterdef}ページ)を集合上で考えたものである:
\label{setfilterdef}
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \keyw{if} s = \{\}
      \keyw{then} \{\}
      \keyw{else let} x \keyw{in set} s
          \keyw{in} (\keyw{if} p(x) \keyw{then} \{x\} \keyw{else} \{\}) \keyw{union}
             set_filter[@elem](p)(s \verb+\+ \{x\});
   \end{alltt}
別の方法として、この関数を集合内包 (第 \ref{setexpr}節参照)を用いて定義することもできるであろう:
  \begin{alltt}
    set_filter[@elem] : (@elem -> \keyw{bool}) -> (\keyw{set of} @elem) -> 
                        (\keyw{set of} @elem)
    set_filter(p)(s) ==
      \{ x | x \keyw{in set} s & p(x)\};
  \end{alltt} 

 最後の例はオプションである ``be such that'' 部分をどのように用いることができるかを示す。
いくつかのプロパティをもつある要素が存在することはわかっているがその要素に対する明示的な式がわからないまたは記述することが難しい場合に、この部分は特に役に立つ。たとえばこの式を選択ソートアルゴリズムを書くために活用することができる:
   \begin{alltt}\label{selectionSortdef}
   remove : \keyw{nat} * \keyw{seq of nat} -> \keyw{seq of nat}
   remove (x,l) ==
     \keyw{let} i \keyw{in set inds} l \keyw{be st} l(i) = x
     \keyw{in} l(1,...,i-1)\verb+^+l(i+1,...,\keyw{len} l)
   \Keyw{pre} x \keyw{in set elems} l;

   selection_sort : \keyw{seq of nat} -> \keyw{seq of nat}
   selection_sort (l) ==
     \keyw{if} l = []
     \keyw{then} []
     \keyw{else let} m \keyw{in set elems} l \keyw{be st}
         \keyw{forall} x \keyw{in set elems} l & m <= x
         \keyw{in} [m]\verb+^+(selection_sort (remove(m,l)))
   \end{alltt}
   ここでは、最初の関数は与えられたリストから与えられた要素を取り除く；
2番目の関数は並び替えされていないリスト部分から最も小さい要素を繰り返し取り除き、並び替えされた部分の頭に置く。
\end{description}

\subsection{def式} \label{define-exp}

この式は、第~\ref{op-def}節で述べられる操作の内部でのみ用いることができる。
式の部分でグローバル変数を取り扱うために、操作の内部で特別な式(すなわちdef式)が許されている。

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{def式} \dsep
    \ldots
    }

\Rule{def式}{
  \Lop{def}, 
  \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{式}
  } 

\item[意味定義:] {\it def式} は次の形式をもつ:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \Keyw{in}
      e
  \end{alltt}
   {\it def式} は、右辺の式がローカル変数やグローバル変数の値に従属する可能性はあるが相互に再帰するものではない、といったことを除けば、let式に相等する。
これは、パターン(または束縛){\tt pb1, \ldots, pbn}が対応する式 {\tt e1, \ldots,    en}とマッチする文脈中で、式{\tt e}の値を示す\footnote{束縛が用いられている場合は、簡単に言えばパターンと一致した値はさらに第~\ref{patterns}章で述べられる型式または集合式によって制限を受けるということを意味する。}。

\item[例題:] 式の値はグローバル変数に従属するという事実に気づいてもらえるよう、{\it def式} が合理的な方法で用いられる。

 これは小さな例で説明することができる:
  \begin{alltt}
    \Keyw{def} user = lib(copy) \keyw{in}
      \keyw{if} user = <OUT>
      \Keyw{then} \keyw{true}
      \Keyw{else} \keyw{false}
  \end{alltt}      
   {\tt copy} が文脈中に定義されている場所で、{\tt lib} はグローバル変数である(このように {\tt lib(copy)} は変数の一部の内容検索と考えることができる)。

  第\ref{letstmt}節の操作 \texttt{GroupRunnerUp\_expl} でもまたdef式の例が与えられている。
\end{description}

\subsection{単項式または2項式}\label{unandbin}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{単項式} \dsep \Ruleref{2項式} \dsep \ldots
    }

\Rule{単項式}{
  \Ruleref{接頭辞式} \dsep
  \Ruleref{逆写像}
  }

\Rule{接頭辞式}{
  \Ruleref{単項演算子}, \Ruleref{式}
  }

  \Rule{単項演算子}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lop{abs} \dsepl
    \Lop{floor} \dsepl \Lop{not} \dsep
    \Lop{card} \dsepl \Lop{power} \dsepl \Lop{dunion} \dsepl
    \Lop{dinter} \dsep
    \Lop{hd} \dsepl \Lop{tl} \dsepl \Lop{len} \dsepl \Lop{elems} \dsepl
    \Lop{inds} \dsepl \Lop{conc} \dsep
    \Lop{dom} \dsepl \Lop{rng} \dsepl \Lop{merge} 
    }

\Rule{逆写像}{
  \Lop{inverse}, \Ruleref{式}
  }

  \Rule{2項式}{
    \Ruleref{式}, \Ruleref{2項演算子}, \Ruleref{式}}

  \Rule{2項演算子}{
    \Lit{+} \dsepl \Lit{-} \dsepl \Lit{*} \dsepl \Lit{/} \dsep
    \Lop{rem} \dsepl \Lop{div} \dsepl \Lop{mod} \dsepl \Lit{**} \dsep
    \Lop{union} \dsepl \Lop{inter} \dsepl \Lit{\char'134} \dsepl
    \Lop{subset} \dsep
    \Lop{psubset} \dsepl \Lop{in set} \dsepl \Lop{not in set} \dsep
    \Lit{\char'136} \dsep
    \Lit{++} \dsepl \Lop{munion} \dsepl \Lit{<:} \dsepl \Lit{<-:} \dsepl \Lit{:>} \dsepl \Lit{:->} \dsep
    \Lop{and} \dsepl \Lop{or} \dsep
    \Lit{=>} \dsepl \Lit{<=>} \dsepl \Lit{=} \dsepl \Lit{<>} \dsep
    \Lit{<} \dsepl \Lit{<=} \dsepl \Lit{>} \dsepl \Lit{>=} \dsep
    \Lop{comp}
    }

\item[意味定義:] 
単項式と2項式は、特定の型の値を記述する演算子と演算対象の結合である。
これらすべての演算子のシグネチャについては、すでに第~\ref{typedef}節で述べてあるのでそれ以上の説明はここでは行わない。
逆写像単項演算子は、数学的構文における接尾辞記号で記述されるため、別に取り扱う。
\item[例題:] これらの演算子を用いた例題は第~\ref{typedef}節で与えられるため、ここでは触れない。
\end{description}

\subsection{条件式}
\label{if-exp} \label{cases-exp}
\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{if式} \dsep \Ruleref{cases式} \dsep \ldots
    }

  \Rule{if式}{
    \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{式},\lfeed
    \SeqPt{\Ruleref{elseif式}}, \Lop{else}, \Ruleref{式}
    }

  \Rule{elseif式}{
    \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{式}
    }
                     
  \Rule{cases式}{
    \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
    \Ruleref{cases式選択肢群}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others式}}, \Lop{end}
    }

  \Rule{cases式選択肢群}{
    \Ruleref{cases式選択肢},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases式選択肢}}
    }

  \Rule{cases式選択肢}{
    \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{式}
    } 

  \Rule{others式}{
    \Lop{others}, \Lit{->}, \Ruleref{式}
    }

\item[意味定義:]  {\it if式} と {\it cases式}は、1つの特定の式の値を基に、複数の中から1つの式を選ぶことを可能にする。

  {\it if式} は次の形式をもつ:
  \begin{alltt}
    \keyw{if} e1
    \Keyw{then} e2
    \Keyw{else} e3
  \end{alltt}
ここで {\tt e1} はブール式であり、一方  {\tt e2} と {\tt e3} はどのような型であってもよい。
もし {\tt e1}が与えられた文脈中でtrueであるならば、 if式は与えられた文脈中で評価された{\tt e2}の値を表す。
そうでなければ、if式は与えられた文脈上で {\tt e3}の値を表す。
 \keyw{elseif}式の使用は、ある式の\keyw{else}部分においてネストされたif-then-else式を単に省略したものである。

  {\it cases式} は次の形式をもつ
  \begin{alltt}
    \keyw{cases} e :
      p11, p12, ..., p1n -> e1,
      ...                -> ...,
      pm1, pm2, ..., pmk -> em,
      \Keyw{others}             -> emplus1
    \keyw{end}
  \end{alltt}
 ここで {\tt e} は1つの任意の型の式であり、{\tt pij} で表すすべては1つ1つが式 {\tt e}にマッチするパターンである。 
{\tt  ei}で表すのは任意の型の式であり、キーワードの \keyw{others} とそれに対応する式{\tt emplus1}とはオプションとなる。 
cases式では、 {\tt pij} パターンの1つが {\tt e}にマッチした文脈中で評価された{\tt ei} 式の値を示す。 
選択された {\tt ei} は、パターンの1つを式 {\tt e}とマッチさせることができた最初の入口である。
もしパターンのうちのどれも{\tt e}にマッチしない場合には、 \keyw{others} 節がなくてはならないし、そこでcases式は与えられた文脈中で評価される{\tt emplus1}の値を示す。
     
\item[例題:] 
 \vdmslpp{\vdmsl}{\vdmpp}\ におけるif式は、大部分のプログラム言語において用いられているものに相等するが、その一方 \vdmslpp{\vdmsl}{\vdmpp}\ における cases式は、大部分のプログラム言語よりもより一般的なものとなる。
このことは実際にパターンマッチングがおきる事例から見て取れるであろうが、しかしまた大部分のプログラム言語におけるようなパターンが定数である必要がないためでもある。
  条件式の使用例はマージソートアルゴリズムの記述により提供される:
  \begin{alltt}
  lmerge : \keyw{seq of nat} * \keyw{seq of nat} -> \keyw{seq of nat}
  lmerge (s1,s2) ==
    \keyw{if} s1 = [] \keyw{then} s2
    \keyw{elseif} s2 = [] \keyw{then} s1
    \keyw{elseif} (\keyw{hd} s1) < (\keyw{hd} s2)
    \keyw{then} [\keyw{hd} s1]\verb+^+(lmerge (\keyw{tl} s1, s2))
    \keyw{else} [\keyw{hd} s2]\verb+^+(lmerge (s1, \keyw{tl} s2));

  mergesort : \keyw{seq of nat} -> \keyw{seq of nat}
  mergesort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      l1\verb+^+l2 -> lmerge (mergesort(l1), mergesort(l2))
    \keyw{end}
  \end{alltt}
cases式によって提供されたパターンマッチングは、型の合併を扱うことに役立つ。
たとえば、\pageref{exprdef} ページからの型定義\texttt{Expr}を用いることで次を得る:
  \begin{alltt}\label{printExprDef}
  print_Expr : Expr -> \keyw{seq1 of char}
  print_Expr (e) ==
    \keyw{cases} e:
      \keyw{mk\_}Const(-) -> "Const of"\verb+^+(print_Const(e)),
      \keyw{mk\_}Var(id,-) -> "Var of"\verb+^+id,
      \keyw{mk\_}Infix(\keyw{mk\_}(e1,op,e2)) -> "Infix of"\verb+^+print_Expr(e1)^","
                                      \verb+^+print_Op(op)\verb+^+","
                                      \verb+^+print_Expr(e2),
      \keyw{mk\_}Cond(t,c,a) -> "Cond of"\verb+^+print_Expr(t)\verb+^+","
                                 \verb+^+print_Expr(c)\verb+^+","
                                 \verb+^+print_Expr(a)
    end;

  print_Const : Const -> \keyw{seq1 of char}
  print_Const(\keyw{mk\_}Const(c)) ==
    \keyw{if} \keyw{is\_nat}(c)
    \keyw{then} "nat"
    \keyw{else} -- must be bool
         "bool";
  \end{alltt}
  関数 \texttt{print\_Op}は同様に定義されるであろう。
\end{description}

\subsection{限量式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{限量式} 
    \dsep \ldots
    }

  \Rule{限量式}{
    \Ruleref{全称限量式} \dsep
    \Ruleref{存在限量式} \dsep
    \Ruleref{1存在限量式}
    } 

  \Rule{全称限量式}{
    \Lop{forall}, \Ruleref{束縛リスト}, \Lit{\char'046}, \Ruleref{式}
    }
    
  \Rule{存在限量式}{
      \Lop{exists}, \Ruleref{束縛リスト}, \Lit{\char'046}, \Ruleref{式}
    }

  \Rule{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Rule{1存在限量式}{
    \Lop{exists1}, \Ruleref{束縛}, \Lit{\char'046}, \Ruleref{式}
    }

\item[意味定義:] 限量式には3つの形式がある:
  {\it 全称} ( \keyw{forall}と記述される), {\it 存在} ( \keyw{exists}と記述される), そして {\it 1 存在} ( \keyw{exists1}と記述される)である。
以下に述べられるように、各々はブール値である \keyw{true} または \keyw{false}の値をとる。

   {\it 全称限量式} は次の形式をもつ:
  \begin{alltt}
    \keyw{forall} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  ここで各々の {\tt mbdi} は多重束縛 {\tt pi \keyw{in set} s} (あるいは型束縛であるならば {\tt pi : 型})であり、 {\tt e} は {\tt mbdi}のパターン識別子を含むブール式である。 
この値は、{\tt e}を {\tt mbd1, mbd2, \ldots,
    mbdn}における束縛のすべてにおいて文脈上で評価して、\keyw{true}であるならば \keyw{true}となりそうでない場合は\keyw{false} となる。

   {\it 存在限量式} は次の形式をもつ:
  \begin{alltt}
    \keyw{exists} mbd1, mbd2, \ldots, mbdn \& e
  \end{alltt}
  ここで {\tt mbdi} および {\tt e} は、全称限量式におけるものと同じである。
ここで{\tt mbd1, mbd2, \ldots, mbdn}における束縛の少なくとも1つを選択した文脈上で評価した場合に{\tt e} が \keyw{true}であったならば、この値は \keyw{true} となりそうでない場合は \keyw{false} となる。

   {\it 1 存在限量式} は次の形式をもつ:
  \begin{alltt}
    \keyw{exists1} bd \& e
  \end{alltt}
  ここで{\tt bd}は 集合束縛か型束縛であり、 {\tt e} は {\tt bd}のパターン識別子を含むブール式である。
束縛のうちのちょうど1つを選択した文脈上で評価して{\tt e} が \keyw{true} であるならば、この値は\keyw{true}となりそうでない場合は \keyw{false} となる。

 すべての限量式は、可能な優先度の中で最も低い優先度を持つ。
これは、可能な限り長い構成式が使われることを意味する。
式は、構文的に可能な限りの右側へ続く。


\item[例題:] 
存在限量の例は以下の \texttt{QualificationOk}で提示される関数で与えられる。
この関数は、\cite{Fitzgerald&98}における化学プラント警報システムの仕様書からとってきたものであるが、ある専門家の集団が要求された資質を満たすか否かを照合するものである。
  \begin{alltt}
  types

  ExpertId = \keyw{token};
  Expert :: expertid : ExpertId
            quali : \keyw{set of} Qualification
  \keyw{inv} ex == ex.quali <> {};
  Qualification = <Elec> | <Mech> | <Bio> | <Chem>

  functions

  QualificationOK: \keyw{set of} Expert * Qualification -> \keyw{bool}
  QualificationOK(exs,reqquali) ==
      \keyw{exists} ex \keyw{in set} exs & reqquali \keyw{in set} ex.quali
  \end{alltt}
  この関数 \texttt{min} は全称限量の例を示す: 
  \begin{alltt}
  min(s:\keyw{set of nat}) x:\keyw{nat}
  \Keyw{pre} s <> \{\} 
  \Keyw{post} x \keyw{in set} s \keyw{and}
       \keyw{forall} y \keyw{in set} s \verb+\+ \{x\} & y < x
  \end{alltt}
1 存在限量は、すべての写像\texttt{m}が満足する関数プロパティを述べるために用いることができる:
  \begin{alltt}
  \keyw{forall} d \keyw{in set dom} m &
    \keyw{exists1} r \keyw{in set rng} m & m(d) = r
  \end{alltt}


\end{description}

\subsection{iota式}\label{iotaexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{iota式} \dsep
    \ldots
    }

  \Rule{iota式}{
    \Lop{iota}, \Ruleref{束縛}, \Lit{\char'046}, \Ruleref{式}
    }

\item[意味定義:] {\it iota式}は次の形式をもつ:
  \begin{alltt}
    \keyw{iota} bd \& e
  \end{alltt}
  ここで{\tt bd} は集合束縛かまたは型束縛であり、 {\tt e} は {\tt bd}のパターン識別子を含むブール式である。
束縛に一致して本体式 {\tt e} を \keyw{true} とする唯一の値が存在するならば、\keyw{iota} 演算子を唯一用いることができる(i.e.\ {\tt \keyw{exists1} bd \& e} は \keyw{true}でなくてはならない)。 
 iota式の意味定義は、本体式 ({\tt e})を満たす唯一の値を返すということである。

\item[例題:] 
 次に定義された値 \texttt{sc1,...,sc4} を用いる
  \begin{alltt}
    sc1 = \keyw{mk\_}Score (<France>, 3, 0, 0, 9);
    sc2 = \keyw{mk\_}Score (<Denmark>, 1, 1, 1, 4);
    sc3 = \keyw{mk\_}Score (<SouthAfrica>, 0, 2, 1, 2);
    sc4 = \keyw{mk\_}Score (<SaudiArabia>, 0, 1, 2, 1);
  \end{alltt}
これより
  
  \begin{tabular}{lcl}
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.team = <France>} & $\equiv$ & \texttt{sc1}\\
    \texttt{ \keyw{iota} x \keyw{in set} \{sc1,sc2,sc3,sc4\} \& 
      x.points > 3} & $\equiv$ & $\perp$\\
    \texttt{ \keyw{iota} x : Score \& x.points < x.won} & $\equiv$ &
  $\perp$
  \end{tabular}

  \noindent 最後の例は実行不可能であり、加えて最後の2式は未定義となることに注意しよう竏酎O者は式を満たす値が多くなるからであり、後者は式を満たす値がないからである。

\end{description}

\subsection{集合式}\label{setexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{集合列挙} \dsep \Ruleref{集合内包} \dsep
    \Ruleref{集合範囲式} \dsep \ldots
    }
  
  \Rule{集合列挙}{
    \Lit{\{}, \OptPt{\Ruleref{式リスト}}, \Lit{\}}
    }

  \Rule{式リスト}{
    \Ruleref{式}, \SeqPt{\Lit{,}, \Ruleref{式}}
    }

  \Rule{集合内包}{
    \Lit{\{}, \Ruleref{式}, \Lit{$|$}, \Ruleref{束縛リスト}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{\}}
    }

  \Rule{集合範囲式}{
    \Lit{\{}, \Ruleref{式}, \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{式}, \Lit{\}}
    }

\item[意味定義:] {\it 集合列挙}は次の形式をもつ:
  \begin{alltt}
    \{e1, e2, e3, \ldots, en\}
  \end{alltt}
 ここで {\tt e1} から {\tt en} までは一般の式である。
列挙された式の値の集合を構成する。
空集合は \verb+{}+ と書かれなければならない。

    {\it 集合内包}式は次の形式をもつ:
  \begin{alltt}
    \{e | mbd1, mbd2, \ldots, mbdn \& P\}
  \end{alltt}
 述語 {\tt P}が \keyw{true}と評価される束縛すべてのもとで、式{\tt e} を評価することで1つの集合が構成される。
多重束縛には集合束縛と型束縛の両方を含めることができる。
したがって{\tt mbdn} は {\tt pat1 \keyw{in set} s1, pat2 : tp1,
    \ldots \keyw{in set} s2}というようになるであろうが、ここにおける {\tt pati} はパターンであり (通常は単なる識別子である)、 {\tt s1} や {\tt s2} は式で構成される集合である ( これに対して{\tt tp1}は、型束縛もまた用いることができることを示すために使われている)。 
ただし型束縛はインタープリタでは実行できないので注意したい。

   {\it 集合範囲式} は集合内包の特別な場合である。
これは次の形式をもつ
  \begin{alltt}
    \{e1, \ldots, e2\}
  \end{alltt}
 ここでの {\tt e1} と {\tt e2} は数式である。
この集合範囲式は {\tt e1} から {\tt e2} までに含まれる整数の集合を表記する。
 {\tt e2} が {\tt e1} よりも小さい場合には、集合範囲式は空集合を表す。

\item[例題:] 
 \texttt{Europe=\{<France>,<England>,<Denmark>,<Spain>\}} および \\
 \texttt{GroupC = \{sc1,sc2,sc3,sc4\}} (ここでの \texttt{sc1,...,sc4} は前述の例にて定義されたもの) の値を用いて次を得る

  \begin{tabular}{lcl}
    \texttt{\{<France>, <Spain>\} \keyw{subset} Europe} & $\equiv$ &
      \keyw{true}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<Brazil>, <Chile>, <England>\}}\\
      \mbox{\hspace{3em}}\texttt{\keyw{subset} Europe} }
      & $\equiv$ &  \keyw{false}\\
    \parbox[t]{7cm}{\raggedright
      \texttt{\{<France>, <Spain>, {\char'042}France{\char'042}\}} \\
      \mbox{\hspace{3em}}\keyw{subset} \texttt{Europe}} &
      $\equiv$ & \keyw{false}\\
    \parbox[t]{7cm}{\raggedright\texttt{\{sc.team | sc \keyw{in set} GroupC }\\
                    \mbox{\hspace{3em}}\texttt{\& sc.points > 2\}}} &
      $\equiv$ & \texttt{\{\parbox[t]{4cm}{<France>,\\ <Denmark>\}}}\\
    \parbox[t]{7cm}{\raggedright
        \texttt{\{sc.team | sc \keyw{in set} GroupC }\\
        \mbox{\hspace{3em}}\texttt{\& sc.lost > sc.won \}}}
      & $\equiv$ & \texttt{\{\parbox[t]{4cm}{<SouthAfrica>, \\<SaudiArabia>\}}}\\
    \texttt{\{2.718,...,3.141\}} & $\equiv$ & \texttt{\{3\}}\\
    \texttt{\{3.141,...,2.718\}} & $\equiv$ & \texttt{\{\}}\\
    \texttt{\{1,...,5\}} & $\equiv$ & \texttt{\{1,2,3,4,5\}}\\
    \texttt{\{ x | x:\keyw{nat} \& x < 10 \keyw{and} x \keyw{mod} 2 = 0\}}
      & $\equiv$ & \texttt{\{0,2,4,6,8\}}
  \end{tabular}
\end{description}

\subsection{列式} \label{seqexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{列列挙} \dsep \Ruleref{列内包} \dsep
    \Ruleref{部分列} \dsep \ldots
    }

  \Rule{列列挙}{
    \Lit{[}, \OptPt{\Ruleref{式リスト}}, \Lit{]}
    }

  \Rule{列内包}{
    \Lit{[}, \Ruleref{式}, \Lit{|}, \Ruleref{集合束縛}, \lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{]}
    }

  \Rule{部分列}{
    \Ruleref{式}, \lfeed
    \Lit{(}, \Ruleref{式},
    \Lit{,}, \Lit{\Range},
    \Lit{,}, \lfeed
    \Ruleref{式}, \Lit{)}
    }

\item[意味定義:]  {\it 列列挙}は次の形式をもつ:
  \begin{alltt}
    [e1, e2, \ldots, en]
  \end{alltt}
  ここでの{\tt e1}から {\tt en} は一般の式である。 
これは列挙された要素の列を構成する。
空列は {\tt []}と書かれなければならない。

   {\it 列内包} は次の形式をもつ:
  \begin{alltt}
    [e | pat \keyw{in set} S \& P]
  \end{alltt}
 ここでの式 {\tt e} は、パターン {\tt pat} からもってきた識別子を用いることになる(通常このパターンは単なる識別子となるが、唯一実際上の必要条件としては、ちょうど1つのパターン識別子のみがパターン中に存在するということである)。 
{\tt S} は値 (通常は自然数)の集合である。
このパターン識別子の束縛は何らかの種類の数値に対するものでなければならず、これにより結果列における要素の順を指示するために用いられる。
述語 {\tt P}が \keyw{true}と評価されるすべての束縛上で式{\tt e}を評価することにより、列を構成する。

列 {\tt l} の{\it 部分列} というのは {\tt l}の連続する要素からなる列;索引 {\tt n1}以上 {\tt n2}以下のもの、である。 
次の形式をもつ:
  \begin{alltt}
    l(n1, ..., n2)
  \end{alltt}
 ここでの {\tt n1} と {\tt n2} は正の整数式である。
 下限の {\tt n1}(空でない列での最初の索引) が1 より小さい場合は、列式は列の最初の要素から始まることとなる。
上限の{\tt n2}(空でない列で索引中最大のもの) が列の長さよりも大きい場合は、列式は列の最後の要素で終わることとなる。

%  A {\it sequence modifier} has the form:
%  \begin{alltt}
%    l ++ \{n1 |-> e1, n2 |-> e2, \ldots, nm |-> em\}
%  \end{alltt}
%  where {\tt l} is an expression denoting a sequence (which is going to be
%  modified), {\tt n1, n2, \ldots, nm} are positive integer expressions
%  (less than the length of {\tt l}) and {\tt e1, e2, \ldots, em} are
%  expressions of any type. The sequence modifier expression denotes the
%  sequence {\tt l} modified in a way so that element {\tt ni} has been
%  replaced by {\tt ei}.

\item[例題:] \texttt{GroupA} が次の列に等しい場合
  \begin{alltt}\label{GroupAdef}
    [ \keyw{mk\_}Score(<Brazil>,2,0,1,6), 
      \keyw{mk\_}Score(<Norway>,1,2,0,5),
      \keyw{mk\_}Score(<Morocco>,1,1,1,4),
      \keyw{mk\_}Score(<Scotland>,0,1,2,1) ]
  \end{alltt} 以下が導かれる:

  \begin{tabular}{lcl}
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i).team \\
            | i \keyw{in set inds} GroupA \\
                  \mbox{\hspace{1em}} \& GroupA(i).won <> 0]}
    &$\equiv$ & 
        \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
                                 <Brazil>, \\
                                 <Norway>, \\
                                 <Morocco>]}\\
  \parbox[t]{5.4cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA\\
            \mbox{\hspace{1em}} \& GroupA(i).won = 0]}
    &$\equiv$ & \texttt{[\keyw{mk\_}Score(<Scotland>,0,1,2,1)]}\\
  \texttt{GroupA(1,...,2)} 
    &$\equiv$ & 
    \texttt{[}\parbox[t]{4cm}{\ttfamily\selectfont
         \keyw{mk\_}Score(<Brazil>,2,0,1,6), \\
         \keyw{mk\_}Score(<Norway>,1,2,0,5)]}\\
  \parbox[t]{5.65cm}{\ttfamily\selectfont
            [GroupA(i) \\
            | i \keyw{in set inds} GroupA \\
            \mbox{\hspace{1em}} \& GroupA(i).points = 9]}
    &$\equiv$ & \texttt{[]}
  \end{tabular}
\end{description}

\subsection{写像式} \label{mapexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{写像列挙} \dsep \Ruleref{写像内包} \dsep \ldots
    }

  \Rule{写像列挙}{
    \Lit{\{}, \Ruleref{写}, \SeqPt{\Lit{,}, \Ruleref{写}}, \Lit{\}} \dsep
    \Lit{\{}, \Lit{|->}, \Lit{\}}
    } 
  
  \Rule{写}{
    \Ruleref{式}, \Lit{|->}, \Ruleref{式}
    }
  
  \Rule{写像内包}{
    \Lit{\{}, \Ruleref{写}, \Lit{|}, \Ruleref{束縛リスト},\lfeed
    \OptPt{\Lit{\char'046}, \Ruleref{式}}, \Lit{\}}
    }

\item[意味定義:] {\it 写像列挙} は次の形式をもつ:
  \begin{alltt}
    \{d1 |-> r1, d2 |-> r2, \ldots, dn |-> rn\}
  \end{alltt}
  ここですべての定義域式 {\tt di} と値域式{\tt ri}は一般の式である。
 空写像は {\tt \{|->\}}と書かれなければならない。
      
  {\it 写像内包} は次の形式をもつ:
  \begin{alltt}
    \{ed |-> er | mbd1, \ldots, mbdn \& P\}
  \end{alltt}
 ここでの構成 {\tt mbd1, \ldots, mbdn} は、式 {\tt ed} および {\tt er} から集合 (または型)をきめる変数の多重束縛である。
 {\it 写像内包} は、述語 {\tt P}を\keyw{true}と評価するすべての可能なかぎりの束縛上で、式{\tt ed} および {\tt er}を評価することにより写像を構成する。

\item[例題:] \texttt{GroupG}は次の写像と等しいと仮定する
  \begin{alltt}\label{GroupGdef}
    \{ <Romania> |-> mk_(2,1,0), <England> |-> mk_(2,0,1),
      <Colombia> |-> mk_(1,0,2), <Tunisia> |-> mk_(0,1,2) \}
  \end{alltt}
  この場合に次が成り立つ:

  \begin{tabular}{lcl}
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> \keyw{let} \keyw{mk\_}(w,d,-) = GroupG(t)\\
             \mbox{\hspace{4em}}\keyw{in} w * 3 + d \\
             | t \keyw{in set dom} GroupG\}}
    & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6,\\
                   <Colombia> |-> 3,\\
                   <Tunisia> |-> 1\}}\\
  \parbox[t]{8cm}{\ttfamily\selectfont
    \{ t |-> w * 3 + d \\
    | t \keyw{in set dom} GroupG, w,d,l:\keyw{nat} \\
    \ \& \keyw{mk\_}(w,d,l) = GroupG(t) \\
    \mbox{\hspace{.7em}}\keyw{and} w > l\}}
   & $\equiv$ & \texttt{\{}\parbox[t]{5cm}{\ttfamily\selectfont
                   <Romania> |-> 7,\\
                   <England> |-> 6\}}
  \end{tabular}
\end{description}

\subsection{組構成子式} \label{tupexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{組構成子} \dsep \ldots
    }

  \Rule{組構成子}{
    \Lop{mk\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{式リスト}, \Lit{)}
    }

\item[意味定義:]  {\it 組構成子式} は次の形式をとる:
  \begin{alltt}
    \keyw{mk\_}(e1, e2, \ldots, en)
  \end{alltt}
 ここで {\tt ei} は一般の式である。
 相等および不等演算子のみが使用できる。
     
\item[例題:] 前述の例で定義された写像 \texttt{GroupG} を用いて、次が得られる:

  \begin{tabular}{lcl}
  \texttt{\keyw{mk\_}(2,1,0) \keyw{in set rng} GroupG} & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}({\char'042}Romania{\char'042},2,1,0) \keyw{not in set rng} GroupG} 
       & $\equiv$ \keyw{true}\\
  \texttt{\keyw{mk\_}(<Romania>,2,1,0) <> \keyw{mk\_}({\char'042}Romania{\char'042},2,1,0)}
       & $\equiv$ \keyw{true}
  \end{tabular}
\end{description}

\subsection{レコード式} \label{recexpr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{レコード構成子} \dsep
    \Ruleref{レコード修正子} \dsep \ldots
    }

  \Rule{レコード構成子}{
    \Lop{mk\_}, \Ruleref{名称}, \Lit{(}, 
    \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

  \Rule{レコード修正子}{
    \Lop{mu}, \Lit{(}, \Ruleref{式}, \Lit{,}, 
    \Ruleref{レコード修正}, \lfeed \SeqPt{\Lit{,}, \Ruleref{レコード修正}}
    \Lit{)}
    }

  \Rule{レコード修正}{
    \Ruleref{識別子}, \Lit{|->}, \Ruleref{式}
    }

\item[意味定義:] {\it レコード構成子}は次の形式をもつ:
  \begin{alltt}
    \keyw{mk\_}T(e1, e2, \ldots, en)
  \end{alltt}
 ここでの式 {\tt (e1, e2, \ldots, en)} の型は、レコード型{\tt T}にある対応する入り口の型に一致する。

  {\it レコード修正} は次の形式をとる:
  \begin{alltt}
    \keyw{mu} (e, id1 |-> e1, id2 |-> e2, \ldots, idn |-> en)
  \end{alltt}
 ここで式 {\tt e} の評価として、修正されるべきレコード値を返す。
識別子 {\tt idi}は、{\tt e}のレコード型の中ですべて異なる名称をもつ入り口でなければならない。
     
\item[例題:] \texttt{sc} が値 \texttt{\keyw{mk\_}Score(<France>,3,0,0,9)} であるならば
  \begin{alltt}
    \keyw{mu}(sc, drawn |-> sc.drawn + 1, points |-> sc.points + 1)
    \MYEQUIV \keyw{mk\_}Score(<France>,3,1,0,10)
  \end{alltt}
さらなる例題として関数 \texttt{win}の説明を行う。
この関数は2つのチームと1つのスコアをもつ。
スコアの集合から与えられているチームに相当するスコア(勝ったチームには\texttt{wsc}、負けたチームには\texttt{lsc})を各々割り当て、\keyw{mu}演算子を用いてこれらを更新する。
チームの集合はここで、新しいスコアをもとのものと置き換えることで更新される。
  \begin{alltt}
  win : Team * Team * \keyw{set of} Score -> \keyw{set of} Score
  win (wt,lt,gp) ==
    \keyw{let} wsc = \keyw{iota} sc \keyw{in set} gp & sc.team = wt,
       lsc = \keyw{iota} sc \keyw{in set} gp & sc.team = lt
    \keyw{in let} new_wsc = \keyw{mu}(wsc, won |-> wsc.won + 1,
                            points |-> wsc.points + 3),
         new_lsc = \keyw{mu}(lsc, lost |-> lsc.lost + 1)
      \keyw{in} (gp \verb+\+ \{wsc,lsc\}) \keyw{union} \{new_wsc, new_lsc\}
  \Keyw{pre} \keyw{forall} sc1, sc2 \keyw{in set} gp &
          sc1 <> sc2 <=> sc1.team <> sc2.team
          \keyw{and} \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gp\}
  \end{alltt}

\end{description}

\subsection{適用式}\label{app-expr}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{適用} \dsep
    \Ruleref{項目選択} \dsep
    \Ruleref{組選択} \dsep
    \Ruleref{関数型インスタンス化} \dsep
    \ldots
    }

  \Rule{適用}{
    \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }

  \Rule{項目選択}{
    \Ruleref{式}, \Lit{.}, \Ruleref{識別子}
    }

  \Rule{組選択}{
    \Ruleref{式}, \Lit{.\#}, \Ruleref{数字}
    }

  \Rule{関数型インスタンス化}{
    \Ruleref{名称}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
    }

\item[意味定義:] 
  {\it 項目選択式} はレコードに対して用いることができるが、第~\ref{records} 節ですでに説明したのでここではそれ以上の説明は行わない。
 {\it 適用} は、ある写像において検索を行い、列に索引をし、最後に関数を呼び出すために用いられる。
第~\ref{maps} 節で、写像において検索を行うとはどういうことかはすでに述べてある。同様に第~\ref{sequences} 節では、列に索引をするとはどのように行うのかが説明されている。

 \vdmslpp{VDM-SL}{\vdmpp}においては、ここで更に1つの操作を呼び出すことが可能である。
これは標準VDM-SLにおいては許されていないことであり、この種の操作呼び出しは状態を変更してしまう可能性があるので、混合式においては慎重に使用されるべきである。
このような操作呼び出しで例外を起こすことが許されてはいないことに注意したい。

 このような操作呼出しでは評価の順が重要となる可能性がある。
したがって型検査では、式の中でユーザーが操作呼出しを有効化や無効化することを許す。

 組選択式は、組から特別な構成要素を抽出するために用いられる。
式の意味は、 もし \texttt{e} がいくつかの組 \keyw{mk\_}\texttt{(v1,...,vN)}であると評価され、 \texttt{M} が範囲 \verb+{1,...,N}+ 内の1つの整数であるならば、 \texttt{e.\#M}は \texttt{vM}となるということである。
\texttt{M} が \verb+{1,...,N}+ からはずれているならば、この式は未定義である。

 {\it 関数型インスタンス化\/} は、適当な型をもつ多相関数のインスタンス生成に用いられる。
これは次の形式をもつ:
  \begin{alltt}
    pf [ t1, ..., tn ]
  \end{alltt}
 ここで {\tt pf} は多相関数の名称であり、 {\tt t1,  \ldots, tn} は型である。
結果の関数は、関数定義で与えられた変数型の名称の代わりに、型 {\tt  t1, \ldots, tn} を用いる。

\item[例題:] 
\texttt{GroupA} は1つの列 ( \pageref{GroupAdef}ページ)、 \texttt{GroupG} は1つの写像 (\pageref{GroupGdef}ページ)、そして \texttt{selection\_sort} は1つの関数( \pageref{selectionSortdef}ページ)であったことを思い起こそう:

  \begin{tabular}{lcl}
  \texttt{GroupA(1)} & $\equiv$ & 
                           \texttt{\keyw{mk\_}Score(<Brazil>,2,0,1,6)}\\
  \texttt{GroupG(<Romania>)} & $\equiv$ &
                           \texttt{\keyw{mk\_}(2,1,0)}\\
  \texttt{GroupG(<Romania>).\#2} & $\equiv$ &
                           \texttt{1}\\
  \texttt{selection\_sort([3,2,9,1,3])} & $\equiv$ &
                           \texttt{[1,2,3,3,9]}
  \end{tabular}

 多相関数使用と関数型インスタンス化の1つの例として、第~\ref{functiondef}節から例題の関数を用いる:
  \begin{alltt}
    \keyw{let} emptyInt = empty_bag[int] \keyw{in}
      plus_bag[int](-1, emptyInt())

  \MYEQUIV

    \{ -1 |-> 1 \}
  \end{alltt}

\end{description}

#ifdef VDMPP
\subsection{new式}
\label{sec:creation}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{new式} 
    }
  \Rule{new式}{
    \Lop{new}, \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\item[意味定義:]  {\it new式}は次の形式をもつ:

  \begin{alltt}
    \keyw{new} classname(e1, e2, ..., en)
  \end{alltt}
{\it new式}を用いることで、クラス記述からオブジェクトを生成すること(これはまた{\em インスタンス生成}とも呼ばれる ) が可能である。
 {\it new式}による効果は、{\tt classname}クラスに記述された他と識別できる新しいオブジェクトが生成されることである。
{\it new式} の値は、新しいオブジェクトへの参照である。

{\it new式} がパラメーターなしで呼び出された場合は、中のすべてのインスタンス変数は ``既定'' 値 (i.e.\ それらの初期化条件で定義された値)をとった1つのオブジェクトが生成される。
パラメーターありの場合には {\it new式} は  \emph{構成子}~(第~\ref{constructors}を参照)に相当し、カスタマイズされたインスタンスを生成する(つまり\ ここでのインスタンス変数は既定値とは異なる値をとることも許される)。


\item[例題:] \texttt{Queue} という1つのクラスを仮定し、この既定インスタンスは空であるとする。
 またこのクラスは1つの構成子(これもまた \texttt{Queue}と呼ばれる) を含み、これは単一のパラメーターをとりこれが任意のスタートキューを表す値のリストであるとする。このように仮定すると\texttt{Queue}の既定インスタンスを生成することができ、実際のキューは次の式を用いて空である
\begin{alltt}
  \keyw{new} Queue()
\end{alltt}
そして次の式を用いることで\texttt{Queue}の1つのインスタンスを生成することができるが、 ここにおいて実際のキューはたとえば\texttt{e1, e2, e3}となる
\begin{alltt}
  \keyw{new} Queue([e1, e2, e3])
\end{alltt}

 \pageref{TreeDef} ページで定義されたクラス \texttt{Tree} を用いることで、 \texttt{node}s を構成する新しい \texttt{Tree} インスタンスを生成する:
\begin{alltt}
\keyw{mk\_}node(\keyw{new} Tree(), x, \keyw{new} Tree())
\end{alltt}
    
\end{description}

\subsection{self式}
\label{sec:self}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{self式} 
    }
  \Rule{self式}{
    \Lop{self}
  }

\item[意味定義:] {\it self式}は次の形式をもつ:

  \begin{alltt}
    \keyw{self}
  \end{alltt}
  self式は現在実行中のオブジェクトへの参照を返す。
継承の連鎖における名前空間を単一化するために、用いることができる。

\item[例題:] \pageref{TreeDef} ページで定義された\texttt{Tree}クラス を用いることで、B木検索アプローチを用いてデータを保存する \texttt{BST} と呼ばれるサブクラスを記述することができる。
これにより、B木検索挿入を実行する操作を指定することができる:
\begin{alltt}
    Insert : \keyw{int} ==> ()
    Insert (x) ==
      (\keyw{dcl} curr_node : Tree := \keyw{self};

       \keyw{while not} curr_node.isEmpty() \keyw{do}
         \keyw{if} curr_node.rootval() < x
         \keyw{then} curr_node := curr_node.rightBranch()
         \keyw{else} curr_node := curr_node.leftBranch();
       curr_node.addRoot(x);
       )
\end{alltt}
この操作は、挿入に先立ちそこから行き来するルートを見つけるため、self式を用いる。 
更なる例題が第 \ref{call-stmt}に示される。
\end{description}

\subsection{スレッドID式}
\label{sec:threadid}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{スレッドID式} 
    }
  \Rule{スレッドID式}{
    \Lop{threadid}
  }
  
\item[意味定義:] {\it スレッドID式}は次の形式をもつ:

  \begin{alltt}
    \keyw{threadid}
  \end{alltt}
  スレッドID式は、その式が実行されているスレッドを一意に識別する自然数を返す。
#ifdef VICEMAN
  周期的なスレッドはそれぞれの周期の状態における新しいスレッドIDを得ることに注意する。
#endif

\item[例題:] 
スレッドIDを用いることで、許可述語を使って、VDM++にJAVAスタイルのwait-notifyを実装するVDM++基本クラスを提供することが可能となる。
このwait-notify手法で利用できるオブジェクトはすべて、この基本クラスから派生するものでなければならない。
\begin{alltt}
\keyw{class} WaitNotify

  \keyw{instance variables}
    waitset : \keyw{set of nat} := \{\};

  \keyw{operations}
    \PROTECTED wait: () ==> ()
    wait() == 
      \keyw{let} p = \keyw{threadid}
      \keyw{in} (
        AddToWaitSet( p );
        Awake();
       );

    AddToWaitSet : \keyw{nat} ==> ()
    AddToWaitSet( p ) ==
      waitset := waitset \keyw{union} \{ p \};
      
    Awake: () ==> ()
    Awake() == 
      \keyw{skip};
  
    \PROTECTED notify: () ==> ()
    notify() == 
        \keyw{if} waitset <> \{\} \keyw{then}
          \keyw{let} arbitrary_process \keyw{in set} waitset
          \keyw{in}  waitset := waitset \verb+\+ \{arbitrary_process\};

    \PROTECTED notifyAll: () ==> ()
    notifyAll() ==
         waitset := \{\};

  \keyw{sync}
    \keyw{mutex}(notifyAll, AddToWaitSet, notify);
    \keyw{per} Awake => \keyw{threadid not in set} waitset;

\keyw{end} WaitNotify
\end{alltt}
この例ではスレッドID式が2箇所で用いられている:
\begin{itemize}
\item スレッドに対する\texttt{Wait} 操作中に、このオブジェクトへの関心を記録するため。
\item  \texttt{Awake}に対する 許可述語中。
関与するスレッドは、\texttt{Wait}を用いた記録を行った後に \texttt{Awake}を呼ぶべきである。
そしてこのスレッドは、\texttt{notify}に対するもうひとつのスレッド呼出しの後、待ち集合からスレッドIDが取り除かれるまでブロックされる。
\end{itemize}

#ifdef VICEMAN
周期的なスレッドを持っているときは、wait-notify構造の使用について注意する必要がある。
(なぜなら、それぞれの新しい周期にたいしてスレッドIDが変化するからである)
#endif

\end{description}
#endif VDMPP

\subsection{ラムダ式}\label{lambda}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep \Ruleref{ラムダ式} \dsep \ldots
    }

  \Rule{ラムダ式}{
    \Lop{lambda}, \Ruleref{型束縛リスト}, \Lit{\&}, \Ruleref{式}
    }

\Rule{型束縛リスト}{
  \Ruleref{型束縛}, \SeqPt{\Lit{,}, \Ruleref{型束縛}}
  }

  \Rule{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }
        
\item[意味定義:] {\it ラムダ式} は次の形式をもつ:
  \begin{alltt}
    \keyw{lambda} pat1 : T1, \ldots, patn : Tn \& e
  \end{alltt}
 ここで {\tt pati} はパターン、{\tt Ti} は型式、そして{\tt e} は本体式である。 
パターン{\tt pati} におけるパターン識別子のスコープが本体式である。
ラムダ式は多相ではありえないが、それとは別に、意味定義においては第~\ref{functiondef}節に説明される陽関数定義に相当する。
ラムダ式によって定義される関数は、入れ子になった本体中で新しいラムダ式を用いることでカリー化することが可能となる。
ラムダ式が1つの識別子と結びついたとき、再帰関数を定義することもまた可能である。
\item[例題:] 以下のようにラムダ式を用いて、増加関数を定義することができる:
  \begin{alltt}
    Inc = \keyw{lambda} n : \keyw{nat} \& n + 1
  \end{alltt}
さらに加算関数はカリー化できる:
  \begin{alltt}
    Add = \keyw{lambda} a : \keyw{nat} \& \keyw{lambda} b : \keyw{nat} \& a + b
  \end{alltt}
もしこれが唯一の引数に適用された場合には、新しいラムダ式が返される:
  \begin{alltt}
    Add(5) \(\equiv\) \keyw{lambda} b : \keyw{nat} \& 5 + b
  \end{alltt}
 ラムダ式は、高階関数との関連で用いられる場合に役立つ。
 たとえば \pageref{setfilterdef}ページに定義される関数 \texttt{set\_filter}を用いてみると:
  \begin{alltt}
  set_filter[nat](lambda n:nat & n mod 2 = 0)(\{1,...,10\})
  \MYEQUIV \{2,4,6,8,10\}
  \end{alltt}
\end{description}


\subsection{narrow式}
\label{narrow}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{ 式} 
    }
  \Rule{ narrow式}{
    \Lit{\keyw{narrow}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\item[意味定義:] {\it narrow式}の値は、与えた式の結果の型を、指定された型に変換したものである。

静的型チェックおよび動的型チェックにより、無関係の型間の変換は型エラーとなる。

\item[例題1:]
この例では、Test() および Test'() の実行結果には差がないが、
Test() は「def」型チェックエラーとなる。

\begin{alltt}
class A

types
public C1 :: a : nat;
public C2 :: b : nat;
public S = C1 | C2;

operations
public
Test: () ==> nat
Test() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = s
   in
     return c.a;

public
Test': () ==> nat
Test'() ==
 let s : S = mk_C1(1)
 in
   let c : C1 = narrow_(s, C1)
   in
     return c.a;
end A
\end{alltt}

#ifdef VDMPP
\item[例題2:]
この例では、Test() および Test'() の実行結果には差がないが、
Test() は型チェックエラーとなる。

\begin{alltt}
class S
end S

class C1 is subclass of S

instance variables
public a : nat := 1;

end C1

class C2 is subclass of S

instance variables
public b : nat := 2;

end C2

class A

operations
public
Test: () ==>  seq of nat
Test() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> e.a,
                (isofclass(C2, e)) -> e.b
               end | i in set inds list ];

public
Test': () ==>  seq of nat
Test'() ==
 let list : seq of S = [ new C1(), new C2() ]
 in
   return [ let e = list(i)
            in cases true:
                (isofclass(C1, e)) -> narrow_(e, C1).a,
                (isofclass(C2, e)) -> narrow_(e, C2).b
               end | i in set inds list ];
end A
\end{alltt}
#endif VDMPP

\end{description}


\subsection{is式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{一般is式} \dsep
    \ldots
    }

  \Rule{一般is式}{
    \Ruleref{is式} \dsep
    \Ruleref{型判定}
    }


  \Rule{is式}{
    \Lop{is\_}, \Ruleref{名称}, \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
    \Ruleref{is基本型}, \Lit{(}, \Ruleref{式}, \Lit{)}
    }

  \Rule{is基本型}{
    \Lop{is\_}, 
    \Brack{%
      \Lop{bool} \dsepl
      \Lop{nat} \dsepl 
      \Lop{nat1} \dsepl 
      \Lop{int} \dsep 
      \Lop{rat} \dsepl 
      \Lop{real} \dsep
      \Lop{char} \dsepl
      \Lop{token}
      }
    }

  \Rule{型判定}{
    \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\item[意味定義:] 
 {\it is式} は基本値かまたはレコード値(なにかのレコード型に属するタグ付けされた値)とともに用いられる。 
このis式は、与えられた値が指定された基本型に属する場合、または値が指定されたタグを持つ場合に、trueとなる。他の場合はfalseとなる。

 型判定は、型が静的には決定されえない式に対して用いることができることから、より一般的な形式である。
式 \texttt{\keyw{is}\_(e,t)} は、 \texttt{e} が\texttt{t}型 でありその場合にのみ、trueとなる。
     
\item[例題:]  \pageref{scoredef}ページに定義されたレコード型 \texttt{Score} を用いて次を得る:     
     
  \begin{tabular}{lcl}
    \texttt{\keyw{is\_}Score(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_bool}(\keyw{mk\_}Score(<France>,3,0,0,9))}
      & $\equiv$ & \keyw{false}\\
    \texttt{\keyw{is\_real}(0)} & $\equiv$ & \keyw{true}\\
    \texttt{\keyw{is\_nat1}(0)} & $\equiv$ & \keyw{false}
  \end{tabular}

 型判定の例は以下のとおり:
  \begin{alltt}
    Domain : \keyw{map nat to nat} | \keyw{seq of (nat*nat)} -> \keyw{set of nat}
    Domain(m) ==
      \keyw{if is}\_(m, \keyw{map nat to nat})
      \keyw{then dom} m
      \keyw{else} \{d | \keyw{mk}\_(d,-) \keyw{in set elems} m\}
  \end{alltt}
   加えて \pageref{exprIsExs}にも例題が載せられている。
\end{description}

#ifdef VDMPP

\subsection{基底クラス構成要素}\index{base class membership expression}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
    \Ruleref{isofbaseclass式} \dsep
    \ldots
    }

  \Rule{isofbaseclass式}{
    \Lop{isofbaseclass},
    \Lit{(}, \Ruleref{識別子}, \Ruleref{式}, \Lit{)}}
  
\item[意味定義:] {\vppsmall isofbaseclass} 関数がオブジェクト参照である{\vppsmall 式}やクラス名である{\vppsmall 識別子}に適用されるときは、 {\vppsmall 式}によって参照されるオブジェクトの継承連鎖において{\vppsmall 識別子} が ルートスーパークラスで、かつその場合にのみブール値$\True$ をとりその他の場合は $\False$ となる。

  
\item[例題:] \label{treeExDef}
 \texttt{BinarySearchTree} が \texttt{Tree}のサブクラスであると仮定すると、\texttt{Tree}は他のクラスのサブクラスにはならないし、 \texttt{Queue} が \texttt{Tree}や \texttt{BinarySearchTree}に継承によって関係付けられることもない。
\texttt{t} を \texttt{Tree}のインスタンス、 \texttt{b} を \texttt{BinarySearchTree}のインスタンス、 \texttt{q} を \texttt{Queue}のインスタンス、とすると次の通り:
  
  \begin{tabular}{lcl}
    \keyw{isofbaseclass}\texttt{(Tree, t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(BinarySearchTree, b)} & $\equiv$ & \keyw{false}\\
    \keyw{isofbaseclass}\texttt{(Queue, q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofbaseclass}\texttt{(Tree, q)} & $\equiv$ & \keyw{false}
  \end{tabular}
\end{description}

\subsection{クラス構成要素}\index{class membership expression}
\begin{description}
\item[構文] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{isofclass式} \dsep
    \ldots
    }
  \Rule{isofclass式}{
    \Lop{isofclass}, \Lit{(}, \Ruleref{識別子}, \Ruleref{式}, \Lit{)}
  }

\item[意味定義:] あるオブジェクト参照 {\vppsmall 式}とクラス名 {\vppsmall 識別子}に適用された関数 {\vppsmall isofclass}は、{\vppsmall 式}が {\vppsmall 識別子} クラスのオブジェクトまたは {\vppsmall 識別子}クラスのいくつかのサブクラスのうちの1つのオブジェクトを参照しかつその場合にのみブール値 $\True$ をとり、それ以外の場合には $\False$ となる。

\item[例題:] 前の例と同様に、\texttt{Tree},\texttt{BinarySearchTree}, \texttt{Queue}のクラスと、識別子 \texttt{t},\texttt{b}, \texttt{q}を仮定する:  
  
  \begin{tabular}{lcl}
    \keyw{isofclass}\texttt{(Tree,t)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,b)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(Tree,q)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(Queue,q)} & $\equiv$ & \keyw{true}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,t)} & $\equiv$ & \keyw{false}\\
    \keyw{isofclass}\texttt{(BinarySearchTree,b)} & $\equiv$ & \keyw{true}
  \end{tabular}

\end{description}

\subsection{同基底クラス構成要素}%
\index{same base class membership expression}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
     \Ruleref{samebaseclass式} \dsep
    \ldots
    }
  \Rule{samebaseclass式}{\Lop{samebaseclass}, \lfeed
  \Lit{(},
        \Ruleref{式}, \Ruleref{式}, \Lit{)}
    }
  
\item[意味定義:] オブジェクト参照 \texttt{ex\-pression1}と{\vppsmall expression2}に適用された関数 {\vppsmall samebaseclass} は、 \texttt{expres\-sion1}と{\vppsmall expression2} によって記述されたオブジェクトが同じルートスーパークラスから派生し得たクラスのインスタンスでありかつその場合にのみにブール値 $\True$ をとり、それ以外の場合は $\False$となる。
  
\item[例題:] 前に述べた例題と同様に、クラス\texttt{Tree}、\texttt{BinarySearchTree}, \texttt{Queue}, および識別子 \texttt{t},\texttt{b}, \texttt{q} を仮定し、\texttt{AVLTree} を \texttt{Tree}のもうひとつのサブクラス、
\texttt{BalancedBST} を \texttt{BinarySearchTree}のサブクラス、 \texttt{a}
を \texttt{AVLTree}のインスタンス、そして \texttt{bb} を\texttt{BalancedBST}のインスタンスとする:

  \begin{tabular}{lcl}
  \keyw{samebaseclass}\texttt{(a,b)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(a,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(b,bb)} & $\equiv$ & \keyw{true}\\
  \keyw{samebaseclass}\texttt{(t,bb)} & $\equiv$ & \keyw{false}\\
  \keyw{samebaseclass}\texttt{(q,a)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\subsection{同クラス構成要素}%
\index{same class membership expression}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep
     \Ruleref{sameclass式} \dsep
    \ldots
    }

  \Rule{sameclass式}{\Lop{sameclass}, \lfeed
  \Lit{(}, \Ruleref{式},
        \Ruleref{式}, \Lit{)}
   }
   
\item[意味定義:] オブジェクト参照 \texttt{expressi\-on1} と {\vppsmall expression2} に適用される関数 {\vppsmall sameclass} は、\texttt{expression1} と {\vppsmall expression2} により記述されたオブジェクトが同じクラスのインスタンスとなりかつその場合にのみブール値 $\True$ をとり、それ以外の場合は $\False$ となる。

\item[例題:] 
第 \ref{treeExDef}節においてのクラス \texttt{Tree}、\texttt{BinarySearchTree}、 \texttt{Queue}、そして識別子 \texttt{t}、\texttt{b}、 \texttt{q} を仮定し、さらに\texttt{b'} が \texttt{BinarySearchTree} のもうひとつのインスタンスであると仮定した場合、次が得られる:

  \begin{tabular}{lcl}
  \keyw{sameclass}\texttt{(b,t)} & $\equiv$ & \keyw{false}\\
  \keyw{sameclass}\texttt{(b,b')} & $\equiv$ & \keyw{true}\\
  \keyw{sameclass}\texttt{(q,t)} & $\equiv$ & \keyw{false}\\
  \end{tabular}
\end{description}

\subsection{履歴式}\index{history expressions}
\label{sec:historyexpr}

\begin{description}
\item[構文:] 
  \Rule{式}{
    \ldots \dsep
    \Ruleref{act式} \dsep
    \Ruleref{fin式} \dsep
    \Ruleref{active式} \dsep
    \Ruleref{req式} \dsep
    \Ruleref{waiting式} \dsep 
    \ldots
  }
  \Rule{act式}{
    \Lit{\#act}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#act}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{fin式}{
    \Lit{\#fin}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#fin}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{active式}{
    \Lit{\#active}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#active}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{req式}{
    \Lit{\#req}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#req}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Rule{waiting式}{
    \Lit{\#waiting}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#waiting}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }

\item[意味定義:] 履歴式は許可述語においてのみ用いられる (第 \ref{sec:permissionpred}節参照)。
履歴式は以下の式を1つ以上含むことが許される:
  
\begin{itemize}
\item {\tt \#act (}{\em 操作名}{\tt )} {\em 操作名} 操作が起動された回数。
\item {\tt \#fin(}{\em 操作名}{\tt )} {\em 操作名}操作が完了した回数。
\item {\tt \#active(}{\em 操作名}{\tt )} 現在起動中である{\em 操作名}操作の数。 このとき:
{\tt \#active(}{\em
    操作名}{\tt )} $=$ {\tt \#act(}{\em 操作名}{\tt )}
  $-$ {\tt \#fin(}{\em 操作名}{\tt )}
\item {\tt \#req(}{\em 操作名}{\tt )}  {\em 操作名} 操作に対して発生した要求の数。
\item {\tt \#waiting(}{\em 操作名}{\tt )} {\em 操作名}操作に対する未解決の要求の数。 
このとき: {\tt
    \#waiting(}{\em 操作名}{\tt )} $=$ {\tt \#req(}{\em 操作名}{\tt )} $-$ {\tt \#act(}{\em 操作名}{\tt )}
\end{itemize}
これらすべての演算子に対して、名前リスト版である\texttt{\#}\textit{history op(op1,$\ldots$,opN)} は \texttt{\#}\textit{history op(op1)} \texttt{+} $\mathtt{\cdots}$ \texttt{+\#}\textit{history op(opN)}に対する簡易な省略形である。

\item[例題:] 
3つの操作 \texttt{A}, \texttt{B} そして \texttt{C} が実行されるある特別なスレッドの実行における1時点を想定しよう。
 要求、起動、完了、の列がこのスレッド中で起こる。
 このことは図\ref{historyfig}において視覚的にみてとれる。

\insertfig{history}{14cm}{履歴式}{\label{historyfig}}

ここに記号 \textit{rA} を操作 \texttt{A}の実行要求を示すものとして用い、 \textit{aA} は \texttt{A}の起動を示すもの、 \textit{fA} は操作 \texttt{A}の実行の完了を示すものとし、そして同様のことを操作 \texttt{B} と\texttt{C}に対しても用いる。 
各々の履歴式は、 時間間隔[\textbf{S},\textbf{T}]に対するものとしての以下の値をとる:
\end{description}

\begin{center}\small
\begin{tabular}{llll}
\texttt{\#act(A) = 1} & \texttt{\#act(B) = 1} & \texttt{\#act(C) = 1}
& \texttt{\#act(A,B,C) = 3}\\
\texttt{\#fin(A) = 1} & \texttt{\#fin(B) = 1} & \texttt{\#fin(C) = 0}
& \texttt{\#fin(A,B,C) = 2}\\
\texttt{\#active(A) = 0} & \texttt{\#active(B) = 0} & 
\texttt{\#active(C) = 1} & \texttt{\#active(A,B,C) = 1}\\
\texttt{\#req(A) = 2} & \texttt{\#req(B) = 1} & \texttt{\#req(C) = 3}
& \texttt{\#req(A,B,C) = 6}\\
\texttt{\#waiting(A) = 1} & \texttt{\#waiting(B) = 0} & 
\texttt{\#waiting(C) = 2} & \texttt{\#waiting(A,B,C) = 3}\\
\end{tabular}
\end{center}


#endif VDMPP

#ifdef VICEMAN
\subsection{time式}\index{time expression}\label{sec:time}

\begin{description}
\item[構文:] 
 \Rule{time式}{\Lop{time}}

\item[意味定義:] これは単純に、与えられたCPU上の現在の時間を問い合わせるものである。時間は自然数で提供されます。
% uchida add start
\item[例:] たとえば、確実にある操作が実行されたことをログ（記録）に取りたい場合、 \texttt{logEnvToSys}のようにして操作を作成することができる。
\begin{alltt}

  \keyw{public} logEnvToSys: \keyw{nat} ==> ()

  logEnvToSys (pev) == e2s := e2s \keyw{munion} \{pev |-> \keyw{time}\};

\end{alltt}
% uchida add end
\end{description}

#endif VICEMAN

\subsection{リテラルと名称}

\begin{description}
\item[構文:]
  \Rule{式}{    \ldots \dsep
    \Ruleref{名称} \dsep
    \Ruleref{旧名称} \dsep
    \Ruleref{記号リテラル} \dsep
    \ldots
    }

  \Rule{名称}{
    \Ruleref{識別子}, \OptPt{\Lit{`}, \Ruleref{識別子}}
    }

  \Rule{名称リスト}{
    \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
    }

  \Rule{旧名称}{
    \Ruleref{識別子}, \Lit{\char'176}
    }

\item[意味定義:] {\it 名称\/} と {\it 旧名称\/} は、関数、操作、値、状態構成要素の定義にアクセスするためによく用いられる。
 {\it 名称\/} は次の形式をもつ:
  \begin{alltt}
    id1`id2
  \end{alltt}
ここで {\tt id1} と {\tt id2} は単なる識別子である。
名称が唯一の識別子で構成される場合は、その識別子はスコープ内で定義されている。つまり、ローカルにパターン識別子かパターン変数として定義されているか、
あるいはグローバルに現モジュール内で関数、操作、値、またはグローバル変数として定義されているか、いずれかである。
そうでない場合は、識別子 {\tt id1}が
コンストラクタが定義されている場所の
#ifdef VDMSL
モジュール名
#endif VDMSL
#ifdef VDMPP
クラス名
#endif VDMPP
を示している (
#ifdef VDMSL
  第~\ref{modules}節
#endif VDMSL
#ifdef VDMPP
第~\ref{sec:classdep}節
#endif VDMPP
および付録 \ref{ap:lexis}も参照)。
 {\it 旧名称\/} は、操作定義の事後条件(第~\ref{op-def}節参照)および仕様文の事後条件(第~\ref{se:specification}節参照)において、グローバル変数の旧値にアクセスするためによく用いられる。
これは次の形式をもつ:

  \begin{alltt} 
    id~ 
  \end{alltt} 
 ここで {\tt id} は状態構成要素である。

  {\it 記号リテラル\/} はいくつかの基本型における定数値である。

\item[例題:] {\it 名称} と {\it 記号リテラル\/} はこの本の中ですべての例題を通して用いられている (付録~\ref{Symbols}参照)。


#ifdef VDMSL
  旧名称の使用の例は、以下のように定義された状態を考える:
  \begin{alltt}
    \keyw{state} sigma \keyw{of}
      numbers : \keyw{seq of nat}
      index   : \keyw{nat}
    \Keyw{inv}  \keyw{mk\_}sigma(numbers, index) == index \keyw{not in set elems} numbers
    \Keyw{init} s == s = \keyw{mk\_}sigma([], 1)
    \keyw{end}
  \end{alltt}
#endif VDMSL
#ifdef VDMPP
 {\it 旧名称}の使用例として、以下のように定義されたインスタンス変数を考えてみよう:
  \begin{alltt}
    \keyw{instance variables}
      numbers: \keyw{seq of nat} := [];
      index  : \keyw{nat} := 1;
    \Keyw{inv} index \keyw{not in set elems} numbers;
  \end{alltt}
#endif VDMPP

 変数 {\tt index}を増加させる陰操作を定義することができる:
  \begin{alltt}
    IncIndex()
    \keyw{ext wr} index : \keyw{nat}
    \keyw{post} index = index~ + 1
  \end{alltt}
 操作 {\tt IncIndex} は、\keyw{ext wr} 節に示されるように、変数 {\tt index}を操作する。
事後条件の中で、 {\tt index} の新しい値は {\tt index}の旧値に  \texttt{1}を足したものと等しい。
(これ以上は第~\ref{op-def}節の操作についてを参照)。

#ifdef VDMSL
module 
#endif VDMSL
#ifdef VDMPP
クラス
#endif VDMPP
名の簡単な例としては、以下のように、 \texttt{build\_rel} という関数が \texttt{CGRel} という
#ifdef VDMSL
module 
#endif VDMSL
#ifdef VDMPP
クラス
#endif VDMPP
において定義された(そしてエクスポートされた)と仮定する:
\begin{alltt}
  \keyw{types}

    Cg = <A> | <B> | <C> | <D> | <E> | <F> | 
         <G> | <H> | <J> | <K> | <L> | <S>;
    CompatRel = \keyw{map} Cg \keyw{to set of} Cg

  \keyw{functions}

    build_rel : \keyw{set of} (Cg * Cg) -> CompatRel
    build_rel (s) == \{|->\}
\end{alltt}
別の
#ifdef VDMSL
module 
#endif VDMSL
#ifdef VDMPP
クラス
#endif VDMPP
においては、
#ifdef VDMSL
最初にモジュール\texttt{CGRel}lを輸入し、 
#endif VDMSL
それから、以下の呼出しを行なうことでこの関数をアクセスすることができる
  \begin{alltt}
  CGRel`build_rel({mk_(<A>, <B>)})
  \end{alltt}


\end{description}

\subsection{未定義式}

\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{未定義式}
    }

  \Rule{未定義式}{
    \Lop{undefined}
    }
  
\item[意味定義:] {\it 未定義式} は、ある式の結果が定義されないことを明白に述べるために用いられる。
 たとえばこれは、if-then-else式でelse分岐を評価した結果をどうすべきかが決定されていない場合などに、用いることができるであろう。
{\it 未定義式} が評価される場合、インタプリタは実行を終了し未定義式が評価されたと記録する。

実用において、未定義式の使用は事前条件のとは異なる:
事前条件の使用とは、関数が呼ばれたときに事前条件が満たされることを保障するのは呼び出す側の責任であることを意味する;
未定義式の使用であれば、エラー処理を行うのは呼び出された関数の責任となる。

\item[例題:] \texttt{Score} 値のbuildの前に、型の不変条件が保たれるかをチェックすることができる:

  \begin{alltt}
  build_score : Team * \keyw{nat} * \keyw{nat} * \keyw{nat} * \keyw{nat} -> Score
  build_score (t,w,d,l,p) ==
    \keyw{if} 3 * w + d = p
    \keyw{then} \keyw{mk\_}Score(t,w,d,l,p)
    \keyw{else undefined}
  \end{alltt}
\end{description}

\subsection{事前条件式}
\begin{description}
\item[構文:]
  \Rule{式}{
    \ldots \dsep 
    \Ruleref{事前条件式}
    }
  \Rule{事前条件式}{
    \Lop{pre\_}, \Lit{(}, \Ruleref{式}, \lfeed
                          \OptPt{\SeqPt{\Lit{,}, \Ruleref{式}}},
                 \Lit{)}
    }
  
\item[意味定義:] 
 \texttt{e} が関数型であると仮定すると、 式 \keyw{pre\_}\texttt{(e,e1,...,en)} は、\texttt{e}の事前条件が引数 \texttt{e1,...,em}に対してtrueでありかつその場合にのみtrueとなるが、ここで\texttt{m}は\texttt{e}の事前条件のarity(引数の数)である。
 \texttt{e} が関数でなかったり、 \texttt{m} $>$ \texttt{n} であったりした場合は、結果は \texttt{true}となる。
 \texttt{e} が事前条件をもたない場合は、式はtrueと等しい。
\item[例題:] 
  以下のように定義された関数 \texttt{f} と \texttt{g} を考えよう
  \begin{alltt}
  f : \keyw{nat} * \keyw{nat} -> \keyw{nat}
  f(m,n) == m \keyw{div} n
  \keyw{pre} n <> 0;

  g (n: \keyw{nat}) sqrt:\keyw{nat}
  \keyw{pre} n >= 0
  \keyw{post} sqrt * sqrt <= n \keyw{and}
       (sqrt+1) * (sqrt+1) > n
  \end{alltt}
この場合、次の式は
  \begin{alltt}
  \keyw{pre}\_(\keyw{let} h \keyw{in set} \{f,g, \keyw{lambda mk}\_(x,y):\keyw{nat} * \keyw{nat} & x \keyw{div} y\} 
       \keyw{in} h, 1,0,-1)
  \end{alltt}  
以下と等しくなる
  \begin{itemize}
  \item \texttt{h}が \texttt{f} に束縛されている場合は \texttt{\keyw{pre}\_f(1,0)}と等しいと考えられるため、falseとなる;
  \item \texttt{h}が \texttt{g}に束縛されている場合は \texttt{\keyw{pre}\_g(1)}と等しいと考えられるため、trueとなる;
  \item  \texttt{h} が \texttt{\keyw{lambda} \keyw{mk}\_(x,y):\keyw{nat} * \keyw{nat} \& x \keyw{div} y} に束縛されている場合はこの関数に対して定義された事前条件がないため、 trueとなる。
  \end{itemize}
 \texttt{h} がいかに束縛されていたとしても、最後の引数  (\texttt{-1}) は決して使われないことに注意しよう。
\end{description}


\section{パターン}\label{patterns}

\begin{description}
\item[構文:]
  \Rule{パターン束縛}{
    \Ruleref{パターン} \dsepl
    \Ruleref{束縛}
    }

  \Rule{パターン}{
    \Ruleref{パターン識別子} \dsep
    \Ruleref{一致値} \dsep
    \Ruleref{集合列挙パターン} \dsep
    \Ruleref{集合合併パターン} \dsep
    \Ruleref{列列挙パターン} \dsep
    \Ruleref{列連結パターン} \dsep
    \Ruleref{写像列挙パターン} \dsep
    \Ruleref{写像併合パターン} \dsep
    \Ruleref{組パターン} \dsep
    \Ruleref{レコードパターン}
    }

  \Rule{パターン識別子}{
    \Ruleref{識別子} \dsepl \Lit{-}
    }

  \Rule{一致値}{
    \Ruleref{記号リテラル} \dsep \Lit{(}, \Ruleref{式}, \Lit{)}
    }

  \Rule{集合列挙パターン}{
    \Lit{\{}, [\Ruleref{パターンリスト}], \Lit{\}}
    }

  \Rule{集合合併パターン}{
    \Ruleref{パターン}, \Lit{\keyw{union}}, \Ruleref{パターン}
    }

  \Rule{列列挙パターン}{
    \Lit{[}, [\Ruleref{パターンリスト}], \Lit{]}
    }

  \Rule{列連結パターン}{
    \Ruleref{パターン}, \Lit{\char'136}, \Ruleref{パターン}
    }

  \Rule{写像列挙パターン}{
    \Lit{\{}, [\Ruleref{写パターンリスト}], \Lit{\}}
    }
    
  \Rule{写パターンリスト}{
    \Ruleref{写パターン}, \SeqPt{\Lit{,}, \Ruleref{写パターン}}
    }
    
  \Rule{写パターン}{
    \Ruleref{パターン}, \Lit{|->}, \Ruleref{パターン}
  }

   \Rule{写像併合パターン}{
    \Ruleref{パターン}, \Lit{\keyw{munion}}, \Ruleref{パターン}
    }

  \Rule{組パターン}{
    \Lop{mk\_(}, \Ruleref{パターン}, \Lit{,}, \Ruleref{パターンリスト}, \Lit{)}
    }
 
  \Rule{レコードパターン}{
    \Lop{mk\_}, \Ruleref{名称}, \Lit{(}, [\Ruleref{パターンリスト}], \Lit{)}
    }
   
  \Rule{パターンリスト}{
    \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
    }

\item[意味定義:] パターンは常に文脈中で用いられ、1つの特定の型の1つの値に一致する。
マッチングでは、あるパターンがある値と一致する可能性があるかの照合を行い、そしてパターン中のパターン識別子に対応する値を結びつけ、識別子がそのスコープ内で、これらの値を意味するようにする。
パターンを用いることのできるいくつかの場合においては、束縛も同様に用いることができる (次節を参照)。
もし束縛が用いられていたら、それは単純に言って、与えられたパターンに一致する可能性のある値を束縛することに更なる情報(型式または集合式)が用いられていることを意味する。

 マッチングは次のように定義される
  \begin{enumerate}
  \item  {\it パターン識別子} はどんな型にも合致するしどんな値にも一致し得る。
それが識別子であるならば、その識別子はその値に束縛される;
それがdon't-care記号 \Lit{-}であるならば、どのような束縛も起こらない。

  \item {\it 一致値} はそれ自身の値に対してのみ一致し得る; どのような束縛もなされない。
一致値がたとえば {\tt 7} とか {\tt <RED>}とかのようにリテラルでない場合は、パターン識別子に対してこれを区別するために、括弧にかこまれた式でなければならない。

  \item  {\it 集合列挙パターン} は集合値のみと適合する。
1つ1つのパターンは1つの集合の異なる要素と一致させられ; すべての要素が一致しなければならない。

  \item   {\it 集合合併パターン} は集合値のみと適合する。
1つの集合を2つに分けた部分集合に対して、2つのパターンが一致する。
2つの部分集合は、互いに素で、かつ合併すると元の集合になるように選ばれる。
元の集合の要素数が2以上の時、2つの部分集合は空で無いように分割される。
元の集合の要素数が1の時は、1つの部分集合は、空となる。

  \item  {\it 列列挙パターン} は唯一列値にのみ合致する。
 各々のパターンは列値中の対応する要素に対して一致する; 列長とパターン数は等しくなければならない。

  \item  {\it 列連結パターン} は唯一列値とのみ合致する。
 2つのパターンは、共に連結するともとの列値をつくることができる2つの部分列に、一致する。 
2つの部分列は常に空でないように選ばれる。

  \item  {\it 写像列挙パターン} は写像値とのみ合致する。

　 \item  {\it 写パターンリスト} は1つの写像の、それぞれ異なる写（maplet）と一致する; すべての写が一致しなければならない。

 \item  {\it 写像併合パターン} は写像値とのみ合致する。
 1つの写像を2つに分けた部分写像に対して、2つのパターンが一致する。
2つの部分写像は、互いに素となり、かつ併合すると元の写像と一致するように選ばれる。
元の写像の要素数が2以上の時、2つの部分写像は空で無いように分割される。
元の写像の要素数が1の時は、1つの部分写像は、空となる。

  \item  {\it 組パターン} は同じ要素数をもつ組にのみ合致する。
 パターンの各々は、組値の中で対応する要素に対して一致させられる。

  \item  {\it レコードパターン} は同じタグをもつレコード値にのみ適合する。
  パターンの各々は、レコード値の項目に対して一致させられる。
 レコードのすべての項目が一致させられなくてはならない。
  \end{enumerate}

\item[例題:] 以下にパターンの使用例を説明する。

\paragraph{パターン識別子の例}
最も単純なパターンはパターン識別子である。
この例は次に述べるlet式で与えられる:
\begin{alltt}
  \keyw{let} top = GroupA(1)
  \keyw{in} top.sc
\end{alltt}
ここで識別子 \texttt{top} は列\texttt{GroupA}の先頭と結びつき、したがって識別子はlet式の本体で用いられることが許される。

\paragraph{一致値の例}
以下の例では一致値を用いる:
\begin{alltt}
  \keyw{let} a = <France>
  \keyw{in} \keyw{cases} GroupA(1).team:
             <Brazil> -> "Brazil are winners",
             (a)      -> "France are winners",
             \keyw{others}    -> "Neither France nor Brazil are winners"
     \keyw{end;}
\end{alltt}
一致値は唯一それ自身の値と一致させることが可能なので、ここで \texttt{GroupA} の先頭のチームが \texttt{<Brazil>} であるならば最初の節で一致する; もし \texttt{GroupA} の先頭のチームが\texttt{<France>} であるなら2番目の節で一致する。
これら以外は\keyw{others}が一致する。
ここで \texttt{a}を囲んだ括弧の使用が、\texttt{a} を一致値とみなすよう強要していることに留意しよう。

\paragraph{集合列挙パターンの例}
集合列挙は、パターンを1つの集合の要素と一致させる。
たとえば次において
\begin{alltt}
  \keyw{let} \{sc1, sc2, sc3, sc4\} = \keyw{elems} GroupA
  \keyw{in} sc1.points + sc2.points + sc3.points + sc4.points;
\end{alltt}
識別子 \texttt{sc1}, \texttt{sc2}, \texttt{sc3} および\texttt{sc4} は \texttt{GroupA}の4つの要素と結び付けられる。
束縛の選択はゆるいものであることに注目しよう - たとえば\texttt{sc1} は\texttt{\keyw{elems}GroupA} の[どのような] 要素と結び付いてもよい。
この場合、もし \texttt{\keyw{elems} GroupA} がちょうど4つの要素を含んでいるわけではなかったら、この式は良形とはいえない。

\paragraph{集合合併パターンの例}
集合合併パターンは、集合を再帰関数呼出しに分解させるために用いることができる。
この1つの例は集合を (任意の順での)列に変換する関数 \texttt{set2seq}である:
\begin{alltt}
  set2seq[@elem] : \keyw{set of} @elem -> \keyw{seq of} @elem
  set2seq(s) ==
    \keyw{cases} s:
      \{\} -> [],
      \{x\} -> [x],
      s1 \keyw{union} s2 -> (set2seq[@elem](s1))^(set2seq[@elem](s2))
    \keyw{end}
\end{alltt}
caseの3番目の選択肢で、集合合併パターンを使用しているのがわかる。
これは \texttt{s1} と \texttt{s2} を\texttt{s}の任意の部分集合に束縛し、それによって \texttt{s}を区分けする。
 Toolboxインタープリタは常に互いに素の区分けを実現する。

\paragraph{列列挙パターンの例}
列列挙パターンは、1つの列から指定された要素を抽出するために用いることができる。この1つの例として関数 \texttt{promoted}があり、これはスコアの列の最初から2つの要素を抽出し、チームの中の対応する2つを返す:
\begin{alltt}
  promoted : \keyw{seq of} Score -> Team * Team
  promoted([sc1,sc2]^-) == \keyw{mk\_}(sc1.team,sc2.team);
\end{alltt}
ここで \texttt{sc1} は引数列の先頭と結びつき、\texttt{sc2} は列の2番目の要素と結びつく。
もし\texttt{promoted} が要素数が2つない列で呼び出されるなら、ランタイムエラーが起きる。
リストの残りの要素には興味を持たないので、それら残りに対して don't careパターンを用いていることに注目したい。

\paragraph{列連結パターンの例}
前に述べた例でも、列連結パターンの使用を行っている。
もうひとつの例として関数\texttt{quicksort}があるが、これは標準のクイックソートアルゴリズムを実装している:
\begin{alltt}
  quicksort : \keyw{seq of nat} -> \keyw{seq of nat}
  quicksort (l) ==
    \keyw{cases} l:
      [] -> [],
      [x] -> [x],
      [x,y] -> \keyw{if} x < y \keyw{then} [x,y] \keyw{else} [y,x],
      -^[x]^- -> quicksort ([y | y \keyw{in set elems} l & y < x]) ^ 
                 [x] ^ quicksort ([y | y \keyw{in set elems} l & y > x])
    \keyw{end}
\end{alltt}
ここで、 case式の最後のcases式選択肢で、列連結パターンは \texttt{l}をある任意のピボット(かなめ)要素と2つの部分列に分解するのに用いられている。
ピボットはリストをピボットより小さい値と大きい値に区分けるために用いられ、2つの区分けされた部分は再帰的にソートされる。

\paragraph{写像列挙パターンの例}
写像列挙パターンは、パターンを1つの写像と個々の写（maplet）と一致させる。
例えば、次の例では

\begin{alltt}
 \keyw{let} \{1 |-> a, a |-> b, b |-> c\} = \{1 |-> 4, 2 |-> 3, 4 |-> 2\} 
 \keyw{in} \keyw{mk_}(a, b, c)
\end{alltt}
aは、対応する定義域の値が1なので、4と一致する。
aが４なので、定義域の値が4である写の値域の値すなわちbの値は２になる。
同様に、bが２なので、cは3になる。

\paragraph{写像併合パターンの例}
写像併合パターンは、写像の写（maplet）を1つずつ処理する再帰関数に用いることができる。
ここでは、写像を（任意の順番で）写の列に変換する関数map2seqを示す。

\begin{alltt}
public map2seq[@T1, @T2] : \keyw{map} @T1 \keyw{to} @T2 -> \keyw{seq of} (\keyw{map} @T1 \keyw{to} @T2)
map2seq(m) ==
  \keyw{cases} m:
    (\{|->\})	-> [],
    \{- |-> -\}	-> [m],
    m1 \keyw{munion} m2 -> map2seq[@T1, @T2] (m1) ^  map2seq[@T1, @T2] (m2)
  \keyw{end};
\end{alltt}

ここで、case式の3番目のcases式選択肢で、写像併合パターンを使用している。
m1とm2を写像mの任意の（互いに素な）部分写像に束縛する。

\paragraph{組パターンの例}
組パターンは、組構成要素を識別子と結びつけるために用いることができる。
たとえば上で定義された関数 \texttt{promoted} は2つを返すので、以下の値定義では \texttt{GroupA}の勝ったチームの方を識別子\texttt{Awinner}に結びつける:
\begin{alltt}
  \keyw{values}

    \keyw{mk\_}(Awinner,-) = promoted(GroupA);
\end{alltt}

\paragraph{レコードパターンの例}
レコードパターンはレコードのいくつかの項目が同じ式で用いられるときに役立つ。
たとえば次の式は、チーム名から点数スコアへの写像を構成する:
\begin{alltt}
  \{ t |-> w * 3 + l | \keyw{mk\_}Score(t,w,l,-,-) \keyw{in set elems} GroupA\}
\end{alltt}
 \pageref{printExprDef}ページの関数 \texttt{print\_Expr} もまた、レコードパターンのいくつかの例を与えてくれる。


\end{description}

\section{束縛}\label{bind}

\begin{description}
\item[構文:]
  \Rule{束縛}{
    \Ruleref{集合束縛} \dsepl \Ruleref{型束縛}
    }

  \Rule{集合束縛}{
    \Ruleref{パターン}, \Lop{in set}, \Ruleref{式}
    }

  \Rule{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }

  \Rule{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Rule{多重束縛}{
    \Ruleref{多重集合束縛} \dsep
    \Ruleref{多重型束縛}
    }

  \Rule{多重集合束縛}{
    \Ruleref{パターンリスト}, \Lop{in set}, \Ruleref{式}
    }

  \Rule{多重型束縛}{
    \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}
    }

%\item[意味定義:] {\it 束縛}は、ある値にパターンを一致させる。
\item[意味定義:] {\it 束縛}は、あるパターンをある値に一致させる。
 {\it 集合束縛} において、値は束縛の集合式によって定義された集合から選ばれる。
 {\it 型束縛} において、値は型式で定義された型から選ばれる。
 {\it 多重束縛}は、いくつかのパターンが同じ集合または型に束縛されることを除けば {\it 束縛} と同じである。
型束縛はインタープリタで実行させることは {\bf できない} ことに注意しよう。
これは、インタープリタに自然数というような無限の定義域の検索を要求するということであるからだ。

\item[例題:] 束縛は主に、これらの例にみられるように限量式や内包で用いられる:
  \begin{alltt}
    \keyw{forall} i, j \keyw{in set inds} list \& i < j => list(i) <= list(j)
      
    \{ y | y \keyw{in set} S & y > 2 \}

    \{ y | y: nat & y > 3 \}

    occurs : \keyw{seq1 of char} * \keyw{seq1 of char} -> \keyw{bool}
    occurs (substr,str) ==
      \keyw{exists} i,j \keyw{in set inds} str & substr = str(i,...,j);

  \end{alltt}
\end{description}

\section{値(定数)定義} \label{valuedef}

\vdmslpp{\vdmsl}{\vdmpp}\ では定数値の定義をサポートする。 
値定義については、伝統的プログラム言語における定数定義に相当する。

\begin{description}
\item[構文:]
  \Rule{値定義群}{
    \Lop{value}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                       {\Ruleref{値定義}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                              {\Ruleref{値定義}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{アクセス値定義}{
       (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed 
         \Ruleref{値定義}
    }}{}


  \Rule{値定義}{
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

\item[意味定義:] 値定義は次の形式をもつ:
  \begin{alltt}
    \keyw{values}
      \ifthenelse{\boolean{VDMpp}}{access}{} pat1 = e1;
      \ldots
      \ifthenelse{\boolean{VDMpp}}{access}{} patn = en
  \end{alltt}

  
グローバル値(値定義で定義された)は、 \vdmslpp{\vdmsl}{\vdmpp} 記述の全水準で参照が可能である。
しかしながら、1つの記述が実行可能であるためには、値定義の列に用いられる前段階でそれらの値は定義されていなければならない。 
この ``使用前の宣言'' 原則は、インタープリタが値定義にのみ使う。
 このことはたとえば、関数などは宣言される前に用いられることが可能なのである。
標準 VDM-SL では、定義の順番における制限はいっさい存在しない。
同様に型制限を提供することが可能であるから、このことでより正確な型情報を得るのに役立てることができる。

#ifdef VDMPP
アクセスおよび \keyw{static} 記述子の詳細は、第 \ref{ch:interface}節で述べられる。 
#endif VDMPP

\item[例題:] 以下の例は \cite{Fitzgerald&98} からとったものであるが、識別子\texttt{p1} と \texttt{eid2}にトークン値を与え、\texttt{e3} に\texttt{Expert} レコード値を与え、そして \texttt{a1}に \texttt{Alarm} レコード値を与える。
\begin{alltt}
     \keyw{types}

     Period = \keyw{token};
     ExpertId = \keyw{token};
     Expert :: expertid : ExpertId
               quali : \keyw{set of} Qualification
     \keyw{inv} ex == ex.quali <> \{\};
     Qualification = <Elec> | <Mech> | <Bio> | <Chem>;
     Alarm :: alarmtext : \keyw{seq of} char
              quali : Qualification

     \keyw{values}
 
     \PUBLIC p1: Period = mk_token("Monday day");
     \PRIVATE eid2 : ExpertId = mk_token(145);
     \PROTECTED e3 : Expert = mk_Expert(eid2, { <Mech>, <Chem> });
     \mbox{} a1 : Alarm = mk_Alarm("CO2 detected", <Chem>)
\end{alltt}
 この例が示すように、ある値はそれ自身が定義される前に定義された他の値に依存できる。
#ifdef VDMSL
  トップレベル仕様記述は多くのファイルやモジュールからの仕様記述から成り立つことができる(節~\ref{top-level}参照)。 
  命令が重要であるように、他のモジュール内で定義された値に依存させないことは、良い慣習である。
#endif VDMSL
\end{description}

#ifdef VDMPP
\section{インスタンス変数}
\label{sec:ivars}

クラス定義からインスタンス化されたオブジェクトとそのクラス自身の両者で、1つの内部状態を持つことができ、それはまたオブジェクトまたはクラスの \emph{インスタンス変数} と呼ばれる。 
オブジェクトの場合には、この状態をまたオブジェクトのグローバル状態として参照する。

\begin{description}
\item[構文:]
  \Rule{インスタンス変数定義群}{
    \Lop{instance}, \Lop{variables}, \lfeed
    \OptPt{\Ruleref{インスタンス変数定義}, \lfeed
           \SeqPt{\Lit{;}, 
               \Ruleref{インスタンス変数定義}
                 }
          }
  }
  

  \Rule{インスタンス変数定義}{
    \Ruleref{アクセス指定定義} \dsep
    \Ruleref{不変条件定義}
  }

  \Rule{アクセス指定定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
    \Ruleref{代入定義}
  }

\Rule{代入定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=},
  \Ruleref{式}}
  }
\Rule{不変条件定義}{
  \Lop{inv}, \Ruleref{式}
  }

%\Rule{init文}{
%  \Lop{init}, \Ruleref{文}
%  }

\item[意味定義:] 内部状態の記述する節に先立ち、 {\tt instance variables}というキーワードが必要である。
インスタンス変数定義と不変条件定義のリストは以下にある。
各々のインスタンス変数定義は、対応する型指定をともなうインスタンス変数名からなり、そこには初期値とアクセスおよび \keyw{static} 指定子を含めることもある。
アクセスおよび \keyw{static} 指定子についての詳細は、第\ref{ch:interface}節にみることができる。

不変条件定義の方法により、インスタンス変数の値を制限することが可能である。
各々の不変条件定義は、1つ以上のインスタンス変数を含み、クラスオブジェクトのインスタンス変数の値上で定義される可能性もある。
スーパークラスから継承されるものを含むクラスにあるすべてのインスタンス変数は、不変条件式で使用することができる。
各不変条件定義は、式がtrueとなるようにインスタンス変数の値を制限するブール式でなければならない。
すべての不変条件式は、そのクラスの各々のオブジェクトの全存在期間でtrueとなる必要がある。

あるクラスの全てにわたる不変条件式というのは、そのクラスおよびその複数のスーパークラスの不変条件定義のすべてが、まずは1)複数のスーパークラス、次は2)そのクラス自身、の中で定義された順に論理\keyw{and}で結合されたものである。

%あるクラスが1つまたはそれ以上の不変条件定義を含む場合、{\tt inv\_classname}という名の操作が暗黙的にこのクラス中に構築される
%\footnote{インタープリタではサポートされていない。}。
この操作はプライベートのものであり、パラメーターはもたず、不変条件式の実行に対応し1つのブール値を返す。

\item[例題:]

以下の例はインスタンス変数定義を示している。
このクラスでは1つのインスタンス変数が詳しく述べられる: 
  \begin{alltt}
  \keyw{class} GroupPhase

  \keyw{types}

    GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>;
    Team = ... -- as on page \pageref{scoredef}
    Score::team : Team
           won : \keyw{nat}
           drawn : \keyw{nat}
           lost : \keyw{nat}
           points : \keyw{nat};


  \keyw{instance variables}
    gps : \keyw{map} GroupName \keyw{to set of} Score;
  \keyw{inv forall} gp \keyw{in set rng} gps & 
        (\keyw{card} gp = 4 \keyw{and}
         \keyw{forall} sc \keyw{in set} gp & sc.won + sc.lost + sc.drawn <= 3)

  \keyw{end} GroupPhase
  \end{alltt}

% ***** Put this back in in the future if access to invariant can be
% ***** modified from private to public or protected
%The second example demonstrates inheritance.
%  \begin{alltt}
%  \keyw{class} BankAccount
%
%    \keyw{types}
%
%    \PUBLIC digit = \keyw{nat}
%    \keyw{inv} d == d < 10
%
%    \keyw{instance variables}
%      holder : \keyw{seq1 of char};
%      number : \keyw{seq1 of digit};
%      branchcode : \keyw{seq1 of digit};
%    \keyw{inv len} number = 8 \keyw{and len} branchcode = 6
%
%  \keyw{end} BankAccount
%  \end{alltt}
%
%In this example three instance variables are defined: \texttt{holder}
%- a string representing the name of the account holder,
%\texttt{number} - a sequence of digits representing the account
%number, and \texttt{branchcode} - a sequence of digits representing
%the code number of the bank branch holding the account.
%The invariant ensures that at all times the account number has 8
%digits and the branch code has 6 digits.
%
%As the class {\tt BankAccount} contains an invariant definition
%the invariant operation below is implicitly constructed:
%
%  \begin{alltt}
%    \keyw{inv\_}BankAccount: () ==> \keyw{bool}
%    \keyw{inv\_}BankAccount() ==
%      \keyw{return len} number = 8 \keyw{and len} branchcode = 6;
%  \end{alltt}
%
%The effect of inheritance is demonstrated by the class
%\texttt{ATMCard}:
%\begin{alltt}\label{ATMCardDef}
%  \keyw{class} ATMCard \keyw{is subclass of} BankAccount
%
%    \keyw{instance variables}
%      cardnumber : \keyw{seq of} digit;
%      expiry : digit * digit * digit * digit;
%    \keyw{inv} (\keyw{let mk\_}(m1,m2,y1,y2) = expiry
%        in m1 * 10 + m2 <= 12) and
%        \keyw{len} cardnumber >= 8
%
%  \keyw{end} ATMCard
%\end{alltt}
%This is a subclass of \texttt{BankAccount} so it inherits the type
%\texttt{digit}. In this case the implicitly created invariant
%operation is:
%
%  \begin{alltt}
%    \keyw{inv\_}ATMCard: () ==> \keyw{bool}
%    \keyw{inv\_}ATMCard() ==
%      \keyw{return} \keyw{len} number = 8 \keyw{and len} branchcode = 6 \keyw{and}
%            (\keyw{let} mk_(m1,m2,y1,y2) = expiry
%             \keyw{in} m1 * 10 + m2 <= 12) \keyw{and}
%             \keyw{len} cardnumber >= 8;
%  \end{alltt}

\end{description}
#endif VDMPP

#ifdef VDMSL
\section{状態定義}\label{statedef}

グローバル変数が仕様記述で要求されれば、状態定義をすることは可能である。状
態定義のコンポーネントは操作内で参照できるグローバル変数のコレクションと
見なすことが可能である。
モジュールの状態はモジュール内の(その状態を使用している)操作
定義のいずれかがインタープリタによって使用される前に初期化される。

\begin{description}
\item[構文:]
  \Rule{状態定義}{
    \Lop{state}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \lfeed
    \OptPt{\Ruleref{不変条件}}, \OptPt{\Ruleref{初期化}}, \Lop{end}, \OptPt{\Lit{;}}
    }

  \Rule{不変条件}{
    \Lop{inv}, \Ruleref{不変条件初期関数}
    }

  \Rule{初期化}{
    \Lop{init}, \Ruleref{不変条件初期関数}
    }

  \Rule{不変条件初期関数}{
    \Ruleref{パターン}, \Lit{==}, \Ruleref{式}}

\item[意味定義:] 状態定義は次の形式をもつ:
  \begin{alltt}
    \keyw{state} ident \keyw{of}
      id1 : type1
      \ldots
      idn : typen
    \Keyw{inv}  pat1 == inv
    \Keyw{init} pat2 == init
    \keyw{end}
  \end{alltt}
  状態識別子 {\tt idn}は特定の型 {\tt typen}であると宣言される。不変条件 {\tt inv}はいつも状態 {\tt ident}が保たなければならない特性を意味している論理式である。
  {\tt init}は初めに成立しなければならない状態を指示する。
  インタープリタを使用するためには、(もしも、状態を使用している操作が実行されるならば)初期化述語が必要であることに注意すべきである。
  加えてこの初期化述語の本体は状態全体の名称(その名称はパターン
  として使用されなくてはならない)を等式の左辺値とし、右辺値は正しい
  型のレコード値として評価される二項相当式でなくてはならない。これ
  はインタープリタが {\tt init} 状態を評価すること可能にする。初期化述語の簡単な例を以下に示す:

  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{init} s == s = \keyw{mk\_}St(0,0,[1])
  \keyw{end}
  \end{alltt}

  不変条件と初期値の両方の仕様記述では、全体として状態を操作しなければならない。
  また、それを状態名(例を参照)でタグ付けされたレコードとして参照することによって行う。
  状態中の項目がoperationで操作されるとき、状態名が前に付いていない項目名によって、項目は直接参照されなければならない。



\item[例:] 以下の例では、一つの状態変数を作成している:
  \begin{alltt}
  \keyw{types }

  GroupName = <A> | <B> | <C> | <D> | <E> | <F> | <G> | <H>

  \keyw{state} GroupPhase \keyw{of}
    gps : \keyw{map} GroupName \keyw{to set of} Score
  \keyw{inv mk\_}GroupPhase(gps) ==
    \keyw{forall} gp \keyw{in set rng gps} & 
      (\keyw{card} gp = 4 \keyw{and}
       \keyw{forall} sc \keyw{in set} gp & sc.won + sc.lost + sc.drawn <= 3)
  \keyw{init} gp ==
    gp = \keyw{mk\_}GroupPhase ({ <A> |-> 
                                init_sc ({<Brazil>, <Norway>, 
                                    <Morocco>, <Scotland>}),
                         ...})
  \keyw{end}

  \keyw{functions}

  init_sc : \keyw{set of} Team -> \keyw{set of} Score
  init_sc (ts) ==
    \{ \keyw{mk\_}Score (t,0,0,0,0) | t \keyw{in set ts} \}
  \end{alltt}
  不変条件において、各グループには4 つのチームがあり、どのチームも3ゲーム以上行わないことを提示する。
  初めは、どのチームもゲームをしていない。

\end{description}
#endif VDMSL

\section{操作定義} \label{op-def}

操作については第~\ref{algorithm}節にすでに述べてきた。 
一般的な形式は
\ifthenelse{\boolean{VDMsl}}{ここで述べる。}{すぐ次に述べるが、クラスのインスタンス構成に用いられる\emph{構成子} と呼ばれる特別な操作については 第~\ref{constructors}節に記述する。} 

\begin{description}
\item[構文:]
  \Rule{操作定義群}{
    \Lop{operations}, 
    \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                       {\Ruleref{操作定義}}, \lfeed
           \SeqPt{\Lit{;}, 
                  \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                       {\Ruleref{操作定義}}
                 }, 
           \OptPt{\Lit{;}}
          }
    }

  \ifthenelse{\boolean{VDMpp}}{
     \Rule{アクセス操作定義}{(
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsep\  
     (
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{操作定義}
    }}{}


\Rule{操作定義}{
  \Ruleref{陽操作定義} \dsep
  \Ruleref{陰操作定義} \dsep
  \Ruleref{拡張陽操作定義}
  }

\Rule{陽操作定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{操作型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーター群}, \lfeed
  \Lit{{\tt ==}}, \lfeed  \Ruleref{操作本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
#ifdef VDMPP
  %, \lfeed
  %\OptPt{\Lop{time}, \Lop{post}, expression}
#endif VDMPP
  }

\Rule{陰操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Ruleref{陰操作本体}
  }

\Rule{陰操作本体}{
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}, \lfeed
#ifdef VDMPP
  %\OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{例外}}
  }

\Rule{拡張陽操作定義}{
  \Ruleref{識別子}, \lfeed
  \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Lit{==}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed
#ifdef VDMPP
  %\OptPt{\Lop{time}, \Lop{post}, \Ruleref{式}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{例外}}
}

\Rule{操作型}{
  \Ruleref{任意の型}, \Lit{{\tt ==>}}, \Ruleref{任意の型}
  }

\Rule{任意の型}{
  \Ruleref{型} \dsepl \Lit{()}
  }

\Rule{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Rule{パターンリスト}{
  \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\Rule{操作本体}{
  \Ruleref{文} \dsep 
#ifdef VDMPP
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!操作}
  \dsep \Lop{is subclass responsibility}\index{\keyw{is subclass responsibility}!操作}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified}\index{\keyw{is not yet specified}!operations}
#endif VDMSL
  }

\Rule{外部節}{
  \Lop{ext}, \Ruleref{var情報}, \SeqPt{\Ruleref{var情報}}
  }

\Rule{var情報}{
  \Ruleref{モード}, \Ruleref{名称リスト}, \OptPt{\Lit{:}, \Ruleref{型}}
  }

\Rule{モード}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Rule{名称リスト}{
  \Ruleref{識別子}, \SeqPt{\Lit{,}, \Ruleref{識別子}}
  }

\Rule{例外}{
  \Lop{errs}, \Ruleref{エラーリスト}
  }

\Rule{エラーリスト}{
  \Ruleref{エラー}, \SeqPt{\Ruleref{エラー}}
  }

\Rule{エラー}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{式}, \Lit{->}, \Ruleref{式}
  }

\item[意味定義:]
#ifdef VICEMAN
VDMでの操作はデフォルトの同期単位であるが、キーワード``\keyw{async}''が操作定義の前で使用されると、
それは、操作が非同期操作として扱われることを意味する。
これは、非同期操作の呼び出しを要求をされた後に、操作が戻り型を持つことが出来ず、
非同期操作と呼ばれるスレッドが自身の実行を続けることを意味する。

※コンストラクタを非同期であると宣言できないことに注意してください。
#endif VICEMAN
#ifdef VDMPP
アクセスと \keyw{static} 指定子の詳細については、第 \ref{ch:interface}節に求められる。
静的操作では静的でない操作や関数を呼ぶことは許されていないし、self式を静的操作の定義に用いることはできない、ということは注意しよう。
#endif VDMPP

陽操作の以下の例は、1つのチームがもうひとつを打ち負かす場合に
#ifdef VDMSL
状態 \texttt{GroupPhase} 
#endif VDMSL
#ifdef VDMPP
\texttt{GroupPhase}クラスのインスタンス変数
#endif VDMPP
を更新する。
\begin{alltt}\label{winDef}
  Win : Team * Team ==> ()
  Win (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps := gps ++ \{ gp |-> 
                        \{\keyw{if} sc.team = wt
                         \keyw{then mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                         \keyw{else if} sc.team = lt
                         \keyw{then mu}(sc, lost |-> sc.lost + 1)
                         \keyw{else} sc 
                    | sc \keyw{in set} gps(gp)\}\}
    \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\};
\end{alltt}
1つの陽操作は1つの文(あるいは1つのブロック文を用いてまとめられたいくつかの文)からなるが、これについては第 \ref{sec:stmt}節で述べられている。 
文は、必要とするどのような
#ifdef VDMSL
状態
#endif
#ifdef VDMPP
インスタンス
#endif
変数に対しても、適当と判断したときに読込みや書出しを行いアクセスすることが許されている。

陰操作は、オプションである事前条件、または必要不可欠な事後条件を用いて指定される。
たとえば、ここに暗黙に陰操作\texttt{Win}を指定できる:
\begin{alltt}
  Win (wt,lt: Team)
  \Keyw{ext wr} gps : \keyw{map} GroupName \keyw{to set of} Score
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
          \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \Keyw{post} \keyw{exists} gp \keyw{in set dom} gps &
         \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
         \keyw{and} gps = gps~ ++ 
                       \{ gp |-> 
                         \{\keyw{if} sc.team = wt
                          \keyw{then} \keyw{mu}(sc, won |-> sc.won + 1,
                                     points |-> sc.points + 3)
                          \keyw{else if} sc.team = lt
                          \keyw{then mu}(sc, lost |-> sc.lost + 1)
                          \keyw{else} sc 
                     | sc \keyw{in set} gps(gp)\}\};
\end{alltt}

外部節の項目は、操作が扱うはずの
#ifdef VDMSL
状態
#endif
#ifdef VDMPP
インスタンス
#endif
変数をリストする。
予約語である \keyw{rd} の後にリストされた
#ifdef VDMSL
状態
#endif
#ifdef VDMPP
インスタンス
#endif
変数は読み取りのみができるが、その一方 \keyw{wr}の後にリストされた変数は読みとり書きだしの両方行うことができる。
 
#ifdef VDMSL
これらの事前、事後条件に対して、インタープリタも操作定義の事前、事後条件として新しい関数を作成する。
しかし、仕様記述がグローバルな状態を含んでいるならば、状態は新たに作成された関数の一部である。 
したがって、以下のシグネチャを持つ関数が、事前、事後条件をもった操作に対して作成される
\footnote{しかしながら、これらの事前、事後条件の述語は単にブール関数であることを覚えておくべきである。
また、その状態のコンポーネントは、このような述語を呼び出すことによって変更してはいけない}:
\begin{alltt}
  \keyw{pre\_}Op : InType * State +> \keyw{bool}

  \keyw{post\_}Op : InType * OutType * State * State +> \keyw{bool}
\end{alltt}
以下は例外である:
\begin{itemize}
\item もし、操作が引数を取らないなら、シグネチャの{\tt InType}部分を {\tt \keyw{pre\_}Op} と {\tt \keyw{post\_}Op}
の両方で省略する。

\item もし、操作が値を返さないなら、{\tt OutType}部分を {\tt \keyw{post\_}Op}シグネチャにおいて省略する。

\item もし、仕様記述が状態を定義しないなら、両方のシグネチャの{\tt State}部分は省略する。

\end{itemize}

{\tt \keyw{post\_}Op}シグネチャにおいて、最初の {\tt State}部分は旧状態であるに対して、
2番目の {\tt State}部分は操作呼び出し後の状態である。

例えば、以下の仕様記述を考える:

\begin{quotation}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} A

\keyw{definitions}

\keyw{state} St \keyw{of}
  n : \keyw{nat}
\keyw{end}

\keyw{operations}

Op1 (a : \keyw{nat}) b :\keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} A

\end{alltt}
\end{minipage}
\begin{minipage}[t]{.4\textwidth}
\begin{alltt}
\keyw{module} B

\keyw{definitions}

\keyw{operations}

Op1 (a : \keyw{nat}) b : \keyw{nat}
\keyw{pre} a > 0
\keyw{post} b = 2 * a;

Op2 () b : \keyw{nat}
\keyw{post} b = 2;

Op3 ()
\keyw{post} \keyw{true}

\keyw{end} B
\end{alltt}
\end{minipage}
\end{quotation}

\textbf{module A}に対しこの仕様記述で定義されている事前事後条件の引用方法を以下に示す

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{引用式} & 説明 \\ \hline
\keyw{pre}\_Op1(1,\keyw{mk}\_St(2))              
  & \texttt{n}を2に、\texttt{a}を1に束縛する \\
\keyw{post}\_Op1(1,2,\keyw{mk}\_St(1), \keyw{mk}\_St(2)) 
  & \texttt{a} を1に、\texttt{b} を2に、
    \texttt{n} の前の状態を1に、
      \texttt{n} の後の状態を2に束縛する \\
\keyw{post}\_Op2(2,\keyw{mk}\_St(1), \keyw{mk}\_St(2))   
  & \texttt{b} を2に、
    \texttt{n} の前の状態を1に、
      \texttt{n} の後の状態を2に束縛する \\
\keyw{post}\_Op3(\keyw{mk}\_St(1), \keyw{mk}\_St(2))     
  & \texttt{n} の前の状態を1に、
    \texttt{n} の後の状態を2に束縛する \\
\hline
\end{tabular}

\textbf{module B}に対しこの仕様記述で定義されている事前事後条件の引用方法を以下に示す

\begin{tabular}{|>{\ttfamily\selectfont}p{.4\textwidth}p{.4\textwidth}|} \hline
\textrm{引用式} & 説明 \\ \hline
\keyw{pre}\_Op1(1)     & \texttt{a} を1に束縛する\\
\keyw{post}\_Op1(1,2)  & \texttt{a} を1に、\texttt{b}を2に束縛する\\
\keyw{post}\_Op2(2)    & \texttt{b}を2に束縛する\\
\keyw{post}\_Op3()     & 何も束縛しない\\
\hline
\end{tabular}

\vspace{2ex}

#endif VDMSL

例外節は、ある操作がエラー状態にどのように対処するかを記述をすることに用いることができる。
理論的根拠を持つための例外節は、正常なケースと例外ケースを切り離す分離することを可能にする。
例外を用いた記述では、どのように例外を起こすかについて言及はしていないが、どのような環境でエラー状態が起こり得るか、また操作を呼
び出した結果どのような影響が起きるかについて示す手段が与えられる。

例外節は次の形式をもつ:
\begin{alltt}
   \keyw{errs} COND1: c1 -> r1
       \ldots
       CONDn: cn -> rn
\end{alltt}
条件名 {\tt COND1}, \ldots, {\tt CONDn} は識別子で、起きる可能性があるエラーの種類を記述する\footnote{これらの名前は単に記憶を助けてくれる値であり、つまり意味定義上は重要でない。}。 
条件式 {\tt c1}, \ldots, {\tt cn} は、異なる種類のエラーに対する事前条件と考えることができる。
このようにこれらの式においては、引数リストから識別子をまた外部節リストからは変数を用いることができる (それらは事前条件と同じスコープをもつ)。
結果の式である {\tt r1},\ldots, {\tt rn} は相対的にみれば、異なる種類のエラーに対する事後条件と同じと考えられる。
これらの式においては、結果の識別子とグローバル変数 (書き込みのできる) の旧値もまた用いることができる。
このように、ここでのスコープは事後条件のスコープに相当する。

表面的には、ここでの例外と事前条件との間にはいくらか重複があるようにみえる。
しかしながらこれらの間には、どちらをいつ用いるべきか指し示す概念的な違いが存在する。 
事前条件は、その操作の呼び出しが正しく行なわれるためにどんなことを保証しなければならないかを指定する; 例外節は、例外条件が満たされたときに記述された操作がエラー処理の責任をとることを示す。
したがって通常は、例外節と事前条件は重複しない。

#ifdef VDMSL
操作における次の例は、以下の状態定義を使用する:
\begin{alltt}
  \keyw{state} qsys \keyw{of}
    q : Queue
  \keyw{end}
\end{alltt}    
#endif
#ifdef VDMPP
次のある操作例では、後に続くインスタンス変数定義を用いる:
\begin{alltt}
  \keyw{instance variables}
    q : Queue
  \keyw{end}
\end{alltt}    
#endif
この例では、陰操作の例外がどのように用いられるか示される:
\begin{alltt}
  DEQUEUE() e: [Elem]
  \keyw{ext} \keyw{wr} q : Queue
  \keyw{post} q~ = [e] ^ q
  \keyw{errs} QUEUE_EMPTY: q = [] -> q = q~ \keyw{and} e = \keyw{nil}
\end{alltt}

これはデキュー操作であって、 型{\tt Queue}の グローバル変数 {\tt q}を用いて、キューから型{\tt Elem}の 要素{\tt e}をとりのぞく。 
ここでの例外としては、その中で例外節が操作がどのように行われるかを指定するキューが、空である場合がある。

#ifdef VDMSL
Toolboxはここで以下の関数を作成することに注意する:
\begin{alltt}
  \keyw{post\_}DEQUEUE: [Elem] * qsys * qsys +> \keyw{bool}
\end{alltt}
#endif

#ifdef VDMPP

%The time post-condition has the same scope as the post-condition and
%deals with the duration of the operation from the invocation moment
%until the moment it finishes. Thus describing for explicitly specified
%operations, the duration of the statement.
%
%The following two extra concepts are
%introduced: {\tt now\verb+~+}, representing the time the operation is
%invoked (moment of incrementing {\tt \#act}) and {\tt now},
%representing the time the operation is completely finished (moment of
%incrementing {\tt \#fin}). The expression:
%\begin{alltt}
%  now - now\verb+~+
%\end{alltt}
%represents the duration of the operation. 
%
%For instance, consider the specification of a system for controlling a
%set of traffic lights. We might have the following instance variables:
%\begin{alltt}
%  \keyw{instance variables}
%    red: \keyw{bool};
%    green: \keyw{bool};
%    amber: \keyw{bool};
%  \keyw{inv} (red => (\keyw{not} green \keyw{and not} amber)) \keyw{and}
%     (green => (\keyw{not} amber \keyw{and not} red)) \keyw{and}
%     (amber => (\keyw{not} red \keyw{and not} green))
%\end{alltt}
%Then the following operation specifies that on execution the light
%must change from red to green within 20 time units:
%\begin{alltt}
%    RedToGreen()
%    \keyw{ext wr} red: \keyw{bool}
%       \keyw{wr} green: \keyw{bool}
%    \keyw{pre} red
%    \keyw{post} green
%    \keyw{time post now} - \keyw{now}~ < 20
%\end{alltt}

#endif VDMPP

\end{description}

#ifdef VDMPP
\subsection{構成子}\label{constructors}

構成子は操作であって、それ自身が中で定義されたクラスと同じ名前をもち、このクラスの新しいインスタンスをつくるものである。
このため戻り値の型は、その同じクラス名でなければならず、戻り値が指定されるならば \keyw{self}となるべきであるが、これはオプションで省略可能である。

第~\ref{sec:classdep}節で述べられるが、オーバーロードする操作を用いた単一クラスで、多重構成子の定義が可能である。 

#endif VDMPP

\section{文}\label{sec:stmt}

この章では、異なる種類の文を1種類ごとに記述する。 
各々は、次の方法で記述されていく:
\begin{itemize}
\item BNF構文記法。
\item 形式的でない意味定義記述。
\item 使用例を1つ。
\end{itemize}

\subsection{let文}\label{letstmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \Ruleref{let文} \dsep
    \Ruleref{let be文} \dsep
    \ldots
    }

  \Rule{let文}{
    \Lop{let}, \Ruleref{ローカル定義}, \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
    \Lop{in}, \Ruleref{文}
    }

  \Rule{let be文}{
    \Lop{let}, \Ruleref{束縛}, \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}},
    \Lop{in}, \lfeed
    \Ruleref{文}
    }

  \Rule{ローカル定義}{
    \Ruleref{値定義} \dsep \Ruleref{関数定義}
    }

  \Rule{値定義}{ 
    \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
    }

 ここでの構成要素である ``関数定義'' は第~\ref{functiondef}節に記述されている。

\item[意味定義:]  {\it let文} と {\it let-be-such-that文} は、{\it in}の部分が式であるかわりに文であることを除けば、各々がそれぞれ {\it let} と {\it let-be-such-that式} に対応し似ている。
これは以下のように説明することができる:

  単純な {\it let文} は次の形式をもつ:
  \begin{alltt}
    \keyw{let} p1 = e1, \ldots, pn = en \keyw{in} s
  \end{alltt}
ここで {\tt p1, \ldots, pn} はパターン、{\tt e1, \ldots, en} は対応するパターンである{\tt pi}に一致する式、そして {\tt s}は任意の型の文であるが {\tt  p1, \ldots, pn}というパターン識別子を含む。 
これは、パターン {\tt p1, \ldots, pn} が式{\tt e1, \ldots, en}に対して一致する文脈中での、文 {\tt s} の評価を示す。

ローカル関数定義を用いることで、より高度な let 文をつくることもできる。
これを行う意味定義は単純で、このようなローカルに定義された関数のスコープはlet文の本体に制限される。

#ifdef VDMSL
  VDM-SLでは、複数の定義が互いに再帰的になるかもしれない。
%  However, this is not supported by the interpreter in IFAD VDM-SL.
  しかしながら、これはVDM-SLでインタプリタによってサポートされていない。
  その上、定義を使用されている前に、すべての構成要素が定義されるように命令しなければならない。
#endif VDMSL

  {\it let-be-such-that文}は次の形式をもつ
  \begin{alltt}
    \keyw{let} b \keyw{be st} e \keyw{in} s
  \end{alltt}
ここで {\tt b} は束縛であって集合値(または型)に対するパターンからなり、 {\tt  e} はブール式、 そして{\tt s} は文であって {\tt b}におけるパターンのパターン識別子を含むものである。 
 {\tt \keyw{be st} e}の部分はオプションである。
この式は、{\tt b}からの集合(または型)の要素に対し{\tt b}からのパターンが一致する文脈中での、文 {\tt s} の評価を示すものである\footnote{集合束縛のみがインタープリタで実行できるということを思い出そう。}。 
 \keyw{be st}式である{\tt e}が存在するとき、唯一このような束縛が、一致させる文脈中で{\tt e} が真と評価される場所で用いられる。
     
\item[例題:] \keyw{let be st} 文の1つの例は、
#ifdef VDMPP
クラス \texttt{GroupPhase}の
#endif VDMPP
操作 \texttt{GroupWinner}中にあり、あるグループ内での勝チームを返してくれるものである: 
  \begin{alltt}
  GroupWinner : GroupName ==> Team
  GroupWinner (gp) ==
    \keyw{let} sc \keyw{in set} gps(gp) \keyw{be st}
       \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} & 
          (sc.points > sc'.points) \keyw{or}
          (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
    \keyw{in return} sc.team
  \end{alltt}
 仲間の操作である\texttt{GroupRunnerUp} もまた同様に、簡単な let 文の例を与えてくれる:
  \begin{alltt}
  GroupRunnerUp_expl : GroupName ==> Team
  GroupRunnerUp_expl (gp) ==
    \keyw{def} t = GroupWinner(gp)
    \keyw{in let} sct = \keyw{iota} sc \keyw{in set} gps(gp) & sc.team = t
      \keyw{in}
         \keyw{let} sc \keyw{in set} gps(gp) \verb+\+ \{sct\} \keyw{be st}
           \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc,sct\} & 
             (sc.points > sc'.points) \keyw{or}
             (sc.points = sc'.points \keyw{and} sc.won > sc'.won)
         \keyw{in return} sc.team
  \end{alltt}
ここにおける \texttt{def} 文 (第 \ref{defstmt}節参照)の使用に注意; 右辺が操作呼出しであるために \texttt{let} 文ではなくこれを用いるが、したがってこれは式ではない。
\end{description}

\subsection{def文}\label{defstmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{def文} \dsep \ldots
    }

  \Rule{def文}{
    \Lop{def}, 
    \Ruleref{相等定義}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{相等定義}},\OptPt{\Lit{;}},
    \Lop{in}, \lfeed
    \Ruleref{文}
    } 

  \Rule{相等定義}{
    \Ruleref{パターン束縛}, \Lit{=},
    \Ruleref{式}}

\item[意味定義:] {\it def文} は次の形式をもつ:
  \begin{alltt}
    \Keyw{def} pb1 = e1;
        \ldots
        pbn = en
    \keyw{in}
      s
  \end{alltt}
  {\it def文} は、 右辺において操作呼出しを用いることが許される点を除けば{\it def式}に相当するものである。 
このような、状態を変化させる操作もここで用いることができ、またもし複数の定義がなされている場合には、出現した順に評価が行われる。 
 このことは、パターン(または束縛){\tt pb1, \ldots, pbn}が対応する式や演算呼出し{\tt e1, \ldots, en}によって返される値と一致する文脈中の文{\tt s} の評価の外延を表す\footnote{束縛が用いられるのであれば第~\ref{patterns}節で説明されるように、パターンと一致し得る値はさらに型や集合式により束縛がなされることを単純に意味する。}。

\item[例題:]  以下の列が与えられている:
  \begin{alltt}
  secondRoundWinners = [<A>,<B>,<C>,<D>,<E>,<F>,<G>,<H>];
  secondRoundRunnersUp = [<B>,<A>,<D>,<C>,<F>,<E>,<H>,<G>]
  \end{alltt}
#ifdef VDMPP
 \texttt{GroupPhase} クラスからの
#endif VDMPP
操作\texttt{SecondRound}%
は組の列を返し、第2ラウンドゲームが\keyw{def}文の例を与えていることを表わす:
  \begin{alltt}
  SecondRound : () ==> \keyw{seq of} (Team * Team)
  SecondRound () ==
  \keyw{def} winners = \{ gp |-> GroupWinner(gp) | gp \keyw{in set dom} gps \};
     runners_up = \{ gp |-> GroupRunnerUp(gp) | gp \keyw{in set dom} gps\}
  \keyw{in return} ([mk_(winners(secondRoundWinners(i)),
                runners_up(secondRoundRunnersUp(i))) 
           | i \keyw{in set} \{1,...,8\}])
  \end{alltt}

\end{description}

\subsection{ブロック文} \label{dcl-stmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{ブロック文} \dsep \ldots
    }

  \Rule{ブロック文}{
    \Lit{(}, \SeqPt{\Ruleref{dcl文}}, \lfeed
    \Ruleref{文}, \SeqPt{\Lit{;}, \Ruleref{文}}, \OptPt{\Lit{;}}, \Lit{)}
    }

  \Rule{dcl文}{
    \Lop{dcl}, \Ruleref{代入定義}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{代入定義}}, \Lit{;}
    }

  \Rule{代入定義}{
    \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=},
    \Ruleref{式}}}

\item[意味定義:] {\it ブロック文}は、伝統的な高水準プログラム言語におけるブロック文に相当する。
ブロック文を用いることで、(宣言文を使用して)ブロック文の本体内での変更が許されたローカル定義変数の使用が可能となる。
これは単に、個々の文が規定することを順に実行することを示すものである。
文の列において1つの値を返す最初の文により、文の列を終了させるための評価がひき起こされる。
この値はブロック文の値として返される。
ブロック内のどの文も値を返さない場合には、ブロック文の評価はブロック内の最後の文が評価されたときに終了する。
ブロック文が中止された場合には、ローカル変数の値は開放される。
このように、これら変数のスコープは単純にブロック文の内部である。
      
\item[例題:] 次のような
#ifdef VDMSL
state definition
  \begin{alltt}\label{stdef}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
#endif VDMSL
#ifdef VDMPP
インスタンス変数
  \begin{alltt}\label{stdef}
  \keyw{instance variables}
    x:\keyw{nat};
    y:\keyw{nat};
    l:\keyw{seq1 of nat};
  \end{alltt}
#endif VDMPP
に関連したものとして
ここに述べる\texttt{Swap} 操作は、変数 \texttt{x} と \texttt{y}の値交換を行うためにブロック文を用いる:
  \begin{alltt}
  Swap : () ==> ()
  Swap () ==
    (\keyw{dcl} temp: \keyw{nat} := x;
     x := y;
     y := temp
    )
  \end{alltt}

\end{description}

\subsection{代入文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
%    \ifthenelse{\boolean{VDMpp}}{\Ruleref{一般代入文}}%
%                                {\Ruleref{代入文}} \dsep
    \Ruleref{一般代入文} \dsep
    \ldots
    }

%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{一般代入文}{
  \Ruleref{代入文} \dsep
  \Ruleref{多重代入文}
  }
%}%
%{}

\Rule{代入文}{
  \Ruleref{状態指示子}, \Lit{:=}, 
    \Ruleref{式}
  }

  \Rule{状態指示子}{
    \Ruleref{名称} \dsep
    \Ruleref{項目参照} \dsep
    \Ruleref{写像参照または列参照}
    }

  \Rule{項目参照}{
    \Ruleref{状態指示子}, \Lit{.}, \Ruleref{識別子}
    }

%koizumi change_start
%  \Rule{写像参照}{
%    \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
%    }

%  \Rule{列参照}{
%    \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
%    }

  \Rule{写像参照または列参照}{
    \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
    }
%koizumi change_end
%\ifthenelse{\boolean{VDMpp}}{%
  \Rule{多重代入文}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{代入文}, \Lit{;}, \lfeed
      \Ruleref{代入文},
      \lfeed
%      \OptPt{\SeqPt{\Lit{;},\Ruleref{代入文}}}
      \SeqPt{\Lit{;},\Ruleref{代入文}}
    \Lit{)}
    }
%  }%
%{}

\item[意味定義:]  {\it 代入文} は、伝統的な高水準プログラム言語における代入文を一般化したものに相当する。
これを用いてグローバル状態またはローカル状態の値を変更する。
したがって代入文は、状態を変える副作用を起こす。
しかしながら、単純にある状態の一部を変更することができるように、代入文の左辺を状態指定子とすることができる。
状態指定子とは、単純なグローバル変数の名前、変数項目への参照、変数の写像参照、または変数の列参照、である。
この方法で、ある状態の小さな構成子の値を変更することが可能だ。
たとえば、もし状態構成要素が写像であったならば、写像のひとつの要素を変更することが可能である。

 代入文は次の形式をもつ:
  \begin{alltt}
    sd := ec
  \end{alltt}
 ここで {\tt sd} は状態指定子であり、 {\tt ec}は式または操作呼出しである。
代入文は、(式または操作呼出しの)右辺に記述された既に与えられている状態構成要素への変更を示す。
もし右辺が操作変更の状態であるならば、その操作は代入が行われる前に(それ相当の副作用を伴い)実行される。 


 多重代入もまた可能である。
これは次の形式をもつ：
  \begin{alltt}
    \keyw{atomic} (sd1 := ec1;
\           ...;
\           sdN := ecN
           )
  \end{alltt}
右辺の式または操作呼出しはすべて、実行されるかあるいは評価され、その結果は相当の状態指定子に結び付けられる。
右辺は、不変条件評価に関しては原子的に実行される。
#ifdef VDMPP
 しかし多重スレッド併発モデルの場合、タスク切替に関して、実行は必ずしも原子的ではない。 
#endif VDMPP

\item[例題:] 前に述べた例(\texttt{Swap})における操作は、通常の代入を表していた。
次の\texttt{Win\_sd}操作は、\pageref{winDef}ページの\texttt{Win}を手直ししたものであり、特定の写像キーに代入をおこなう状態指示子の仕様記述を行っている:
  \begin{alltt}
  Win_sd : Team * Team ==> ()
  Win_sd (wt,lt) ==
    \keyw{let} gp \keyw{in set dom} gps \keyw{be st} 
        \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
    \keyw{in} gps(gp) := \{ \keyw{if} sc.team = wt
                   \keyw{then mu}(sc, won |-> sc.won + 1,
                               points |-> sc.points + 3)
                   \keyw{else if} sc.team = lt
                   \keyw{then mu}(sc, lost |-> sc.lost + 1)
                   \keyw{else} sc 
                 | sc \keyw{in set} gps(gp)\}
  \Keyw{pre} \keyw{exists} gp \keyw{in set dom} gps & 
                 \{wt,lt\} \keyw{subset} \{sc.team | sc \keyw{in set} gps(gp)\}
  \end{alltt}
\texttt{SelectionSort}操作 は\pageref{selectionSortdef}ページにおける\texttt{selection\_sort}関数の状態使用版である。
これは、~\pageref{stdef}ページに定義された
#ifdef VDMSL
state \texttt{St}
#endif VDMSL
#ifdef VDMPP
インスタンス変数
#endif VDMPP
を用いて、特定の列索引の内容を変更するための状態指示子の使用を述べている。 
  \begin{alltt}
  \keyw{functions}
 
  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
  \keyw{if len} l = 1 \keyw{then} 1
  \keyw{else let} mi = min_index(\keyw{tl} l)
     \keyw{in if} l(mi+1) < \keyw{hd} l
       \keyw{then} mi+1
       \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    \keyw{if} i < \keyw{len} l
    \keyw{then} (\keyw{dcl} temp: \keyw{nat};
         \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         temp := l(mi);
         l(mi) := l(i);
         l(i) := temp;
         SelectionSort(i+1)
        );
  \end{alltt}
#ifdef VDMPP
  以下に述べる例では多重代入を描く。
  \begin{alltt}
  \keyw{class} C

    \keyw{instance variables}
      size : \keyw{nat};
      l : \keyw{seq of nat};
    \keyw{inv} size = \keyw{len} l

    \keyw{operations}
      add1 : \keyw{nat} ==> ()
      add1 (x) ==
         ( l := [x] ^ l;
           size := size + 1);

      add2 : \keyw{nat} ==> ()
      add2 (x) ==
         atomic (l := [x] ^ l;
                 size := size + 1)

  \keyw{end} C
  \end{alltt}
ここでは、\texttt{add1} の中でこのクラスのインスタンス変数における不変条件はこわされるが、一方の\texttt{add2}の中では多重代入を用いることで不変条件は保持される。
#endif VDMPP

\end{description}

\subsection{条件文}\label{condstmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{if文} \dsep
    \Ruleref{cases文} \dsep \ldots
    }

  \Rule{if文}{
    \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{文}, \lfeed
    \SeqPt{\Ruleref{elseif文}}, \OptPt{\Lop{else}, \Ruleref{文}}
    }

  \Rule{elseif文}{
    \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{文}
    }

  \Rule{cases文}{
    \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
    \Ruleref{cases文選択肢群}, \lfeed
    \OptPt{\Lit{,}, \Ruleref{others文}}, \Lop{end}
    }

  \Rule{cases式選択肢群}{
    \Ruleref{cases文選択肢}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{cases文選択肢}}
    }

  \Rule{cases文選択肢}{
    \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{文}
    }

  \Rule{others文}{
    \Lop{others}, \Lit{->}, \Ruleref{文}
    }

\item[意味定義:]   {\it if文}の意味定義は、文に代わることを除けば (また \keyw{else} 部分がオプションであることも除けば)、第~\ref{if-exp}節に述べられた {\it if式} に相当する\footnote{ \keyw{else}部分が省略される場合は、意味定義上は \keyw{else skip}を用いるのと同じである。}。 
  
 {\it cases文} に対する意味定義は、文に代わることを除けば、第~\ref{cases-exp}節に述べられた{\it cases式} に相当する。

\item[例題:] 以下のシグネチャをもつ、関数 \texttt{clear\_winner} と \texttt{winner\_by\_more\_wins} そして演算 \texttt{RandomElement} を仮定する:
  \begin{alltt}
    clear_winner : \keyw{set of} Score -> \keyw{bool}
    winner_by_more_wins : \keyw{set of} Score -> \keyw{bool}
    RandomElement : \keyw{set of} Team ==> Team
  \end{alltt}
その後、操作 \texttt{GroupWinner\_if} ではネストしたif文使用の実例が挙げられている(iota式については \pageref{iotaexpr}ページで紹介されている):
  \begin{alltt}
  GroupWinner_if : GroupName ==> Team
  GroupWinner_if (gp) ==
    \keyw{if} clear_winner(gps(gp))
     -- 他のどのスコアより点数が多いgps(gp)の
     -- 唯一のスコアを返す
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                   \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                     sc.points > sc'.points).team)
    \keyw{else if} winner_by_more_wins(gps(gp))
     -- 最大の点数であり最大点数の他のスコアより多く勝っている
     -- gps(gp)における唯一のスコアを返す
    \keyw{then return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
              \keyw{forall} sc' \keyw{in set} gps(gp) \verb+f+\ \{sc\} &
                (sc.points > sc'.points) \keyw{or}
                (sc.points = sc'.points \keyw{and} 
                 sc.won > sc'.won)).team)
     -- まったくの勝者はなく、よって最高スコアの中から
     -- 無作為にスコアを選ぶ
    \keyw{else} RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                           \keyw{forall} sc' \keyw{in set} gps(gp) &
                            sc'.points <= sc.points\} );
  \end{alltt}
  代わりとして、この操作に対しては一致値パターンをもつ cases文を用いることができるだろう: 
  \begin{alltt}
  GroupWinner_cases : GroupName ==> Team
  GroupWinner_cases (gp) ==
    \keyw{cases true}:
      (clear_winner(gps(gp))) -> 
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                      sc.points > sc'.points).team),

      (winner_by_more_wins(gps(gp))) ->
           \keyw{return} ((\keyw{iota} sc \keyw{in set} gps(gp) &
                     \keyw{forall} sc' \keyw{in set} gps(gp) \verb+\+ \{sc\} &
                       (sc.points > sc'.points) \keyw{or}
                       (sc.points = sc'.points \keyw{and} 
                          sc.won > sc'.won)).team),

      \keyw{others} -> RandomElement ( \{sc.team | sc \keyw{in set} gps(gp) &
                                  \keyw{forall} sc' \keyw{in set} gps(gp) &
                                   sc'.points <= sc.points\} )
    end
  \end{alltt}

\end{description}

\subsection{forループ文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{列forループ} \dsep
    \Ruleref{集合forループ} \dsep
    \Ruleref{索引forループ} \dsep \ldots
    }

  \Rule{列forループ}{
    \Lop{for}, \Ruleref{パターン束縛}, \Lop{in}, 
    \OptPt{\Lop{reverse}}, \Ruleref{式}, \lfeed
    \Lop{do}, \Ruleref{文}
    }\index{for loop}

  \Rule{集合forループ}{
    \Lop{for}, \Lop{all}, \Ruleref{パターン},
    \Lit{\keyw{in set}}, \Ruleref{式},\lfeed
    \Lop{do}, \Ruleref{文}
    }

  \Rule{索引forループ}{
    \Lop{for}, \Ruleref{識別子}, \Lit{$=$}, \Ruleref{式},
    \Lop{to}, \Ruleref{式}, \lfeed
    \OptPt{\Lop{by}, \Ruleref{式}}, \Lop{do}, \Ruleref{文}
    }

\item[意味定義:] {\it forループ文}には3種類ある。
索引を用いるforループはほとんどの高水準プログラム言語において知られているものである。
さらに、集合や列を用いる2つのforループがある。
これらは特に、集合 (または列)のすべての要素に対するアクセスが1つ1つ必要とされる場合に役立つ。

 {\it 索引forループ文} は次の形式をもつ:
  \begin{alltt}
    \keyw{for} id = e1 \keyw{to} e2 \keyw{by} e3 \keyw{do}
    s
  \end{alltt}
 ここにおいて {\tt id} は識別子、{\tt e1} と {\tt e2} はループの下限と上限を示す整数式、 {\tt e3}はステップ幅を示す整数式、そして {\tt s} は文でここで識別子 {\tt id} を用いることができる。
これは連続する文としての文 {\tt s}の評価を表すが、現文脈は{\tt id}の束縛により拡張されたものである。
このように、最初に {\tt s} が評価されるとき、 {\tt id} は下限{\tt e1}などの評価から戻ってきた値に束縛され、これは上限に達するまでつまり、 \texttt{s} $>$ \texttt{e2}となるまで同様に繰り返される。 
{\tt e1, e2} および {\tt e3} はループに入る前に評価されることに、注意したい。

 {\it 集合forループ文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{for all} e \keyw{in set} S \keyw{do}
    s
  \end{alltt}
 ここで {\tt S} は集合式である。
文 {\tt s} は、集合{\tt S}からｅの束縛で拡張され部分列の値となった現環境において評価される。

 {\it 列forループ文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{for} e \keyw{in} l \keyw{do}
    s
  \end{alltt}
ここで {\tt l} は列式である。
文 {\tt s} は、列 {\tt l}からｅの束縛と共に拡張され部分列値となった現環境で、評価される。
キーワード \keyw{reverse}が用いられる場合は、列 {\tt l}の要素は逆順にとられる。

\item[例題:] 操作 \texttt{Remove} は、数の列から与えられた1つの数のすべての出現を削除するための、 \textit{列for}ループの使用について説明している: 
  \begin{alltt}\label{removeDef}
  Remove : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove (k,z) ==
  (\keyw{dcl} nk : \keyw{seq of nat} := [];
   \keyw{for} elem \keyw{in} k \keyw{do}
     \keyw{if} elem <> z
     \keyw{then} nk := nk^[elem];
   \keyw{return} nk
  );
  \end{alltt}
  \textit{集合for}ループは、全グループの勝者集合を戻すように開発されることも可能である:
  \begin{alltt}
  GroupWinners: () ==> \keyw{set of} Team
  GroupWinners () ==
  (\keyw{dcl} winners : \keyw{set of} Team := \{\};
   \keyw{for all} gp \keyw{in set dom} gps \keyw{do}
     (\keyw{dcl} winner: Team := GroupWinner(gp);
      winners := winners \keyw{union} \{winner\}
     );
   \keyw{return} winners
   );
  \end{alltt}
次の \textit{索引for}ループの例は、古典的なバブルソートアルゴリズムである:
  \begin{alltt}
  BubbleSort : \keyw{seq of nat} ==> \keyw{seq of nat}
  BubbleSort (k) ==
    (\keyw{dcl} sorted_list : \keyw{seq of nat} := k;
     \keyw{for} i = \keyw{len} k \keyw{to} 1 \keyw{by} -1 \keyw{do}
       \keyw{for} j = 1 to i-1 \keyw{do}
         \keyw{if} sorted_list(j) > sorted_list(j+1)
         \keyw{then} (\keyw{dcl} temp:\keyw{nat} := sorted_list(j);
               sorted_list(j) := sorted_list(j+1);
               sorted_list(j+1) := temp
              );
     \keyw{return} sorted_list
     )
\end{alltt}
\end{description}

\subsection{whileループ文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{whileループ} \dsep \ldots
    }
  
  \Rule{whileループ}{
    \Lop{while}, \Ruleref{式}, \Lop{do}, \Ruleref{文}
    }

\item[意味定義:]  {\it while文} に対する意味定義は、伝統的なプログラム言語からもってきた while 文 に対応する。
 {\it whileループ\/} の形式は次のとおり:
  \begin{alltt}
    \keyw{while} e \keyw{do}
      s
  \end{alltt}
ここで、 {\tt e} はブール式、 {\tt s} は文である。
式 {\tt e} が \keyw{true} と評価される限りは、本体文 {\tt    s}が評価される。

\item[例題:] {\it whileループ}については、相対誤差 \texttt{e}内で実数 \texttt{r} の平方根を近似するニュートン法を用いた以下の例により、説明できる。
  \begin{alltt}\label{squarerootDef}
  SquareRoot : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRoot (r,e) ==
    (\keyw{dcl} x:\keyw{real} := 1,
        nextx:\keyw{real} := r;
     \keyw{while} \keyw{abs} (x - nextx) >= e * x \keyw{do}
       ( x := nextx;
         nextx := ((r / x) + x) / 2;
       );
     \keyw{return} nextx
    );
  \end{alltt}
\end{description}

\subsection{非決定文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{非決定文} \dsep \ldots
    }
  
  \Rule{非決定文}{
    \Lit{||}, \Lit{(}, \Ruleref{文},\lfeed
    \SeqPt{\Lit{,}, \Ruleref{文}}, \Lit{)}
    }

\item[意味定義:]  {\it 非決定文} は次の形式をもつ:
  \begin{alltt}
    || (stmt1, stmt2, \ldots, stmtn)
  \end{alltt}
またこれは文構成要素 {\tt  stmti} の任意の(非決定)順の実行を表すものである。
しかしながら、文構成要素は同時に実行されるものではないことを書き留めておくべきであろう。
インタープリタは、たとえその構成要素が非決定文と呼ばれたとしても、不十分決定の\footnote{インタープリタの使用者がこれらの文要素が実行される順は知らないとしても、 「プロジェクトオプション」の「乱数発生初期値」が用いられない限りは常に同じ順で実行される。}意味定義を用いるということには注意しよう。

\item[例題:] 次の
#ifdef VDMSL
状態定義
  \begin{alltt}
  \keyw{state} St \keyw{of}
    x:\keyw{nat}
    y:\keyw{nat}
    l:\keyw{seq1 of nat}
  \keyw{end}
  \end{alltt}
#endif VDMSL
#ifdef VDMPP
インスタンス変数
  \begin{alltt}
  \keyw{instance variables}
    x:\keyw{nat};
    y:\keyw{nat};
    l:\keyw{seq1 of nat};
  \end{alltt}
#endif VDMPP
を用いてバブルソートを行うために非決定文が使用できる:

  \begin{alltt}\label{sortDef}
  Sort: () ==> ()
  Sort () ==
    \keyw{while} x < y \keyw{do}
      ||(BubbleMin(), BubbleMax());
  \end{alltt}
ここで\texttt{BubbleMin}は、部分列 \texttt{l(x,...,y)}内の最小値を ``bubbles''した後に列の先頭にもってくる、また\texttt{BubbleMax}は、部分列 \texttt{l(x,...,y)}内の最大値を``bubbles''した後に列の最終索引におく。
\texttt{BubbleMin}は最小値の索引を見つけるために、最初に部分列を通して行う繰り返しにおいて働く。
この索引の内容はその後、列\texttt{l(x)}の先頭の内容と交換される。
  \begin{alltt}
  BubbleMin : () ==> ()
  BubbleMin () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find min val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) < m
       \keyw{then} ( m := l(i);
              z := i);
     -- move min val to index x
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(x);
      l(x) := l(z);
      l(z) := temp;
      x := x+1));
\end{alltt}
\texttt{BubbleMax}もまた同様に操作する。
こちらは最大値の索引を見つけるために、部分列を通して反復を行い、その後この索引の内容を部分列の最後の要素の内容と交換する。
\begin{alltt}
  BubbleMax : () ==> ()
  BubbleMax () ==
    (\keyw{dcl} z:\keyw{nat} := x;
     \keyw{dcl} m:\keyw{nat} := l(z);
     -- find max val in l(x..y)
     \keyw{for} i = x \keyw{to} y \keyw{do}
       \keyw{if} l(i) > m
       \keyw{then} ( m := l(i);
              z := i);
     -- move max val to index y
     (\keyw{dcl} temp:\keyw{nat};
      temp := l(y);
      l(y) := l(z);
      l(z) := temp;
      y := y-1));
  \end{alltt}
\end{description}

\subsection{call文}
\label{call-stmt}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{call文} \dsep \ldots
    }
#ifdef VDMSL
  \Rule{call文}{
    \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
    }
#endif VDMSL
#ifdef VDMPP
  \Rule{call文}{
    \OptPt{\Ruleref{オブジェクト指定子}, \Lit{.}}, name, \lfeed
    \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)},
    }
  \Rule{オブジェクト指定子}{
    \Ruleref{名称} \dsep
    \Ruleref{self式} \dsep
    \Ruleref{narrow式} \dsep
    \Ruleref{new式} \dsep
   \Ruleref{オブジェクト項目参照} \dsep
    \Ruleref{オブジェクト適用}
  }

  \Rule{オブジェクト項目参照}{
    \Ruleref{オブジェクト指定子}, \Lit{.}, \Ruleref{識別子}
  }

  \Rule{オブジェクト適用}{
    \Ruleref{オブジェクト指定子}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }
#endif VDMPP

\item[意味定義:]  {\it call文}は次の形式をもつ:
#ifdef VDMSL
  \begin{alltt}
    opname(param1, param2, \ldots, paramn)
  \end{alltt}
#endif VDMSL

#ifdef VDMPP
  \begin{alltt}
    object.opname(param1, param2, \ldots, paramn)
  \end{alltt}
#endif VDMPP

 {\it call文} は操作 {\tt opname}を呼び、 %
#ifdef VDMPP 
{\tt 式}というオブジェクト中で、
#endif VDMPP
その操作を評価した結果を返す。
操作はグローバル変数を扱うことができるので、 {\it call文} は関数呼出しがそうするように必ずしも値を戻す必要はない。

#ifdef VDMPP 
 {\vppsmall オブジェクト指定子} が指定される場合、それは操作 {\tt opname} が定義されているクラスのオブジェクトに対するオブジェクト参照に従わなければならない、そして操作はpublicに指定されなければならない。
{\tt オブジェクト指定子}が指定されていないのであれば、その操作は現オブジェクトにおいて呼ばれるものである。
操作がスーパークラスで定義されているのであれば、それはpublicかprotectedかで定義されていなければならない。
#endif VDMPP

\item[例題:] \mbox{} 
#ifdef VDMSL
  以下の{\tt ResetStack}操作は変数を持たず、戻り値がない。一方、{\tt PopStack}操作はトップのスタック要素を返す。
  \begin{alltt}
    ResetStack();
    ...
    top := PopStack();
  \end{alltt}
  この{\tt PopStack}は以下のように定義することが出来る:
  \begin{alltt}
    PopStack: () ==> Elem
    PopStack() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack
  \end{alltt}
  この{\tt stack}はグローバル変数である。

#endif VDMSL
#ifdef VDMPP

  以下に述べる{\tt Stack}の単純な記述について考えよう:

  \begin{alltt}
  class Stack

  instance variables
    stack: seq of Elem := [];

  operations

    \PUBLIC Reset: () ==> ()
    Reset() ==
      stack := []; 

    \PUBLIC Pop: () ==> Elem
    Pop() ==
      def res = hd stack in
       (stack := tl stack;
        return res)
    pre stack <> []
    post stack~ = [RESULT] ^ stack

  end Stack
  \end{alltt}

例の中で操作 {\tt Reset} はパラメーターをもたないし、操作 {\tt Pop}がスタックの一番上の要素を戻すのに反し値も戻さない。 
スタックは以下のように用いることができる:
  \begin{alltt}
    ( dcl stack := new Stack();
      stack.Reset();
      ....
      top := stack.Pop();
    )
  \end{alltt}
 
 以下に示すように、{\tt Stack}クラス内で操作を呼び出すことができる:   
  \begin{alltt}
    Reset();
    ....
    top := Pop();
  \end{alltt}
  
 あるいは \keyw{self}\index{self式} 参照を用いれば以下の様になる:
  \begin{alltt}
    \keyw{self}.Reset();
    top := \keyw{self}.Pop();
  \end{alltt}

#endif VDMPP
\end{description}

\subsection{return文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{return文} \dsep \ldots
    }

  \Rule{return文}{
    \Lop{return}, \OptPt{\Ruleref{式}}
    }

\item[意味定義:]  {\it return文} は操作内の式の値を戻す。
値は与えられた文脈中で評価される。
もし操作が値を返さないならば、式は省かれなければならない。
 {\it return文\/}は次の形式をもつ:
  \begin{alltt}
    return e
  \end{alltt}
または
  \begin{alltt}
    return
  \end{alltt}
 ここで式{\tt e} は操作の戻り値である。

\item[例題:]  {\tt FunCall} が関数呼出しであるの対し、以下に述べる例題 {\tt OpCall} は操作呼出しである。
 {\it if文\/}が2つに枝分かれした文だけを受け入れるため、 {\tt FunCall}は  {\it return文}を用いることで文に``変換されて''いる。
  \begin{alltt}
    \keyw{if} test
    \Keyw{then} OpCall()
    \Keyw{else} \keyw{return} FunCall()
  \end{alltt}
#ifdef VDMPP
  たとえば、前節における \texttt{stack} クラスを、スタックの先頭を検査する操作を用い拡張することが可能である：
\begin{alltt}
  \PUBLIC Top : () ==> Elem
  Top() ==
    \keyw{return} (\keyw{hd} stack);
\end{alltt}
#endif

\end{description}

\subsection{例外処理文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{always文} \dsep
    \Ruleref{trap文} \dsep
    \Ruleref{再帰trap文} \dsep
    \Ruleref{exit文} \dsep \ldots
    }

  \Rule{always文}{
    \Lop{always}, \Ruleref{文}, \Lop{in}, \Ruleref{文}
    }

  \Rule{trap文}{
    \Lop{trap}, \Ruleref{パターン束縛}, \Lop{with},
    \Ruleref{文}, \Lop{in}, \lfeed
    \Ruleref{文}
    }

  \Rule{再帰trap文}{
    \Lop{tixe}, \Ruleref{trap群}, \Lop{in}, \Ruleref{文}
    }

  \Rule{trap群}{
    \Lit{\{}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文}, \lfeed
    \SeqPt{ \Lit{,}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文} },
    \Lit{\}}
    }

  \Rule{exit文}{
    \Lop{exit}, \OptPt{\Ruleref{式}}
    }

\item[意味定義:] 例外処理文は、仕様記述のなかで例外エラーを制御するために用いられる。
このことは、仕様記述内で例外信号を送ることができなければならないことを意味する。これは {\it exit文}を用いて行うことができ、次の形式をもつ:
  \begin{alltt}
    \keyw{exit} e
  \end{alltt}
または
  \begin{alltt}
    \keyw{exit}
  \end{alltt}
 ここにおいて{\tt e} はオプションの式である。
式 {\tt e}はどのような種類の例外が起きたのかを知らせるために用いられる。

  {\it always文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{always} s1 \keyw{in}
    s2
  \end{alltt}
ここで {\tt s1} と {\tt s2} は文である。
最初に文 {\tt s2} が評価され、さらに例外が起きたかどうかにかかわらず文 {\tt s1} も評価される。
 {\it always文\/}全体の結果値は、文 {\tt s1}の評価により決定される: もしここで例外を起こせばこの値が戻される、それ以外は文 {\tt s2} の評価の結果が返される。

 {\it trap文\/} は、ある一定の条件が満たされたときに、処理文{\tt s1}を評価する唯一のものである。
これは次の形式をもつ:
\begin{alltt} 
    \keyw{trap} pat \keyw{with} s1 \keyw{in} s2 
\end{alltt}
ここで {\tt pat} はある一定の例外を選択するために用いられるパターンまたは束縛であり、 {\tt s1} と {\tt s2} は文である。
最初に文 {\tt s2}を評価するが、もし例外が発生しなければ{\tt s2}の評価結果が、 {\it trap文\/}全体の結果値となる。
例外が起きた場合には、 {\tt s2} の値はパターン {\tt pat}と一致するか調べる。
そこで一致するものがない場合、例外が{\it trap文}全体の結果値として戻され、そうでない場合は文 {\tt s1}が評価され、この評価の結果がまた {\it trap文}全体の結果値となる。

  {\it 再帰trap文\/} は次の形式をもつ:
  \begin{alltt}
    \keyw{tixe} \{
      pat1 |-> s1,
      ...
      patn |-> sn
    \} \keyw{in} s
  \end{alltt}
ここで {\tt pat1, \ldots, patn} はパターンまたは束縛であり、{\tt s, s1, \ldots,
    sn} は文である。 
最初に文 {\tt s} が評価され、もし例外が起きなければ、その結果が完全な {\it 再帰trap文}の結果として戻される。
そうでない場合、値はパターン {\tt pati}の各々に順に一致させられる。 
一致するものが見つからなかった場合、 {\it 再帰trap文}の結果として例外が戻される。
一致するものが見つかれば、対応する文 {\tt    si} が評価される。
これが例外を起こさない場合には、 {\tt si} の評価の結果値は {\it 再帰trap文}の結果として戻される。
それ以外の場合は、今度は新しい例外値( {\tt si}の評価の結果)をもとに、マッチングを再び始める。

\item[例題:] 多くのプログラムにおいて、1つの操作にはメモリーを割り当てる必要がある。
操作が完了した後には、このメモリーはそれ以上必要でなくなる。
このことは {\it always文}と共に実行される:
  \begin{alltt}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
上記の例では、 {\it always文}の本体文中で起きる可能性のある例外上では、何かを行うことはできない。
 {\it trap文\/} を用いることで、これらの例外を捉えることができる:
  \begin{alltt}
    \keyw{trap} pat \keyw{with} ErrorAction(pat) \keyw{in}
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    )
  \end{alltt}
 ここに{\it always文\/} 中で起きるすべての例外は、 {\it trap文}によって捉えられる。
数個の例外値を区別したい場合には、ネストされた {\it trap文\/} かまたは{\it 再帰trap文}を用いることができる:
  \begin{alltt}
    DoCommand : () ==> int
    DoCommand () ==
    ( \keyw{dcl} mem : Memory;
      \keyw{always} Free(mem) \keyw{in}
      ( mem := Allocate();
        Command(mem, \ldots)
      )
    );

    Example : () ==> int
    Example () ==
    \keyw{tixe}
    \{ <NOMEM> |-> \keyw{return} -1,
      <BUSY>  |-> DoCommand(),
      err     |-> \keyw{return} -2 \}
    \keyw{in}
      DoCommand()
  \end{alltt}
操作{\tt DoCommand}では、メモリー割り当て中に {\it always文\/}を用いるし、また操作{\tt Example}では、起きた例外はすべて {\it   再帰trap文\/} によって捉えられる。
値 {\tt <NOMEM>} をもつ例外は、結果として {\tt -1} の戻り値となり例外は起きない。
例外値が {\tt <BUSY>} であるならば、再び操作{\tt DoCommand}の実行を試みる。
これが例外を起こす場合には、 {\it 再帰trap文}によってまた処理が行われる。
他の例外はすべて、値 {\tt -2}を戻す結果となる。
\end{description}

\subsection{error文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{error文} \dsep
    \ldots
    }

  \Rule{error文}{
    \Lop{error}
    }

\item[意味定義:]  {\it error文} は定義されていない式に相等する。
文の結果は定義されないしこのことによりエラーが起きる、ということを明示的に述べるために用いられる。
{\it error文} が評価されるときは、インタープリタは仕様記述の実行を停止し {\it error文} が評価されたことを報告する。

エラー文の実用的な使用となると、未定義式を用いた場合なので、事前条件の場合とは異なる:  事前条件の使用とは、操作が呼ばれたときは事前条件が満たされていると保証することは呼ぶ側の責任であることを意味する；error文の使用では、エラー処理を取り扱うのは呼ばれた操作側の責任である。


\item[例題:] \pageref{squarerootDef} ページ上の操作 \texttt{SquareRoot} は、平方する数は負かもしれないという可能性を排除するものでない。
これについては操作 \texttt{SquareRootErr}で修正を行う:
  \begin{alltt}
  SquareRootErr : \keyw{real} * \keyw{real} ==> \keyw{real}
  SquareRootErr (r,e) ==
    \keyw{if} r < 0
    \keyw{then error}
    \keyw{else}
      (\keyw{dcl} x:\keyw{real} := 1;
       \keyw{dcl} nextx\keyw:{real} := r;
       \keyw{while abs} (x - nextx) >= e * x \keyw{do}
         ( x := nextx;
           nextx := ((r / x) + x) / 2;
         );
       \keyw{return} nextx
      )
  \end{alltt}
\end{description}

\subsection{恒等文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{恒等文}
    }

  \Rule{恒等文}{
    \Lop{skip}
    }

\item[意味定義:]  {\it 恒等文\/} は何の評価も行われないという信号を送るために用いられる、

\item[例題:] 第\ref{removeDef}節の操作\texttt{Remove} において、\texttt{elem=z} が明示的に述べられていない場合の \textsf{for} ループ内における操作の動き。
以下の{Remove2} がこれを示す。
  \begin{alltt}
  Remove2 : (\keyw{seq of nat}) * \keyw{nat} ==> \keyw{seq of nat}
  Remove2 (k,z) ==
    (\keyw{dcl} nk : \keyw{seq of nat} := [];
     \keyw{for} elem \keyw{in} k \keyw{do}
       \keyw{if} elem <> z \keyw{then} nk := nk^[elem]
       \keyw{else skip};
     \keyw{return} nk
    );
  \end{alltt}
ここで {\it 恒等文}を説明するために \keyw{else}選択枝 を明示的に含めたが、ほとんどの場合\keyw{else}選択枝は含まれないため {\it 恒等文\/} は暗黙に仮定されているのである。

\end{description}

#ifdef VDMPP
\subsection{start文とstartlist文}\label{sec:start}
\label{sc:startstmt}

\begin{description}
\item[構文:] 
  \Rule{文}{
    \ldots \dsep
    \Ruleref{start文} \dsep
    \Ruleref{startlist文}
    }

  \Rule{start文}{
    \Lop{start}, \Lit{(}, \Ruleref{式}, \Lit{)}}

  \Rule{startlist文}{
    \Lop{startlist}, \Lit{(}, \Ruleref{式}, \Lit{)}
  }
    
\item[意味定義:] {\it start} および {\it startlist} 文は次の形式をもつ:
  \begin{alltt}
    \keyw{start}(aRef)
    \keyw{startlist}(aRef_s)
  \end{alltt}

クラス記述がスレッドを含む場合には (第~\ref{ch:thread}節参照)、このクラスから生成される各々のオブジェクトはstand-aloneの仮想マシンとして演算を行う能力をもつ、別の言葉で言えば: オブジェクトが独自の処理能力をもつ。
この状況で、 {\it new式} は 待ち状態のままで`process' を生成する。 
 このようなオブジェクトに対し、 {\vdmpp} は前もって定義された操作に関して、これは {\it start文}を通して発動することができるものだが、待ち状態を変換して活動状態にする仕組みをもっている\footnote{オブジェクトが能動的状態にあるときには、この行動はスレッド(第~\ref{ch:thread}節参照)を用いて記述することができる 。}。

オブジェクト生成とstartの明示的な分離では、オブジェクトが記述された動作の提示をstartする{\it 以前}に(同時に起きる)システムの初期化が完了する可能性を与えているが、この方法で、まだ生成・接続されていないものとしてオブジェクトが参照されるときに起きるかもしれない問題を避けている。

start文の別の形{\it startlist文}は、多くの能動的オブジェクトを任意の順で始めるためにある。
\keyw{startlist} に対するパラメーター {\tt aRef\_s} は、スレッドを含むクラスからインスタンス化されるオブジェクトに対するオブジェクト参照の集合でなければならない。

\item[例題:] 
オペレーティングシステムの仕様記述を考えてみよう。
この構成要素は、ブート連続動作中にスタートするデーモンや他プロセスと考えられる。この見通しから、以下の定義が関連する:
\begin{alltt}
  \keyw{types}

    runLevel = \keyw{nat};

    Process = Kerneld | Ftpd | Syslogd | Lpd | Httpd

  \keyw{instance variables}
    pInit : \keyw{map} runLevel \keyw{to set of} Process
\end{alltt}
ここで \texttt{Kerneld} は他で指定されたオブジェクト参照型であり、並べられている他のプロセスも同様である。

ここで1つの操作としてのブート列をモデル化することができる:
\begin{alltt}
    bootSequence : runLevel ==> ()
    bootSequence(rl) ==
      \keyw{for all} p \keyw{in set} pInit(rl) \keyw{do}
        \keyw{start}(p);
\end{alltt}
もう1つの方法として、 ここで\texttt{startlist} 文を用いることができるであろう:
\begin{alltt}
    bootSequenceList : runLevel ==> ()
    bootSequenceList(rl) ==
      \keyw{startlist}(pInit(rl))
\end{alltt}
\end{description}
#endif VDMPP

\subsection{仕様記述文} \label{se:specification}

\begin{description}
\item[構文:] 
  \Rule{文}{
    \ldots \dsep
    \Ruleref{仕様記述文}
    }
  \Rule{仕様記述文}{
    \Lit{[}, \Ruleref{陰操作本体}, \Lit{]}
  }

\item[意味定義:] 

仕様記述文は、事前条件や事後条件で表した文で期待効果を記述するために用いることができる。
このように、操作定義に強要されることなく抽象的(暗黙の)仕様記述を許すことで、1つの文の概略を捉える。
仕様記述文は、暗黙に定義された陰操作 (第~\ref{op-def}節参照)の本体と同等である。したがって、仕様記述文を実行することはできない。

\item[例題:]  仕様記述文をバブルソートのバブル最大部を指定するために用いることができる:
  \begin{alltt}
  Sort2 : () ==> ()
  Sort2 () ==
    \keyw{while} x < y \keyw{do}
      || (BubbleMin(),
          [\keyw{ext wr} l : \keyw{seq1 of nat}
              \keyw{wr} y : \keyw{nat}
              \keyw{rd} x : \keyw{nat}
           \keyw{pre} x < y
           \keyw{post} y < y~ \keyw{and}
                permutation (l~(x,...,y~),l(x,...,y~)) \keyw{and}
                \keyw{forall} i \keyw{in set} \{x,...,y\} & l(i) < l(y~)]
         )
  \end{alltt}
 (\texttt{permutation} は、もし1つの列が他方の並び替えであるならば真を返すような、2つの列から結果をとる補助関数である。)


\end{description}

#ifdef VICEMAN
\subsection{duration文}
\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{duration文}
  }
  \Rule{duration文}{
    \Lop{duration}, \Lit{(}, \Ruleref{数字}, \Lit{)},\lfeed
    \Ruleref{文}
  }

\item[意味定義:]
duration文とは、閉ざされた文に対する内部クロックが増加するときに伝えられるToolboxのインタプリタへの
ランタイム指示である。duration文で与えられる値（自然数）は通常、その文のために計算される増分の代わりに使用されるべきである。
したがって、duration文は、Toolboxのデフォルト実行時間の計算を優先するためのメカニズムを提供する。

\item[例:]初めに単純な例を示す:
\begin{alltt}
      \keyw{while} n < 10 \keyw{do}
         \keyw{duration}(10) n := n + 1; 
\end{alltt}
この例では、閉ざされたduration文の文中で、このループが実行されないと仮定すると
文 \texttt{n := n + 1} を実行するために必要な時間を計算するよりも、
それぞれのループの繰り返しで、Toolboxは内部クロックを10秒単位で増加するだろう。

duration文が入れ子にされるなら、最外部ものが優先され、残りは無視される。例えば以下の通りである。

\begin{alltt}
      \keyw{duration}(30)(
        n := 1;
        \keyw{while} n < 10 \keyw{do}
           \keyw{duration}(10) n := n + 1; 
        )
\end{alltt}
外側のduration文は優先される。
したがって、これが閉ざされたduration文に関する文中で実行されないと仮定すると、
この文を実行するとき、インタプリタは内部クロックを30秒単位で増加させるだろう。

入れ子は操作呼び出しが原因で発生することに注意する。以下の例で考える:
\begin{alltt}
      op1 : \keyw{nat} ==> \keyw{nat}
      op1(m) ==
       \keyw{duration} (20) \keyw{return} m + 1;

      op2 : () ==> \keyw{nat}
      op2() ==
      (\keyw{dcl} n : \keyw{nat} := 3;
       \keyw{duration}(10)  n := op1(1);
       \keyw{return} n) 
\end{alltt}
\texttt{op2}を実行しているとき、もしも、\texttt{op1}への呼び出しが実行されたら、op1内のduration文は
呼び出し環境内のduration文によって優先されるだろう。
このようにして、\texttt{op2}内の文 \texttt{n := op1(1);} の実行で、内部クロックは10秒単位のみ増加する。

\end{description}

\subsection{cycles文}

\begin{description}
\item[構文:]
  \Rule{文}{
    \ldots \dsep
    \Ruleref{cycles文}
  }
  \Rule{cycles文}{
    \Lop{cycles}, \Lit{(}, \Ruleref{数字}, \Lit{)},\lfeed
    \Ruleref{文}
  }

\item[意味定義:]
cycles文とは、閉ざされた文に対する内部クロックが増加するときに伝えられるToolboxのインタプリタへの
ランタイム指示である。cycles文で与えられた値（自然数）はどのくらいのクロック周期かの目安として使われるべきである。
また通常、文のために計算される増分の代わりに、閉ざされた文は増加されるべきである。
したがって、cycles文はduration文と同様に、Toolboxのデフォルト実行時間の計算を優先するメカニズムを提供するが、
 \texttt{CPU}の速度に関する方法で、計算が行われている。

\item[例題:]初めに単純な例を示す:
\begin{alltt}
      \keyw{while} n < 10 \keyw{do}
         \keyw{cycles}(1000) n := n + 1; 
\end{alltt}
この例では、閉ざされたcycles文の文中で、このループが実行されないと仮定すると
状態 \texttt{n := n + 1} を実行するために必要な時間を計算するよりむしろ、
それぞれのループの繰り返しで、Toolboxは内部クロックを与えられた(容量に比例した) \texttt{CPU}の1000の命令を
処理するためにかかる時間によって増加するだろう。

cycles文が入れ子にされるなら、最外部ものは優先され、残りは無視される。例えば以下の通りである。
\begin{alltt}
      \keyw{cycles}(3000)(
        n := 1;
        \keyw{while} n < 10 \keyw{do}
           \keyw{cycles}(1000) n := n + 1; 
        )
\end{alltt}
外側のcycles文は優先される。したがって、これが閉ざされたcycles文に関する文中で実行されないと仮定すると、この文を実行するとき、
インタプリタは内部クロックを与えられた \texttt{CPU}上で3000の命令を実行するためにかかる時間によって増加するだろう。

入れ子は操作呼び出しが原因で発生することに注意する。以下の例で考える:
\begin{alltt}
      op1 : \keyw{nat} ==> \keyw{nat}
      op1(m) ==
       \keyw{cycles} (2000) \keyw{return} m + 1;

      op2 : () ==> \keyw{nat}
      op2() ==
      (\keyw{dcl} n : \keyw{nat} := 3;
       \keyw{cycles}(1000)  n := op1(1);
       \keyw{return} n) 
\end{alltt}
 \texttt{op2} を実行しているとき、もしも、 \texttt{op1} への呼び出しが実行されたら、 \texttt{op1} 内の
cycles文は呼び出し環境内のcycles文によって優先されるだろう。このようにして、 \texttt{op2} 内の式n := op1(1); の実行で、内部クロック
は与えられた \texttt{CPU}上のみで1000の命令を実行するためにかかる時間によって増加する。
\end{description}

#endif VICEMAN

#ifdef VDMPP
%\subsection{The Delay Statement}
%\begin{description}
%\item[Syntax:] 
%  \Rule{delay statement}{
%    \Lop{delay}, \Lit{(},expression, \Lit{)}
%  }
%
%\item[Semantics:] 
%The delay statement can be used to indicate a required delay in the
%execution of the operation; in Section~\ref{ch:rt} its use is explained
%more extensively.
%
%The {\it expression} denotes the number of system ticks during which the
%execution of the operation in which the delay statement occurs is halted.
%The delay must be a non-zero natural number.
%\end{description}


%\subsection{The Select Statement}
%
%The select statement is described in section \ref{se:proc-thread}.

\newpage
\section{トップレベル仕様記述}

ここまでの節で, 型, 式、文、関数、そして操作、という \vdmpp\ 構成要素を述べてきた。
たくさんのこれらの構成要素も、1つのクラス定義のなかでその定義を構築することができる。
トップレベル仕様記述、あるいは文書、は1つまたはそれ以上のクラス定義により構成されるものである。

\begin{description}
\item[構文:]
\Rule{文書}{
   \Ruleref{クラス} 
#ifdef VICEMAN
   \dsepl\ \Ruleref{システム}
#endif VICEMAN
   ,\SeqPt{\Ruleref{クラス}
#ifdef VICEMAN
   \dsepl\ \Ruleref{システム}
#endif VICEMAN
         }
  }
\end{description}

#ifdef VICEMAN
\subsection{システム}\label{sec:system}

\vdmpp\ での分散システムを述べることを可能にするために、
どのようにシステムモデルの部品が異なったCore Processing Units (CPUs)を分散し、
通信は、互いに接続されたCPUsを運ぶのかを述べているシステム概念を含む。
``\keyw{class}''というキーワードの代わりの``\keyw{system}'' というキーワードを除いて、構文上、
第~\ref{sec:classdep}節以下に述べられている普通のクラスのように、システムは正確に述べられる。

\begin{description}
\item[構文:] 
\Rule{システム}{
  \Lop{system}, \Ruleref{識別子},  \lfeed
  \OptPt{\Ruleref{クラス本体}}, \lfeed
  \Lop{end}, \Ruleref{識別子}
}
\Rule{クラス本体}{\Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
}
\Rule{定義ブロック}{
  \Ruleref{型定義} \dsep
  \Ruleref{値定義} \dsep
  \Ruleref{関数定義} \dsep
  \Ruleref{操作定義} \dsep
  \Ruleref{インスタンス変数定義} \dsep
%  time variable definitions \dsep
  \Ruleref{同期定義} \dsep
  \Ruleref{スレッド定義}
}

\item[意味定義:] それぞれのシステムの種類は、以下の部品を持っている:
\begin{itemize}
\item システム名を持っているシステムヘッダー
\item 任意の {\em システム本体}
\item システムテール
\end{itemize}

システムヘッダーで与えられているシステム名はクラス名の定義している存在である。
システム名は、グローバルに見える。すなわち、仕様記述内の全ての他のクラスやシステムの中が見える。

クラスヘッダーのシステム名はシステムテールの中のシステム名と同じでなければならない。
その上、定義しているシステム名は仕様記述内で一意でなければならない。

システムにおける特別なものは、暗黙のうちに\texttt{CPU}と\texttt{BUS}と呼ばれる特別に定義されたクラスを利
用することができるということである。
システムのインスタンスを作成するのが可能ではないが、 \texttt{CPU} と \texttt{BUS}で作られたインスタンスは初期化時に作成されるだろう。
 \texttt{CPU} と \texttt{BUS}はシステム定義の外側では使うことが出来ないことに注意する。

\texttt{CPU}と\texttt{BUS}のインスタンスはインスタンス変数として作られなくてはならない。
また、定義はコンストラクタを使用しなければならない。
\texttt{CPU}クラスのコンストラクタは2つの変数をもつ:
1つ目は\texttt{CPU}に使用される主要なスケジューリング方針を示す。
一方、2つ目は変数は\texttt{CPU}(Million Instructions Per SecondかMIPSとして、示される)の容量を提供する。
\texttt{BUS}クラスのコンストラクタは3つの変数を持つ。
1つ目は、BUSの種類を示す。2つ目は、BUSの容量(そのバンド幅)、最後3つ目は、
\texttt{BUS}インスタンスを与えられることによって、互いに接続された \texttt{CPU}インスタンスのセットを与える。

現在、サポートされた主要な\texttt{CPU}のスケジューリング方針は:
\begin{description}
\item[\texttt{<FP>}:] Fixed Priority
\item[\texttt{<FCFS>}:] First Come First Served
\end{description} 

現在、サポートされた主要な\texttt{BUS}のスケジューリング方針は:
\begin{description}
%\item[\texttt{<TDMA>}:] Time Division Multiple Access
\item[\texttt{<FCFS>}:] First Come First Served
%\item[\texttt{<CSMACD>}:] Carrier Sense Multiple Access with Collision 
%                          Detection
\end{description} 

\texttt{CPU}クラスは\texttt{deploy}や\texttt{setPriority}と呼ばれるメンバ操作を持っている。
\texttt{deploy}操作は一つの重要な変数を持ち、システム内部の静的インスタンス変数として宣言されるオブジェクトでなければならない。\footnote{また、将来の拡張のため、2番目のパラメタが現在無視されるとき、それは、文字列を取ることができる。}。
deploy操作の意味定義は、このオブジェクト内部のすべての機能性の実行は配置されたCPU上で行われるだろう。
\texttt{setPriority}操作は二つの変数を持つ。1つ目は、CPUに配置されたパブリックな操作名でなければならない。
2つ目は変数は自然数である。
\texttt{setPriority}操作の意味定義は、与えられた操作が与えられた優先度(2つ目の変数)を割り当てることである。
これは、固定された主要なスケジューリングが、与えられたCPU上で使用されるときに使われる。

そのシステムの``class''はそれが含むことだけできる方法で制限される:
\begin{description}
\item[インスタンス変数:] システムの``class''で宣言可能な唯一のインスタンスは、
異なったCPUへ割り当てたい異なったシステムの構成要素の静的インスタンスと同様に、
特別なクラスである\texttt{CPU}と\texttt{BUS}である。

\item[コンストラクタ:] CPUの実際のインスタンス展開と、異なった操作のための優先度の設定は、
システムの``class''に置くことができる唯一の操作であるコンストラクタの内部に設定される。
このコンストラクタの内部で使用可能な唯一の文の種類は、
特別な\texttt{deploy}と\texttt{setPriority}操作の一連の呼び出しを持ったブロック文である。

\end{description}

さらに、異なったCPUへ展開されるインスタンスのための静的な宣言の使用に関して制限がある。
もしも、インスタンスが生成されるクラスが、どんな静的操作や静的関数を含んでいても
基本的に、ユーザは唯一のインスタンスがCPUへ展開されることを確かにするべきである。
静的インスタンス変数が使用される場合、(BUS以上の通信なしで)直接アクセスされる。
つまり、これは本質的に、分布の観点から適応されない。
したがって、展開されたインスタンスの全てのインスタンス変数は操作の使用を通してのみアクセスされるべきである。

\item[例題:] システムクラスを定義した例:
\begin{alltt}
\keyw{system} Simple

\keyw{instance variables
  static public} a : A := \keyw{new} A();
  \keyw{static public} b : B := \keyw{new} B();
  -- define the first CPU with fixed priority scheduling 
  -- and 22E6 MIPS
  CPU1 : CPU := \keyw{new} CPU (<FP>, 22E6);

  \keyw{static public} c : C := \keyw{new} C();
  -- define the second CPU with fixed priority scheduling 
  -- and 11E6 MIPS
  CPU2 : CPU := \keyw{new} CPU (<FP>, 11E6);

  -- create a communication bus that links the three 
  -- CPU's together
  BUS1 : BUS := \keyw{new} BUS (<CSMACD>, 72E3, {CPU1, CPU2})

operations
  public Simple: () ==> Simple
  Simple () ==
    ( -- deploy a on CPU1
      CPU1.deploy(a);
      -- deploy b on CPU1
      CPU1.deploy(b);
      -- deploy c on CPU2
      CPU2.deploy(c,"CT"); 
      -- "CT" is a label here which is ignored
    );

end Simple
\end{alltt}

\noindent \texttt{A}、\texttt{B}および\texttt{C}がすべてクラスとして定義される場合
\end{description}
#endif VICEMAN

\subsection{クラス}
\label{sec:classdep}

標準 \vdmsl\ 言語と比べて、\vdmpp\ はクラスと共に拡張されてきた。
この節では、トップレベル仕様記述を生み出し構成するクラスの使用について記述する。
 \vdmpp\ によって提供されるオブジェクト指向機能を用いれば、次が可能である:

\begin{itemize}
\item クラスの定義とオブジェクトの生成。
\item 関連の定義とオブジェクト間リンクの生成。
\item 継承を通して行う汎化と特化。
\item 関数と操作を用いたオブジェクトの機能的動作の記述。
\item スレッドおよび同期制約を通したシステムの動的動作の記述。
\end{itemize}

実際上の機能を述べる前に、クラスというものの一般的概要を記述する。

\begin{description}
\item[構文:] 
\Rule{クラス}{
  \Lop{class}, \Ruleref{識別子}, \OptPt{\Ruleref{継承節}}, \lfeed
  \OptPt{\Ruleref{クラス本体}}, \lfeed
  \Lop{end}, \Ruleref{識別子}
}
\Rule{継承節}{
      \Lop{is subclass of}, \Ruleref{識別子}, \Lit{,}, \SeqPt{\Ruleref{識別子}}
}
\Rule{クラス本体}{\Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
}
\Rule{定義ブロック}{
  \Ruleref{型定義} \dsep
  \Ruleref{値定義} \dsep
  \Ruleref{関数定義} \dsep
  \Ruleref{操作定義} \dsep
  \Ruleref{インスタンス変数定義} \dsep
%  time variable definitions \dsep
  \Ruleref{同期定義} \dsep
  \Ruleref{スレッド定義}
}

\item[意味定義:] 各々のクラス記述は以下の構成をもつ:
\begin{itemize}
\item クラス名およびオプションである {\em 継承節}からなるクラスヘッダー部
\item オプションである {\em クラス本体}
\item クラステイル部
\end{itemize}

クラス名がクラスヘッダー部で与えられると、そのクラスの名称が定義されたことになる。 
クラス名はグローバルに見ることができる、つまり仕様記述におけるすべての他のクラスにおいても見ることができる。

クラスヘッダー部のクラス名はクラステイル部のクラス名と同じである必要がある。
 さらに、クラス名の定義は仕様記述を通して一回でなければならない。

 (オプションの)クラス本体は次から成る:
\begin{itemize}
\item  {\it 値定義} (定数)の集合
\item {\it 型定義}の集合
\item {\it 関数定義}の集合
\item クラスからインスタンス化されたオブジェクトの内部状態を記述する{\it インスタンス変数定義} の集合
状態不変条件式は推奨されるが強制されるものではない
%\item A set of {\em time variable definitions} describing
%  the internal state of an object as a function of time.
\item 内部状態上で動く {\it 操作定義} の集合
\item  {\it 同期定義}の集合で、許可述語に関してかあるいはmutex制約を用いて記述されたもの
% 各々のトレースとは、他のオブジェクトによる関数や操作の発動で与えられた列を意味する。
\item 能動的オブジェクトに対する制御スレッドを記述する {\it スレッド定義}の集合
\item テストケースを自動的に生成する場合に、一連の操作呼び出しを示すのに使う{\it traces}の集合
\end{itemize}

一般的に、1つのクラス内に定義される構成要素はすべて単一の名称を持たなければならない、たとえば同じ名称の操作と型を定義することはできない。
 しかしながら、それらの入力パラメーターの型は重複してはいないという制限のある条件下では、関数と操作の名前を {\it 多重定義する} ことが可能である(つまり、同じ名称の2つ以上の関数と同じ名称の2つ以上の操作をもつことが可能である)。
これはつまり、どの関数／操作定義が各々の関数／操作呼出しに対応しているのかを、一意に曖昧さなく決定するために、静的型チェックを使うことができるべきなのである。
このことは、あるクラスのローカルなインターフェイスにおいて定義された関数や操作に対してだけではなく、それらが継承したスーパークラスに対しても適用されることに注意しよう。
このように、たとえば多重継承を含むデザインにおいては、クラスCはクラスAからある関数をまたクラスBから同じ名前を持つ関数を継承する可能性を持つので、この関数名を含むすべての呼出しはクラスCにおいて解決可能でなければならない。 
\end{description}

\subsection{継承}\label{ch:inherit}

継承の概念は、オブジェクト指向にとって不可欠なものである。
既存クラスのサブクラスとしてのクラスを定義するとき、サブクラス定義として拡張クラスが導入されるが、これは新しく定義されるサブクラスの定義をスーパークラスの定義と共に構成するものである。

継承を通して、サブクラスはスーパークラスから次の継承をおこなう:
\begin{itemize}
\item インスタンス変数 %and time variables. 
これには、すべての不変条件および許される範囲の修正を行った上でのそれらの制限、もまた含まれる。
\item 操作定義と関数定義。
\item 値定義と型定義
\item 第\ref{ch:sync-inh}節に述べられている同期定義
%\item Its thread definitions as described in
%  Section \ref{ch:thread-inh}.
\end{itemize}

名前衝突は、同種で同じ名称をもつ2つの構成要素が異なるスーパークラスを継承する場合に起きる。
名前衝突は {\it 名前限定}を通して明示的に解決されなければならない、
つまり、スーパークラスの名前と{\vppsmall `}-記号 (バッククォート)で構成要素に接頭語をつけることによってである(第~\ref{sec:nameconflicts}節も参照)。

\begin{description}
\item[例題:] 最初の例題から、サブクラスが遂行すべきある抽象インターフェイスとしてクラス定義を用いるのに、継承を活用できることがわかる:
  \begin{alltt}
  \keyw{class} Sort

    \keyw{instance variables}
      \PROTECTED data : \keyw{seq of int}

    \keyw{operations}

      initial_data : seq of \keyw{int} ==> ()
      initial_data (l) == 
        data := l;

      sort_ascending : () ==> ()
      sort_ascending () == \keyw{is subclass responsibility};
    \keyw{end} Sort

  \keyw{class} SelectionSort \keyw{is subclass of} Sort

    \keyw{functions}

      min_index : \keyw{seq1 of nat} -> \keyw{nat}
      min_index(l) ==
        \keyw{if len} l = 1
        \keyw{then} 1
        \keyw{else let} mi = min_index(\keyw{tl} l)
             \keyw{in} \keyw{if} l(mi+1) < \keyw{hd} l
               \keyw{then} mi+1
               \keyw{else} 1

    \keyw{operations}

      sort_ascending : () ==> ()
      sort_ascending () == selectSort(1);

      selectSort : \keyw{nat} ==> ()
      selectSort (i) ==
        \keyw{if} i < \keyw{len} data
        \keyw{then} (dcl temp: \keyw{nat};
              \keyw{dcl} mi: \keyw{nat} := min_index(data(i,...,\keyw{len} data)) + 
                            i - 1;
         
             temp := data(mi);
             data(mi) := data(i);
             data(i) := temp;
             selectSort(i+1)
             )

  \keyw{end} SelectionSort
\end{alltt}
ここでクラス \texttt{Sort} は、異なるソートアルゴリズムによって遂行される1つの抽象インターフェイスを定義する。
1つの実装は、 \texttt{Selecti\-onSort} クラスで提供される。

次の例は、どのように名前空間衝突が解決されるかを明らかにする。
  \begin{alltt}
    \keyw{class} A
      \keyw{instance variables}
        i: \keyw{int} := 1;
        j: \keyw{int} := 2;
    \keyw{end} A

    \keyw{class} B \keyw{is subclass of} A
    \keyw{end} B

    \keyw{class} C \keyw{is subclass of} A
      \keyw{instance variables}
        i: \keyw{int} := 3;
    \keyw{end} C

    \keyw{class} D \keyw{is subclass of} B,C
      \keyw{operations}
        GetValues: () ==> \keyw{seq of int}
        GetValues() ==
          \keyw{return} [
            A`i, -- 1と相等
            B`i, -- 1 (A`i)と相等
            C`i, -- 3と相等
            j   -- 2 (A`j)と相等
          ]
     \keyw{end} D
  \end{alltt}
\end{description}

この例題で、クラス {\tt D} のオブジェクトは3つのインスタンス変数:{\tt A`i}, {\tt A`j}、{\tt C`j}をもつ。 
クラス {\tt D}のオブジェクトは、たとえこのクラスが {\tt B} 、{\tt C}両クラス共通のスーパークラスであるとしても、クラス{\tt A}で定義されるインスタンス変数の唯一のコピーをもつものである、ことに注意したい。
このようにクラス {\tt D} において、名称 {\tt B`j}、{\tt C`j}、{\tt D`j}、{\tt j} はすべて同じ変数{\tt A`j}を参照している。
さらに変数名称 {\tt i} は、クラス {\tt B} とクラス {\tt C}では異なる変数を参照するので、クラス {\tt D}において曖昧であるということに注意すべきである。

\subsection{クラス要素のインターフェイスと利用可能性}\label{ch:interface}

\vdmpp\ では、クラス内の定義は次のように区別される:

\begin{description}
\item[クラス属性:] 場合によってはどんなにたくさん(ゼロの可能性もあるが)そのクラスのインスタンスが生成されたとしても、唯1つ具体化されるクラスの1属性
 \vdmpp\ におけるクラス属性は、C++ や Java のような言語における {\tt static} クラス要素に相等する。
クラスの (静的)属性は、属性名称にクラス名称に{\vppsmall `}-記号 (バッククォート)を伴った接頭辞をつけることで、参照することができる、
したがって、たとえば{\tt ClassName`val}は {\tt ClassName}クラスで定義された {\tt val} 値を参照する。

\item[インスタンス属性:] クラスの各インスタンスに対して1つの実現が存在する属性。
したがって、1つのインスタンス属性は1つのオブジェクト内でのみ有効であり、また各々のオブジェクトはインスタンス属性の独自のコピーをもつ。
(静的でない)インスタンス属性は、属性の名称にオブジェクトの名称とドットを接頭辞としてつけて参照できるので、たとえば {\tt object.op()} は、{\tt object} と表記されたオブジェクトで操作 {\tt op} を起動する( ただし\texttt{op} は  \texttt{object}に見えるものとして提供されているとする)。
\end{description}

あるクラス内で関数、操作、インスタンス変数、そして定数\footnote{実際には、定数は一般的に静的となる -- 静的でない定数であれば、値がクラスの1つのインスタンスからもう1つへと変化することもある定数を表記することとなり、インスタンス変数を用いる方がより自然であろう。} は、クラス属性かまたはインスタンス属性である可能性がある。
このことはキーワード \keyw{static}で示されている:もし宣言にキーワード \keyw{static} が先行するならばクラス属性が記述されていて、そうでないならばインスタンス属性が記述されている。

他のクラス構成要素については以下に述べるように、既定で常にクラス属性かインスタンス属性かどちらかとなっている:

\begin{itemize}
\item 型定義は常にクラス属性である。
%  Thus, they can be quoted directly in a class. E.g.\ {\tt
%    ClassName`val} refers to the value {\tt val} defined in 
%  class {\tt ClassName}.
% \item Function and operation definitions are instance
%   attributes.  Thus, they are quoted in objects. E.g.\ {\tt
%   object.op()} invokes the operation {\tt op} in the object denoted by
%   {\tt object} (provided that \texttt{op} is visible to \texttt{object}).
% \item Instance variables %and time variables 
%   are instance
%   attributes. Thus, each object has its own copy
%   of the instance %and time 
%   variables.
\item スレッド定義は常にインスタンス属性である。したがって、各能動的オブジェクトは自分自身のスレッドを1つまたは複数もつ。
\item 同期定義は常にインスタンス属性である。したがって各オブジェクトは生成されたときの自分自身の``履歴''をもつ。
\end{itemize}

加えて、クラス要素のインターフェイスやまたアクセスしやすさは、アクセス記述子、 \keyw{public}、\keyw{private}、また \keyw{protected}のうちのいずれか1つを用いることで明示的に定義することもできる。
これらの指定子の意味は次の通り：
\begin{description}
\item[\keyw{public}:] どのクラスでもそれらの要素を用いてよい
\item[\keyw{protected}:] 現クラスのサブクラスのみがそれらの要素を用いてよい
\item[\keyw{private}:] 次以外でそれらの要素を用いてはいけない - これらを指定したクラスの中でのみ用いてよい。
\end{description}

どのクラス要素に対しても既定のアクセスは \textbf{private}である。
これは、ある要素にアクセス指定子が与えられていない場合はprivateとなるということである。

このことは \ref{table:access}表にまとめられている。
ここでは少しの但書きを付け加える: 
\begin{itemize}
\item インスタンス変数に対してアクセスを容認する(つまり\keyw{public} や \keyw{protected}というアクセス指定子を与えることで)ということは、読み込みと書き出し両方のアクセスをこれらのインスタンス変数に与えるということである。
% ***** Change this in the future if o.v := expr is possible
\item パブリックなインスタンス変数は、ドット(オブジェクトインスタンス変数に対して)やバッククォート記号(クラスインスタンス変数に対して)を用いて読み込み(書き出しは行えない)が行える、たとえばオブジェクト\texttt{o} のパブリックインスタンス変数 \texttt{v}は \texttt{o.v}としてアクセスすることが許されている。
\item アクセス指定子は型、値、関数、そしてインスタンス変数定義といっしょの場合のみ用いることが許されている；ただしスレッドや同期定義と共に用いることはできない。\item クラス属性をインスタンス属性にしたりその逆を行うことはできない。
\item 継承されたクラスにとっては、サブクラスに対するインターフェイスとは、サブクラス内の新しい定義と共に拡張されたそのスーパークラスに対するインターフェイスと同じである。
\item 継承された要素へのアクセスはそれ以上に制限を加えられることはない、たとえばスーパークラスにおけるパブリックインスタンス変数は、サブクラス中のプライベートなインスタンス変数として再宣言されることはない。
\end{itemize} 

\begin{table}
\begin{center}
\begin{tabular}{|l|c|c|c|}\hline
                 & \keyw{public} & \keyw{protected} & \keyw{private}\\ \hline
クラス内 & $\surd$       & $\surd$          & $\surd$ \\
サブクラス内    & $\surd$       & $\surd$          & $\times$\\
任意の 
外部クラス内   & $\surd$       & $\times$         & $\times$ \\
\hline
\end{tabular}
\end{center}
\caption{アクセス指定子意味定義のまとめ}\label{table:access}
\end{table}
\begin{description}
\item[例題] 以下の例においては、クラス要素に対する既定アクセスと同様に、異なるアクセス指定子の使用が示されている。
説明は定義中のコメントでなされている。
\begin{alltt}
\keyw{class} A

  \keyw{types}
    \PUBLIC Atype = <A> | <B> | <C>

  \keyw{values}
    \PUBLIC Avalue = 10;

  \keyw{functions}
    \PUBLIC compare : \keyw{nat} -> Atype
    compare(x) ==
      \keyw{if} x < Avalue
      \keyw{then} <A>
      \keyw{elseif} x = Avalue
      \keyw{then} <B>
      \keyw{else} <C>
 
  \keyw{instance variables}
    \keyw{public} v1: \keyw{nat};
    \keyw{private} v2: \keyw{bool} := false;
    \keyw{protected} v3: \keyw{real} := 3.14;

  \keyw{operations}
    protected AInit : \keyw{nat} * \keyw{bool} * \keyw{real} ==> ()
    AInit(n,b,r) ==
      (v1 := n;
       v2 := b;
       v3 := r)
\keyw{end} A

\keyw{class} B \keyw{is subclass of} A

  \keyw{instance variables}
    v4 : Atype -- Aから継承

  \keyw{operations}

    BInit: () ==> ()
    BInit() ==
      (AInit(1,true,2.718); --OK: スーパークラスの
                            -- protected要素にアクセス可能
       v4 := compare(v1);   --OK なぜなら v1 が publicである
       v3 := 3.5;           --OK なぜなら v3 はprotectedであり
                            -- Aのサブクラスである
       v2 := \keyw{false}   --illegal なぜなら v2 は
                            -- Aに対しprivateである
      )

\keyw{end} B

\keyw{class} C

  \keyw{instance variables}
    a: A := \keyw{new} A();
    b: B := \keyw{new} B();


  \keyw{operations}

    CInit: () ==> A`Atype   --型はクラス属性である
    CInit() ==
      (a.AInit(3,\keyw{false},1.1);  
                            --illegal なぜなら AInit は
                            -- protectedである
       b.BInit();           --illegal なぜなら BInit は(既定で)
                            -- privateである
       let - = a.compare(b.v3) in skip;
                            --illegal なぜなら
                            -- CはAのサブクラスではなく
                            -- したがって b.v3 は不可である
       \keyw{return} b.compare(B`Avalue)
                            --OK なぜならcompare は
                            -- publicインスタンス属性であり
                            -- Avalue は Bにおいて
                            -- publicクラス属性である
      )

\keyw{end} C
\end{alltt}
%       b.v1 := 4;           --OK since v1 public in A so is 
%                            --public by inheritance
  


\end{description}

\section{同期制約}\label{ch:sync}

一般的にシステム全体は、(それらの操作が発動されたときにだけ反応する)受動特性のオブジェクトとシステムに`命を吹き込む'能動的オブジェクトを含むものである。
これらの能動的オブジェクトは、それ自身で処理を行う制御スレッドをもち仮想マシンのように動作するうえに、スタートした後もその行動を継続するための他オブジェクトとの相互作用を必要としない。
別の用語法を用いれば、システムは受動的あるいは能動的なサーバーのサービスを要求するたくさんの能動的クライアントから成り立つ、という記述もできるであろう。
このような並列的な環境においては、サーバーオブジェクトは内部の一貫性を保証できる、つまりそれらの状態の不変条件を保守できるような、同期制御を必要とする。
それゆえ並列世界では、受動的オブジェクトは操作を入口とするHoareのモニターのように動作することが必要である。

(同時に能動的な制御スレッドはただひとつであるような)連続システムが記述される場合には、一般特性の特殊な場合のみがとりあげられ余分な構文は必要とされない。
しかしながら、仕様記述から実装への開発の道筋においては、より多くの相違が現れてきそうである。

以下の各オブジェクトに対する既定の同期規則が、 {\vdmpp}においては適用される:
\begin{itemize}
\item 操作は、呼び出す側にたてば、たとえ原子的であっても見えるものでなければならない;
\item 対応する許可述語をもたない操作は、制約を全く受けないこととなる;
\item 同期制約は、オブジェクト内の呼出し(オブジェクト内のある操作がそのオブジェクト内のもうひとつの操作を呼び出すもの)とオブジェクト外の呼出し(ひとつのオブジェクトのある操作からもうひとつのオブジェクトの操作を呼び出すもの)とに等しく適用される;
\item 操作発動では、2つの能動的オブジェクトが含まれる場合にランデブー(Adaにおけるものと同じ、\cite{adalrm}を参照) の意味定義をもつ。
オブジェクト $O_1$ がオブジェクト$O_2$内の操作 $o$ を呼ぶ場合に、もしオブジェクト $O_2$が現在は操作 $o$ をスタートすることができないでいるならば、 $O_1$ が操作が実行され得るときまでブロックする。
このように呼び出し側のオブジェクトと呼び出されるオブジェクトの双方が準備できたときに、発動は起きる。
(ここではAdaの意味定義との微小な相違に注意: Ada ではランデブーへの両方の当事者が実効オブジェクトである;  \vdmpp においては呼出した当事者のみ実効がある)
\end{itemize}
クラス記述における同期定義ブロックは、上記の既定を上書きする方法をユーザーに提供する。

\begin{description}
\item[構文:] 
  \Ruledef{同期定義}{
    \Lop{sync}, \OptPt{\Ruleref{同期}}
  }
  \Rule{同期}{
    \Ruleref{許可述語}
  }

\item[意味定義:] 

同期は \vdmpp においては許可述語を用いて記述される。

\end{description}


\subsection{許可述語}
\label{sec:permissionpred}

以下は、同時に呼び出し可能な操作の実行を受け入れるための規則を述べた構文である。これらの特徴を説明するいくつかの記述がなされている。

\begin{description}
\item[構文:] 
  \Rule{許可述語}{
    \Ruleref{許可述語}, \SeqPt{\Lit{;}, \lfeed
    \Ruleref{許可述語}}
  }
\Rule{許可述語}{
      \Lop{per}, \Ruleref{名称},
      \Lop{=$>$}, \Ruleref{式} \dsep
      \Ruleref{排他制御述語}}

\Rule{排他制御述語}{
       \Lop{mutex}, \Lit{(}, \Lop{all}, \Lit{)}  \dsep
       \Lop{mutex}, \Lit{(}, \Ruleref{名称リスト} \Lit{)}}

\item[意味定義:] 要求された操作の実行を受け入れる許可は、その形式の(deontic)許可述語における保護条件に従う:

\begin{quote}
{\vppsmall per} {\em 操作名称} {\vppsmall =>} {\em 保護条件}
\end{quote}

許可を表現するのに含意を用いるのは、保護条件(式)が真であることが発動のために必要条件ではあるが十分条件ではない、ということを意味する。
もし保護条件が偽であるならば許可なしである、というところから始まるとして、許可述語を読みとるべきである。
この方法で許可を表現することで、サブクラスへの継承を通しての矛盾のリスクなしに、さらに同様の制約が加えられることを許している。
ここにすべての操作に対する既定が存在する:

\begin{quote}
{\vppsmall per} {\em 操作名称} {\vppsmall => true}
\end{quote}

しかしある操作に対して許可述語が指定された場合には、この既定は上書きされる。

保護条件は概念上次のように分類される:
\begin{itemize}
\item
過去のイベントへの依存を定義する{\em 履歴保護}、
\item
オブジェクトのインスタンス変数に依存する{\em オブジェクト状態保護}、そして
\item
オブジェクトによるサービスをまつ操作発動(メッセージ)により形成されたキューの状態に依存する {\em キュー条件保護}。
\end{itemize}
これらの保護は自由に混在させることができる。
\textbf{注意} したいのは、これらの保護の間に\textit{構文的な}相違はない - すべて式である。ただし意味定義レベルで区別することは可能だ。

 排他制御述語は、クラスのすべての操作が相互に排他的に実行されるべきか、または一連の操作が互いに相互に排他的に実行されるべきか、をユーザーが指定することを許す。1つの 排他制御述語内に現れる操作は、同様に他の排他制御述語内にも現れることが許され、さらに通常の許可述語において用いられることも可能である。
各々の 排他制御述語は、名称リストで述べられた各々の操作に対する履歴保護を用いることで、暗黙に許可述語に翻訳されるであろう。 
たとえば、 
\begin{alltt}
\keyw{sync}
  \keyw{mutex}(opA, opB);
  \keyw{mutex}(opB, opC, opD);
  \keyw{per} opD => someVariable > 42;
\end{alltt}
これは以下のような許可述語に翻訳される: 
\begin{alltt}
\keyw{sync}
  \keyw{per} opA => #active(opB) = 0;
  \keyw{per} opB => #active(opA) = 0 and
          #active(opC) + #active(opD) = 0;
  \keyw{per} opC => #active(opB) + #active(opD) = 0;
  \keyw{per} opD => #active(opB) + #active(opC) = 0 and
          someVariable > 42;
\end{alltt}

各操作に対して1つの許可述語のみが許されることに注意しよう。
\texttt{\#active} 演算子は以下で説明される。

 \keyw{mutex(all)}制約は、そのクラス \textit{およびスーパークラス} 内において記述された操作すべてが、相互に排他的に実行されるべきであることを指定する。
\end{description}


\subsubsection{履歴保護}
\begin{description}
\item[意味定義:] 履歴保護とは、履歴式に関して式化されたオブジェクト操作の初期発動の列に依存する保護である (第\ref{sec:historyexpr}節参照)。
履歴式は操作の発動と完了の数を表示するが、それぞれは関数{\tt \#act}と {\tt \#fin}として与えられる。 

\begin{quote}
{\tt \#act}: 操作名称 $\rightarrow$ $\Nat$ \\
{\tt \#fin}: 操作名称 $\rightarrow$ $\Nat$ 
\end{quote}

そのうえ、{\tt \#active(}{\tt A}{\tt )} $=$ {\tt \#act(}{\tt A}{\tt )} $-$
{\tt \#fin(}{\tt A}{\tt )}といった導出された関数 {\tt \#active} が利用できることで、 {\tt A}の現在発動中のインスタンス数が得られる。 
もう1つの履歴関数 - \texttt{\#req} - は第\ref{queuesec}節で定義される。
\item[例題:]
10 の同時接続を支える能力を持ちさらに100 の要求を保持できる Webサーバー\label{example:webserver} を考える。 
この場合、URL からローカルなファイルへの写像を表す1つのインスタンス変数をもつことになる:
\begin{alltt}
  \keyw{instance variables}
    site_map : \keyw{map} URL \keyw{to} Filename := \{|->\}
\end{alltt}

以下に述べる操作はこのクラス中に定義される (簡略のため定義は省略):

\begin{tabular}{lll}
\texttt{ExecuteCGI:} & \texttt{URL ==> File} &  CGI スクリプトをサーバー上で実行させる\\
\texttt{RetrieveURL:} & \texttt{URL ==> File} & htmlのページを送る\\
\texttt{UploadFile:} & \texttt{File * URL ==> ()} & サーバー上にファイルをアップロードする\\
\texttt{ServerBusy:} & \texttt{() ==> File} & ``server busy'' ページを送る\\
\texttt{DeleteURL:} & \texttt{URL ==> ()} & 不要ファイルを取り除く\\
\end{tabular}

サーバーは 10 の同時接続だけは保持することができるので、すでに発動されている数が10に満たない場合は、実行または回復の操作が発動される許可だけは与えられる:
\begin{alltt}
    per RetrieveURL => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
    per ExecuteCGI  => #active(RetrieveURL) +
                       #active(ExecuteCGI) < 10;
\end{alltt}

\end{description}

\subsubsection{オブジェクト状態保護}
\begin{description}
\item[意味定義:] 
オブジェクト状態保護は、オブジェクト自身の1つ(またはそれ以上)のインスタンス変数の値に依存するブール式である。
オブジェクト状態保護は操作である事前条件とは異なり、そこにおいて許可述語が偽である操作の呼出しは、その述語が条件を満たすまで呼出しはブロックされる結果となる。一方で、事前条件が偽となる操作の呼出しとは、その操作の行動は指定されていないことを意味する。

\item[例題:] 
webサーバーの例を再び用いるが、いくつかのファイルがすでに存在する場合にファイル削除のみを許可することができる:
\begin{alltt}
    per DeleteURL   => dom site_map <> \{\}
\end{alltt}

スタックオブジェクトにおいて操作 {\tt Push} および {\tt Pop}を安全に実行するための制約は、次のようなオブジェクト状態保護を用いて式化できる:
\begin{alltt}
    \keyw{per} Push => length < maxsize;\\
    \keyw{per} Pop => length > 0
\end{alltt}
ここでの {\tt maxsize} と {\tt length} はスタックオブジェクトのインスタンス変数である。

たとえば次はスタックの空状態であるが、履歴結果としてこのような制約を式化することが多くの場合に可能である:
\begin{alltt}
    length = 0 <=> \keyw{\#fin}(Push) = \keyw{\#fin}(Pop)
\end{alltt}
ただしサイズというのは、特定のスタックインスタンスのプロパティとしてよくみなされるが1つのプロパティであるので、このような場合は、履歴の結果を保存する利用可能なインスタンス変数を用いる方がより洗練されている。

%In replacing history expressions by state based ones, however,
%it should be remembered, that the change of a state value which
%results from an action, defined in a post-condition, may not occur as
%the last action of the corresponding operation.
%
%Furthermore, object state guards may only be used if mutual exclusion
%is specified in addition for all operations in order to avoid problems
%with possible simultaneous access to the instance variables.
\end{description}


\subsubsection{キュー条件保護}\label{queuesec}
\begin{description}
\item[意味定義:] 
キュー条件保護は、操作の実行のために列をなして待つ要求のもとで働く。
これは第3の履歴関数 {\tt \#req}の使用を必要とするが、{\tt \#req(A)}は操作{\tt A}の実行を要求したオブジェクトが受け取る伝達の数を数えるものである。
再び以下の関数 {\tt \#waiting} を導入することが有効だ:
これはキューの項目数を数える。

\item[例題:] 
再びwebサーバーで、もし100あるいはそれより多くの接続が待ち状態にある場合に、\texttt{ServerBusy}操作を発動することだけが可能である:
\begin{alltt}
    \keyw{per} ServerBusy  => #waiting(RetrieveURL) 
                      + #waiting(ExecuteCGI) >= 100;
\end{alltt}

このようなキュー状態関数を含む式の最も重要な用い方に、操作間での優先順位を式化するための使用がある。 
次にプロトコルを示す:
%mutex(A,B) $\wedge$ per B \kw{=>} \#req(A) = 0
\begin{alltt}
    \keyw{per} B => \keyw{\#waiting}(A) = 0
\end{alltt}
これは{\tt A}の起動を待つ要求に対して優先権を与える。
しかしながら、操作派遣が要求待ち状態に依存する場合、多くの他の状況が存在する。
要求到着時刻に基づく操作選択指示を許可するための、あるいは`次に最も不足するジョブ'行動を記述するための、要求キューの全記述がこれからの開発に委ねられている。

 \texttt{\#\keyw{req}(A)} は操作\texttt{A}の初動に対する許可述語の評価では、値1をもつことに注意しよう。
これは、次のようにすれば常にブロックするであろう。

\begin{alltt}
   \keyw{per} A => \keyw{\#req}(A) = 0
\end{alltt}

\end{description}

\subsubsection{保護の評価}

前の例を用いて、次の状況を考えよう: つまり webサーバーはすでに 10 \texttt{RetrieveURL} の要求に対処している。
これらの要求を処理する間に、更に2つの \texttt{RetrieveURL}要求 (オブジェクト $O_1$ と $O_2$から) と 1つの \texttt{ExecuteCGI} 要求(オブジェクト $O_3$から)を受けた。
これら2つの操作に対する許可述語は、発動中の\texttt{RetrieveURL}操作数がすでに10なので、偽である。
このようにこれらのオブジェクトはブロックをおこなう。

その後、起動中の \texttt{RetrieveURL}操作の1つが完了へと到達する。
そこまで $O_1$、$O_2$、$O_3$をブロックしていた許可述語が、同時に ``真''となるであろう。
ここで疑問がおきる: どのオブジェクトが先に進むことを許されるのであろうか？またはそれらすべてもなのか？ 

保護式はイベントが起きたとき(この場合 \texttt{RetrieveURL} 操作の完了時)のみ、再評価される。
それに加えて、あるオブジェクトによる許可述語のテストおよび(潜在する)発動は、原子的な操作である。
このことは、最初のオブジェクトがその保護式を評価するとき、真であることを発見し相応の操作(この場合は\texttt{RetrieveURL} または\texttt{ExecuteCGI})を発動するであろう、ということを意味する。
保護式を評価する他のオブジェクトはその後、\texttt{\#active(RetrieveURL) + \#active(ExecuteCGI) = 10}であること、またこのようにいまだにブロックされていることを発見するであろう。
 \textit{どのオブジェクトが最初に保護式の評価を許されるかは未定義である。}

発動時にのみ保護式を\textsf{真} と評価しなければならないことを理解することが重要である。
例の中では、$O_1$、$O_2$、$O_3$ の要求が発動されるやいなやその保護式は再び偽となる。


\subsection{同期制約の継承}
\label{ch:sync-inh}

スーパークラスにおいて記述された同期制約は、そのサブクラスにおいて継承される。
これを行う方法はある種の同期に依存するものである。

\subsubsection{排他制御制約}
基底クラスおよび派生クラスからの排他制御制約は簡単に加えられる。
もし基底クラスおよび派生クラスが各々で排他制御定義 {$M_{A}$} と {$M_{B}$}をもつ場合は、派生クラスはすんなりと排他制御制約 {$M_{A}$}と{$M_{B}$}の両方をもつことになる。
実際の操作に対する操作名称の束縛は、常に制約が定義されたクラス内で行われる。
そのために、スーパークラスで定義されサブクラスで継承された\keyw{mutex(all)} 制約は基底クラスからの操作を相互に排他的にすることのみを行い、派生クラスの操作に影響を与えることはない。

排他制約の継承は、許可述語に対する継承図式に全体的に類似している。
内部的には排他制約は常に拡張されて適当な許可述語となり、1つの結合として存在する許可述語に加えられる。
この継承図式では、排他制御定義が基底クラス中で拡張されて許可述語として継承されているか、または、排他制御定義が排他制御定義として継承され派生クラスでのみ拡張されているかにかかわらず、結果は同じであることを保証するものである。

同期制約を現在行われている方法で継承するということは、どのような派生クラスも少なくとも基底クラスの制約を満たす、ということを保証することである。
それに加えて、同期制約を強化することも可能である必要がある。
以下に述べる例のように、派生クラスが新しい操作を追加する場合にこのことが必要となる可能性がある:
\begin{alltt}
  \keyw{class} A 
    \keyw{operations}
    
      writer: () ==> () \keyw{is not yet specified}
    
      reader: () ==> () \keyw{is not yet specified}
    
    \keyw{sync}
       \keyw{per} reader => \keyw{\#active}(writer) = 0; 
       \keyw{per} writer => \keyw{\#active}(reader, writer) = 0; 
  \keyw{end} A

  \keyw{class} B \keyw{is subclass of} A 
    \keyw{operations}

      newWriter: () ==> () \keyw{is not yet specified}

    \keyw{sync}
       \keyw{per} reader => \keyw{#active}(newWriter) = 0; 
       \keyw{per} writer => \keyw{#active}(newWriter) = 0; 
       \keyw{per} newWriter => \keyw{#active}(reader, writer, newWriter) = 0; 

  \keyw{end} B
\end{alltt}

クラス \texttt{A} は、多重読込み単一書出しプロトコルを指定する許可述語を含み、読込みと書出しの操作を実装する。
派生クラス \texttt{B} は \texttt{newWriter}を追加している。
決定動作を確定するために、 \texttt{B} は更に継承された操作に対する許可述語を追加しなければならない。

派生クラスにおける実際の許可述語は、そのため次のようになる:
\begin{alltt}
  \keyw{per} reader => \keyw{\#active}(writer)=0 and \keyw{\#active}(newWriter)=0; 
  \keyw{per} writer => \keyw{\#active}(reader, writer)=0 and \keyw{\#active}(newWriter)=0;
  \keyw{per} newWriter => \keyw{\#active}(reader, writer, newWriter)=0;
\end{alltt}

あるサブクラスが基底クラスからの操作を上書きしたときには、特殊な状況が起こる。
操作の上書きは新しい操作として扱われる。
1つでもサブクラスで定義されないかぎり、許可述語をもたない(特別な継承においてももたない)ことになる。

上書された操作に対する排他制御制約を継承することの意味定義は、全体として次のことと類似する：新しく定義された上書き操作は、基底クラス中の同じ名称の操作に対する排他制御定義によって制限されることはない。
 \keyw{mutex(all)} 省略形は、すべての継承されたまたはローカルに定義された操作を相互に排他的にするものである。
上書きされた操作(基底クラスで定義されたもの)はなんら影響をうけない。 
言いかえれば、すべての操作、つまり限定されない名称で呼ばれる可能性のあるもの(``ローカルに見える操作'')は互いに排他制御となる。


\section{スレッド}\label{ch:thread}

{\em スレッド}部をもつクラスからインスタンス化されたオブジェクトを、{\em 能動的} オブジェクトと呼ぶ。
現クラス内にあるインスタンス変数と操作のスコープは、スレッド記述にまで拡張するものと考えられる。

\begin{description}
\item[構文:]  \Ruledef{スレッド定義}{ \Lop{thread},
\OptPt{\Ruleref{スレッド定義}} } \Rule{スレッド定義}{
#ifdef VICEMAN
    \Ruleref{周期スレッド定義} \dsep 
#endif VICEMAN
    \Ruleref{手続きスレッド定義} }
\end{description}

サブクラスはスーパークラスからスレッドを継承する。
あるクラスが複数のクラスから継承をおこなっている場合には、それらのクラス中の1つだけは自身のスレッドを(もしかすると継承によって) 宣言しているかもしれない。 
さらに、あるサブクラス中で明示的にスレッドを宣言することは、何らかの継承されたスレッドを上書きすることになる。

#ifdef VICEMAN
\subsection{周期スレッド定義}\label{se:periodic-thread}

周期スレッド定義は、あるスレッド内の活動を記述する暗黙の方法とみなすことができる。

\begin{description}
\item[構文:] 
  \Ruledef{周期スレッド定義}{
    \Ruleref{周期義務}
  }
  \Ruledef{周期義務}{
    \Lop{periodic},\Lit{(}, \Ruleref{数字},
    \Ruleref{数字}, \Ruleref{数字}, \lfeed \Ruleref{数字}, 
    \Lit{)}, \Lit{(}, \Ruleref{名称}, \Lit{)}
  }

\item[意味定義:] 
それぞれの周期的なスレッドに関して、4つの異なった番号が使用されている。それらは出現の順になっている: 

\begin{enumerate}
\item \textbf{period:} これは、負またゼロでない値であり、
厳密に周期的なイベントの流れ(jitter = 0)で2つの隣り合ったイベント間の時間間隔の長さを述べる
\item \textbf{jitter:} これは、負でない値であり、単一のイベントの周りで許されている時間の変化量を述べる
その間隔はバランスのとれていると仮定する[-j、j]
jitterは特徴付けるための周期より大きくなることを、いわゆるevent burstsを許すことに注意する
\item \textbf{delay:} これは、2つの隣り合ったイベント間の到着距離の内部における最小値を示すために使われる
周期よりも小さい負でない値である
\item \textbf{offset:} これは、負でない値であり、イベントの流れが始まった最初の周期の時間値の絶対値を示すために使われる
最初のイベントはその間隔[offset, offset+ jitter]で発生することに注意する
\end{enumerate}

1つの定義された時間単位 $\Delta$Tが与えられているとすると、周期義務をもつスレッドが 長さが{\em 周期}の各時間間隔の最初に、記載された操作を発動する。
これは操作の周期的実行を生み出し、インスタンス変数、パラメーター値、もしかしたら操作発動を通して得るその他の外部値も含めた値間で保持されるべき永続関係に、不連続な等価を与える役を演じているのである。 
この間隔の長さを動的に変えることはできない。

周期義務は、たとえば(転写関数などの)公式中の値間のアナログな物理的な関係やそれらの離散イベントのシミュレーションなどを、記述することを意図している。
操作の実行時間は少なくとも用いられている周期時間の長さより小さいものであることを保障するのが、実装上要求されることの1つである。
他の操作が存在する場合は、内部的にも用いられ外部からの発動に対しても利用される時間断片について判断をくだすことにより、これらの他の操作の発動に対する公平な基準が保持されることを、ユーザーが保証しなくてはならない。

周期スレッドは、対応するクラスのインスタンスが生成されたときには、  生成されても始まっても\textit{いない}。
そのかわりスタート文は、手続きスレッドと同様、周期スレッドとともに用いられるべきである。

\item[例題:]
自分自身のスレッド中にあって周期的に時計を進めるタイマークラスを考えよう。 
これはスタートの操作をはじめ、計測のストップ、さらに現時刻の読出しを提供する。

\begin{alltt}
  \keyw{class} Timer
\end{alltt}

タイマーは、現時刻およびタイマーが活動中か否かを示すフラグという2つのインスタンス変数をもつ (現時刻のみはタイマーの活動中に増加する)。
\begin{alltt}
  \keyw{instance variables}
  curTime : \keyw{nat} := 0;
  active  : \keyw{bool} := \keyw{false};
\end{alltt}

タイマーは、それ以上の説明は不要の素直な操作を提供する。
\begin{alltt}
  \keyw{operations}
  public Start : () ==> ()
  Start() ==
    (active := \keyw{true};
     curTime := 0);

  public Stop : () ==> () 
  Stop() ==
    active := \keyw{false};

  public GetTime : () ==> nat
  GetTime() ==
    \keyw{return} curTime;

  IncTime: () ==> ()
  IncTime() ==
    \keyw{if} active
    \keyw{then} curTime := curTime + 100;
\end{alltt}

このタイマーのスレッドは、現時刻が増加していることを保証する。 これが行われる期間は1000秒単位である。
許容jitterは10秒単位であり、2つのインスタンス間の最小間隔は200秒単位である。そして、最終的にオフセットは全く使用されない。
%このタイマーに対して、10システム単位時間に相当する1単位時間を設定する。

\begin{alltt}
  \keyw{thread}
  \keyw{periodic}(1000,10,200,0)(IncTime)

\keyw{end} Timer
\end{alltt}

\end{description}
#endif VICEMAN

\subsection{手続きスレッド定義}\label{se:proc-thread}

手続きスレッドは、 {\em 文}の使用を通して活動中のオブジェクトの外部動作を陽に定義する仕組みを提供するが、そのオブジェクトがスタートしたときに実行されるものである (第 \ref{sec:start}節参照)。  
%Apart from the statements which are allowed
%in operation bodies (as described in  section \ref{sec:stmt}), it is
%also possible to use {\em answer statements} and {\em select
%statements}.
%based on similar constructs in the language {\small
%POOL}~\cite{Boer91}.
%These allow conditional behaviour within the thread depending on the
%environment.  An answer statement explicitly states that the object
%executing it is prepared to execute a (set of) operation(s).  A select
%statement specifies the conditional execution of operations.

\begin{description}
\item[構文:]  
  \Ruledef{手続きスレッド定義}{
    \Ruleref{文} } 

%  \Rule{select statement}{ 
%    \Lop{sel}, 
%    \Lit{(},
%    \Ruleref{guarded command}, \lfeed 
%    \SeqPt{\Lit{,}, 
%          \Ruleref{guarded command}}, 
%    \Lit{)} 
%  } 

%  \Rule{guarded command}{
%    \OptPt{\Ruleref{expression}}, 
%    \OptPt{\Ruleref{answer statement}}, \lfeed 
%    \OptPt{\Lop{$->$}, 
%    \Ruleref{statement}} 
%  } 

%  \Rule{answer statement}{ 
%    \Lop{answer}, 
%    \Brack{\Ruleref{name} \dsepl 
%    \Lop{all}} 
%  }

\item[意味定義:] \mbox{} 
手続きスレッドは、そのスレッドを所有するオブジェクトへのスタート文適用に続いて、実行スケジュールがなされる。
スレッド内の文はその後連続して実行され、文の実行が完了したときにスレッドは消滅する。
多重スレッド間の同期は、共有オブジェクトにおける許可述語を用いることで達成される。
%Select statements and answer statements can
%occur at any place in a thread and allow conditional execution of the
%thread on the basis of operation invocation requests received by the
%thread. Any number of select and answer statements may occur in a
%thread definition, and they may be freely mixed with other
%statements. Note that select and answer statements may only used in
%active objects (threads), though this restriction is presently not
%enforced by the Toolbox.
%
%The following provisos apply:
%\begin{itemize}
%\item {\em guarded command} may not be empty; it must contain one {\em
%expression}, {\em answer statement} or {\em statement} at minimum.
%\item {\em expression} in {\em guarded command} must be boolean (if it
%is absent its default value is $\True$).
%\item {\em name} in the rule for {\em answer statement} must be
%defined in the class or in one of its superclasses.
%\end{itemize}
%Guards without an answer statement can be used to describe the {\em
%else} behaviour of the select statement.
%
%An answer statement \texttt{\keyw{answer} o} waits until the thread
%receives a request for operation \texttt{o}. It then executes this and
%the statement terminates. The \texttt{\keyw{answer all}} statement
%waits until the thread receives a request for any operation defined in
%that class (or superclass), executes that operation and then
%terminates.
%
%The general form of the select statement is
%\begin{alltt}
%  \keyw{sel} 
%     guard1, \keyw{answer} o1 -> s1, 
%       \vdots 
%     guardN, \keyw{answer} oN -> sN;
%\end{alltt}
%Each line after the \texttt{sel} is a guarded command. For each
%guarded command, each of the guard, answer statement,  and statement
%is optional, but at least one of them must appear.
%
%The select statement is then executed as follows:
%\begin{description}
%\item[Step 1:] All conditions of the guarded command \texttt{guard1}
%$\ldots$ \texttt{guardN} are evaluated.  The guards whose conditions
%result in false are discarded.  The remainder are known as {\em open}
%guards.
%\item[Step 2:] The set of operation names occurring in the answer
%statements of the open guards is determined ({\em open operation
%set}).  The set of all invocations of operations within the open
%operation set is determined (the open invocation set).
%
%We then have three choices
%\begin{description}
%\item[Choice 1] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are open guards without an answer statement
%\end{itemize}
%  then an arbitrary open guard without an answer statement is selected
%  and   its associated statement sequence is executed.  The select
%  statement then terminates.
%\item[Choice 2] If
%\begin{itemize}
%\item the open invocation set is empty, and
%\item there are {\em no} open guards without an answer statement
%\end{itemize}
%then the thread waits until an operation in the open operation set is
%invoked by another object. Following completion of this operation the
%corresponding statement is executed. After this the select statement
%terminates.
%\item[Choice 3] If the set of invocations is {\em not} empty then the
%invocation in the open invocation set which was received first is
%selected. An arbitrary guard with an answer statement matching the
%invoked operation is selected. The operation is executed and after
%that the statement sequence associated with that guard is
%executed. Following this the select statement terminates.
%\end{description}
%\end{description}
%
%In addition to the basic mechanism described above a few points are
%worth noting:
%\begin{itemize}
%\item A select statement must always contain at least one {\em open}
%guard.
%\item A calling object will block until its call is answered by the
%select statement.
%\item The calling object and the thread synchronize on the operation
%call. However if a guarded command includes an answer statement and a
%statement to be executed afterwards, synchronization only occurs on
%the operation named in the answer statement. That is, the calling
%object may proceed following completion of the operation, and does not
%wait for execution of the statement listed in the guarded command.
%\end{itemize}
%
\item[例題:]  \mbox{}
以下の例は手続きスレッドを用いて、与えられた整数の階乗を同時的に計算することを実演する。

\begin{alltt}
    \keyw{class} Factorial

    \keyw{instance} \keyw{variables}
      result : \keyw{nat} := 5;
    \keyw{operations}

    \keyw{public} factorial : \keyw{nat} ==> \keyw{nat}
    factorial(n) == 
      \keyw{if} n = 0 \keyw{then} \keyw{return} 1
      \keyw{else} (
        \keyw{dcl} m : Multiplier;
        m := \keyw{new} Multiplier();
        m.calculate(1,n);
        \keyw{start}(m);
        result:= m.giveResult();
        \keyw{return} result
      )

    \keyw{end} Factorial

    \keyw{class} Multiplier

    \keyw{instance} \keyw{variables}
      i : \keyw{nat1};
      j : \keyw{nat1}; 
      k : \keyw{nat1};  
      result : \keyw{nat1}

    \keyw{operations}

    \keyw{public} calculate : \keyw{nat1} * \keyw{nat1} ==> ()
    calculate (first, last) ==  
      (i := first; j := last);

    doit : () ==> ()
    doit() ==
      (
       \keyw{if}  i = j \keyw{then} result := i
       \keyw{else} (
         \keyw{dcl} p : Multiplier;
         \keyw{dcl} q : Multiplier;
         p := \keyw{new} Multiplier();  
         q := \keyw{new} Multiplier();  
         \keyw{start}(p);\keyw{start}(q);  
         k := (i + j)  \keyw{div} 2;
         -- 切下げの除算
         p.calculate(i,k);  
         q.calculate(k+1,j);  
         result := p.giveResult() *  q.giveResult ()
        )
      );


    \keyw{public} giveResult : () ==> \keyw{nat1}
    giveResult() ==  
      \keyw{return} result;

    \keyw{sync}
    -- 列計算のみを許す繰返し制約
    -- ; doit; giveResult

    \keyw{per} doit => \keyw{#fin} (calculate) > \keyw{#act}(doit);
    \keyw{per} giveResult => \keyw{#fin} (doit) > \keyw{#act} (giveResult);
    \keyw{per} calculate => \keyw{#fin} (giveResult) = \keyw{#act} (calculate)

    \keyw{thread}
      doit();

    \keyw{end} Multiplier
\end{alltt}

%First we consider some examples which illustrate the
%basic mechanism of select statements. Suppose we have a thread with
%instance variables \texttt{x:\keyw{nat}}, \texttt{y:\keyw{nat}} and
%\texttt{l:\keyw{seq1 of nat}}, and operations \texttt{o1} and
%\texttt{o2}. Consider the following select statement:
%\begin{alltt}
%  \keyw{sel} ( 
%    x <= 0, \keyw{answer} o1 -> x:= 1,     -- gc1 
%    x >= 0,\mbox{\hspace{0.2em}}          -> y := x,    -- gc2
%            \keyw{answer} o2 -> l := [1]   -- gc3 )
%\end{alltt}
%We consider a number of different scenarios:
%\begin{enumerate}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc1}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set consists of only \texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, \texttt{gc2} is open and has no answer
%statement. Therefore choice 1 is taken. The statement \texttt{y := x}
%is executed then the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & -3\\ \hline \texttt{y} & 1\\ \hline \texttt{l} &
%[1,2,3]\\ \hline
%\end{tabular}
%\end{center}
%
%and no invocations have been received by the thread.
%\begin{description}
%\item[Step 1] \texttt{gc2}s guard evaluates to false and is therefore
%discarded. The other two are retained.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Since no invocations have been received, the set of open
%invocations is empty, and there are no open guards without an answer
%statement. Therefore choice 2 is taken and the thread waits. While it
%waits it can only respond to invocations of \texttt{o1} or
%\texttt{o2}. Suppose then that while waiting it receives a call to
%\texttt{o1}: \texttt{o1} is executed, then the statement \texttt{x :=
%1} is executed and the select statement terminates.
%\end{description}
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and invocations have been received for operations \texttt{o1} and
%\texttt{o2} (\texttt{o2} arriving first).
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains \texttt{o1} and
%\texttt{o2}.
%\item[Choice] Now since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc3} is selected because the invocation of
%\texttt{o2} was received first. \texttt{o2} is executed and on
%completion the statement \texttt{l := [y]} is executed. The select
%statement then terminates.
%\end{description}
%
%\item Suppose the statement is executed in the state
%\begin{center}
%\begin{tabular}{|l|l|}\hline
%\texttt{x} & 0\\ \hline \texttt{y} & 1\\ \hline \texttt{l} & [1,2,3]\\
%\hline
%\end{tabular}
%\end{center}
%
%and an invocation has been received for operation \texttt{o1}.
%\begin{description}
%\item[Step 1] All three guards evaluate to true so no guarded commands
%are discarded.
%\item[Step 2] The open operation set contains only \texttt{o1}.
%\item[Choice] Again, since the set of open invocations is non-empty
%choice 3 is taken. \texttt{gc1} is selected  and \texttt{o1} is
%executed. On completion the statement \texttt{ x:= 1} is executed. The
%select statement then terminates.
%\end{description}
%\end{enumerate}
%
%We now give a more complex example.  Suppose we wish to model the
%behaviour of an ATM machine. We might have the following instance
%variables:
%\begin{alltt}
%  \keyw{instance variables} 
%    status : <InService> | <OutOfService> |  <CardInserted> |  
%             <CardAccepted> := <InService>; 
%    currentCard : [ATMCard] := \keyw{nil}; 
%    pinTries : \keyw{nat} := 0; 
%    balance :  \keyw{nat} := 10000; 
%    keypad : Keypad := \keyw{new} Keypad();
%    accountDB : AccountDB := \keyw{new} AccountDB(); 
%    retained : \keyw{set} of ATMCard := \{\};
%\end{alltt}
%Here \texttt{ATMCard} is a class representing an ATM card,
%\texttt{Keypad} is a simple object that models digit entry by the
%user, and \texttt{AccountDB} is an object modelling the mapping from
%card numbers to account details.
%
%We might wish to perform the following operations on this class (for
%brevity we do not include their definition here):
%
%\begin{tabular}{lll}
%\texttt{EnterCard :} & \texttt{ATMCard ==> ()}  & Enter a card into
%                          the machine\\ 
%\texttt{GetPin :}    & \texttt{() ==> ()}       & Get the PIN digits typed
%                                                  at \\ 
%                     &                          & the keypad\\
%\texttt{VerifyPin:}  & \texttt{\keyw{nat} ==> ()}
%                                                & Check the validity of the PIN \\
%                     &                          & given\\
%\texttt{RetainCard :}& \texttt{() ==> ()}       & Retain the card if three failed\\
%                     &                          & attempts to enter the PIN\\
%\texttt{WithdrawCash :} 
%                     & \texttt{\keyw{nat} ==> ()}
%                                                & Withdraw cash\\
%\texttt{WithdrawCard :} 
%                     & \texttt{() ==> ()}       & Withdraw card from the \\
%                     &                          & machine\\
%\texttt{ReplenishMachine :} 
%                    & \texttt{() ==> ()}        & Refill machine with cash
%\end{tabular}
%
%Then we might specify the thread behaviour of this class as follows:
%\begin{alltt}
%    \keyw{while true do}
%      \keyw{if} status = <InService>
%      \keyw{then} (
%        \keyw{sel} (\keyw{answer} EnterCard);
%        \keyw{while} status <> <InService> \keyw{do}
%          \keyw{sel} ( status = <CardInserted> \keyw{and} pinTries < 3
%                               \keyw{answer} GetPin,
%               status = <CardInserted> \keyw{and} pinTries = 3 
%                               -> RetainCard(),
%               status = <CardAccepted> \keyw{and} balance > 300 
%                               \keyw{answer} WithdrawCash,
%               status = <CardAccepted> \keyw{answer} WithdrawCard
%              );
%        \keyw{if} balance <= 300
%        \keyw{then} status := <OutOfService> )
%      \keyw{else}
%        \keyw{sel} (status = <OutOfService> \keyw{answer} ReplenishMachine);
%\end{alltt}
%This thread repeatedly loops until the object is destroyed. Within
%this loop behaviour diverges according to whether \texttt{status =
%<InService>} or not. Initially the status is \texttt{<InService>} so
%the \texttt{then} clause will be executed. The thread will then wait
%until a card is entered into the machine.
%
%Following this we loop until the status returns to
%\texttt{<InService>}, which only occurs when the operations
%\texttt{WithdrawCard} or \texttt{RetainCard} are executed. Within this
%loop the thread conditionally allows invocations of the operations
%\texttt{GetPin}, \texttt{WithdrawCash} and
%\texttt{WithdrawCard}. Additionally the thread invokes
%\texttt{RetainCard} itself once 3 unsuccessful attempts have been made
%to enter a pin code.
%
%When this loop is exited the status is \texttt{<InService>}. However
%if insufficient cash is left in the machine it goes out of
%service. This terminates the \texttt{then} clause.
%
%In the \texttt{else} clause, it can be seen that the only way this
%clause can be entered is if the status is
%\texttt{<OutOfService>}. Thus the thread waits until the machine is
%replenished. 
%
%Observe that in the second \keyw{sel} statement, if (\texttt{status =
%<CardAccepted> 
%\keyw{and} balance > 300}) then the thread could behave
%non-deterministically, since two guards would be open simultaneously.
%
\end{description}
%
%Note that the two methods of specifying synchronization (permission
%predicates %, trace structures 
%and answer statements) should not be
%mixed in a class specification: only one of these may be used. 
%
%A procedural thread definition has precedence over a
%synchronization specification in a class; when using this way of
%specification, the full external behaviour of an active object has to
%be specified (i.e. for each operation an answer statement must be
%present).  The synchronization definitions can then be derived
%from the procedural thread.  If there is a contradiction between
%synchronization derived from the procedural thread and the specified
%synchronization behaviour then the class is erroneous.

%\subsection{Inheriting from Active Objects}
%\label{ch:thread-inh}
%
%Threads can, in some cases, be inherited in {\vdmpp}; the situations in which
%this is allowed are determined by whether or not there exists
%a sensible interpretation of polymorphism between active objects (see Section
%\ref{sec:polyao}). The different situations in which inheriting from
%active superclasses is allowed is summarized in the following table:
%
%{\small
%\begin{center}
%\begin{tabular}{|c||c|c|c|c|c|}
%\hline
%& & & {\em active,} & {\em active,}\\
%superclass & {\em none} & {\em passive} & {\em declarative} & {\em procedural}\\
%& & & {\em thread} & {\em thread}\\
%\hline
%\hline
%& & behaviour as & inheritance & inheritance\\
%{\em none} & --- & defined by & allowed, see & allowed, see\\
%& & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%& behaviour as & behaviour as & inheritance & inheritance \\
%{\em passive} & defined by & defined by & allowed, see & allowed, see \\
%& the subclass & the subclass & Section \ref{decinh} & Section \ref{procinh}\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em declarative} & allowed, see & allowed, see & allowed, see & {\bf not} \\
%{\em thread} & Section \ref{decinh} & Section \ref{decinh} & Section \ref{decinh} & allowed\\
%\hline
%{\em active,} & inheritance & inheritance & inheritance & inheritance \\
%{\em procedural} & allowed, see & allowed, see & {\bf not} & allowed, see \\
%{\em thread} & Section \ref{procinh} & Section \ref{procinh} & allowed & Section \ref{procinh} \\
%\hline
%\end{tabular}
%\end{center}}
%
%\subsubsection{Polymorphism for Active Objects}\label{sec:polyao}
%
%A basic issue for understanding polymorphism for active objects
%is the notion of risk of interference caused by the thread of such objects.
%A basic understanding to this is provided by the Bernstein rules.
% (see e.g. \cite{bernstein66} or \cite[pages 289--290]{peterson}).
%Bernstein defines the {\em read-set} $R$ for statement $S_i$, $\fnapply{R}{S_i} = \setrange{a_1, a_2}{a_n}$, as:
%\begin{quote}
%the set of all variables referenced in statement $S_i$, such that the value
%of each $a_j$ did not change during the execution of $S_i$.
%\end{quote}
%The {\em write-set} $W$ for statement $S_i$, $\fnapply{W}{S_i}= \setrange{b_1,
%b_2}{b_n}$, is then defined as:
%\begin{quote}
%the set of all variables referenced in 
%statement $S_i$ such that each $b_j$ is
%updated (i.e. gets a new value) in $S_i$.
%\end{quote}
%
%The following three conditions must hold for two successive statements 
%(say: $S_1$ and $S_2$) in order to be executed concurrently and always
%produce the same result as if they were executed sequentially (the 
%Bernstein conditions):
%\begin{enumerate}
%\item
%$\fnapply{R}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \Emptyset$
%\item
%$\fnapply{W}{S_1} \Inter \fnapply{W}{S_2} = \Emptyset$
%\end{enumerate}
%
%As an example, consider two statements $S_1$ and $S_2$. Suppose that
%$S_1$ updates a variable $b$, and that $S_2$ is defined as
%$\ass{c}{a + b}$. Since 
%$\fnapply{W}{S_1} \Inter \fnapply{R}{S_2} = \set{b}$, concurrent
%execution of $S_1$ and $S_2$ is not allowed.
%
%In a similar fashion, in {\vdmpp} the read- and write-sets can be defined
%for threads in terms of instance variables.
%
%For presentation purposes a distinction is made between active objects with
%a {\em declarative} thread (periodic obligation) and those with a
%{\em procedural} thread (sequence of statements using answer and select
%statements).
%
%\subsubsection{Declarative Threads}\label{decinh}
%
%Consider two classes {\tt A} and {\tt B} with a periodic obligation, 
%for {\tt A}, say, defined as:
%  \begin{alltt}
%    periodic (intervalA)(mA)
%  \end{alltt}
%and for {\tt B}, say, defined as:
%  \begin{alltt}
%    periodic (intervalB)(mB)
%  \end{alltt}
%then a class {\tt C}, defined as subclass of both {\tt A} and {\tt B},
%has a new thread with {\it two} periodic obligations, e.g. graphically
%depicted as follows:
%\ \\
%\ \\
%\insertfig{2periodic}{14cm}{Periodic obligations for class C}{}
%
%
%\subsubsection{Procedural Threads}\label{procinh}
%
%Polymorphism for active objects of which the behaviour is defined using
%procedural threads instead of declarative threads is more complicated.
%In {\vdmpp} it is only considered for classes with a non-terminating
%behaviour\footnote{It is possible to define terminating threads, implying that
%these (initially) {\it active} objects become {\it passive} after some time.},
%e.g. defined using a loop, typically:
%  \begin{alltt}
%    while true do\\
%    sel (
%      condA -> answer mA,
%      condB -> answer mB,
%      ...
%      condN -> answer mN
%    )
%  \end{alltt}
%or
%  \begin{alltt}
%    while true do
%    answer mA;
%    answer mB;
%    ...
%    answer mN
%  \end{alltt}
%
%Procedural threads of these forms define `answer-sets/sequences', i.e.
%sets or sequences defining the possible (orders of) operations these
%objects will answer to.
%Defining a subclass of two classes with such definitions implies that
%the subclass has an answer-sets/sequence composed by taking the union
%or weaving the two answer-sets/sequences of the superclasses into one another.
%So, suppose that objects from class {\tt A} respond to
%
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n}
%\end{expr}
%\end{vdm}
%and that objects from class {\tt B} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_{n+1}, m_{n+2}}{m_p}
%\end{expr}
%\end{vdm}
%and that class {\tt C} is a subclass of both {\tt A} and {\tt B}, then
%objects from class {\tt C} respond to
%\begin{vdm}
%\begin{expr}
%\setrange{m_1, m_2}{m_n, m_{n+1}, m_{n+2}, \ldots, m_p}
%\end{expr}
%\end{vdm}
%
%Because the scope in which the instance variables of
%an object are visible includes the procedural thread, a proof obligation is
%raised to satisfy the Bernstein conditions.
%No problems arise in the simple case where {\tt C} is a subclass of 
%{\tt A} and {\tt B} and no further coupling is made in {\tt C}
%between the instance variables of {\tt A} and {\tt B} -- the threads of
%{\tt A} and {\tt B} in {\tt C} only affect the {\tt A} and {\tt B} part
%of the instance variables in {\tt C},
%respectively, hence the Bernstein conditions are always satisfied.
%If, however, a connection is made in {\tt C} between the two state parts
%through an invariant, then it is no longer guaranteed that the Bernstein
%conditions are satisfied.

%\cleardoublepage
%\section{Real-time Behaviour}\label{ch:rt}
%
%For the description of requirements and the behaviour of a system
%(component) in real time a small number of concepts suffice.  These
%concepts are based on
%references~\cite{Hayes90,Mahony&91a,Mahony&91b,Mahony92,Mahony&92}.
%At first the time continuous functions are defined and introduced as
%{\em time variables}. Existing concepts like pre-conditions,
%post-\-cond\-it\-ions, hooked values etc. are overloaded with their
%time aspects.
%
%For a complete (sub)system a development process starting in the
%continuous time domain is envisaged.  The initial input-output
%relations from the requirements can be decomposed into a topology of
%subcomponents through refinement steps in the continuous time domain.
%The continuous behaviour of the topology of the derived objects can be
%mapped on equivalent objects, which operate themselves sequentially in
%a discrete time domain.  Relations between the continuous and the
%discrete objects are established through inheritance.  The resulting
%objects can follow the more common {\vdmpp} refinement steps with
%additional descriptions and rules for their time behaviour. The
%resulting time behaviour of the lower level objects in the
%specification will give the limitations/requirements for the component
%implementation. 
%
%Time continuous variables appear in classes with a special role
%in the specification. Spreading these functions in arbitrary places is not
%foreseen. 
%
%\subsection{Time continuous Functions}
%\label{sec:timeexpr}
%
%Time continuous functions are those in which time can be assumed to
%increase continuously and implicitly, thus without any influence from
%the specification.
%
%At the input side of a system {\em assumptions} can be made about
%these continuous signals. In many cases these assumptions will
%represent the physical properties of the real-world signals and the
%available sensors in the environment.  Such an assumption is
%functionally equivalent to a {\em pre-condition}.  There is no way of
%enforcing this condition, however, because the environment is in
%principle beyond the scope of control of the system specifier.  The
%consequence of this observation is that the correct behaviour of the
%system can only be guaranteed for those time periods where these
%assumptions are met.  In all other cases the system will react in an
%undefined way or not at all.  In other words: the assumptions on input
%signals are environmental requirements.
%
%The syntactical representation of time continuous variables is
%realised through a syntactic block comparable with the instance
%variables block, beginning with the keyword {\tt time variables}. Then
%the declaration of the names of the time functions follow.  The
%function value changes over time either according to a given formula,
%with the time as an independent variable, or changes as an observation
%value of a physical quantity in the environment.
%
%\begin{description}
%\item[Syntax:] 
%\Rule{time variable definitions}{\Lop{time}, \Lop{variables},
%      time spec, \SeqPt{\Lit{;}, time spec}, \OptPt{\Lop{;}}}
%\Rule{time spec}{time var decl \dsep assumption \dsep effect}
%\Rule{time var decl}{\OptPt{\Lop{input}}, name list, \Lit{:}, type}
%\Rule{assumption}{\Lop{assumption}, name list, \Lit{==}, expression}
%\Rule{effect}{\Lop{effect}, name list, \Lit{==}, expression}
%
%\item[Semantics:] If instances are created from a continuous class
%(and used through clientship by other objects) each object represents
%a distinct time continuous function which has in principle no relation
%with the functions in the other instances, i.e. different
%observations.  The following rules hold:
%
%\begin{itemize}
%\item If different subclasses are inheriting from the same continuous
%  superclass, they share the same function, i.e. the same observation of
%  the environment.
%\item If instances are created from a continuous class (and used
%  through clientship by other objects) each object represents a distinct
%  time continuous function which has in principle no relation with the
%  functions in the other instances, i.e. different observations.
%\item Sharing of the information available in an object as server for
%  more than one client object, has to be realised by referencing through
%  clientship to the same server object.
%\end{itemize}
%
%This interpretation can be used e.g. with a number of sensors for the
%temperature in a room; they measure the local temperature in a certain area
%Sharing of the information available can be achieved by using 
%an object as server form more
%than one client object.
%The local temperature variations are discarded and
%only one room temperature is used in the model.
%
%A special clause can be added to a time continuous functions to denote
%assumptions over their behaviour.  The keywords used are {\tt
%assumptions} for input variables and {\tt effects} for output
%variables.
%
%The use of the operation interface is reserved for the discrete system
%behaviour and provides the specification of a sampling mechanism, when
%used on continuous variables.
%
%\item[Examples:] \mbox{} 
%
%  \begin{alltt}
%  class SensorBehaviour
%  
%    time variables
%      input theta: real;
%      input myinput: real;
%    assumption myinput == myinput (t) = a * sin (w * t)
%
%  end SensorBehaviour
%  \end{alltt}
%
%These functions are in another notation the continuous time functions:
%
%  \begin{alltt}
%    theta (t) = temperature (t)
%  \end{alltt}
%  and
%  \begin{alltt}
%    myinput (t) = a * sin (w * t)
%  \end{alltt}
%
%\end{description}
% 
%\subsection{From Continuous Time to Discrete Time}
%
%\subsubsection{The input side}
%
%To express the way hardware/software based systems handle the continuous time
%problems a next refinement step will practically always mean the discretisizing
%of the continuous time functions. This means that a sampling mechanism has to
%be specified.
%
%The advised steps to specify this translation into the discrete time
%domain is to:
%
%\begin{enumerate}
%\item Inherit into a new {\vdmpp} class from the continuous class the time
%  function.
%\item Specify a sampling operation.
%\item Introduce a thread which regularly invokes this operation,
%  with sample frequency $f_s\;(=\; \frac{1}{\Delta t})$.
%\end{enumerate}
%
%Discrete sampling involves an approximation of the continuous value.
%If the interval length is $\Delta t$ in the interval $<t_1 , t_1 +
%\Delta t>$, a value within $F \ll t_1 \ldots t_1 + \Delta t \gg $ is
%returned as the discrete result. According to the theory of Shannon,
%the sampling frequency should be at least twice the highest frequency
%which is present in the input signal. The error in the approximation
%can be calculated with standard signal processing operations.
%
%The approximation in time is also needed to handle the fact, that discrete
%observations of ideal time continuous functions always include measurement
%errors, rounding off errors, limited accuracy, etc.
%
%\begin{description}
%\item[Examples:] The advised discretisizing operation as first
%  refinement for the continuous class is represented by the following
%  class based on the continuous temperature class:
%
%\begin{alltt}
%  class Sensor is subclass of SensorBehaviour
%
%    values
%      fs: real = undefined
%  
%    instance variables
%      tempvalues: seq of real := [];
%      currvalue: real;
%    inv len tempvalues > 0 => currvalue = tempvalues(len)
%
%    operations
%      gettemp: () ==> ()
%      gettemp() ==
%      ( currvalue := theta(t);
%        tempvalues := tempvalues ^ [currvalue]
%      )
%  
%   thread
%     periodic (1/fs)(gettemp)
%
%end Sensor
%\end{alltt}
%
%The introduced sequence of values now models the history of all
%samples.  In a normal case in which a $2^{nd}$ order differential
%equation can describe the system behaviour, the length can be reduced
%to three values: those at $t$, $t - \Delta t$ and $t - 2 \Delta t$
%will be sufficient.
%
%\end{description}
%
%\subsubsection{The output side}
%
%At the output side a similar approach can be used, although some special
%considerations are needed here.
%If the discrete class is the `producer' of a series of discrete values over
%time, the output of the system itself will be continuous again.
%Therefore, the impossibility for real signals to perform discontinuous behaviour
%has to be build in. 
%
%\begin{description}
%\item[Example:] In class {\tt HeaterController} there is an instance
%variable {\tt controlvalue} which represented at each time the
%discrete value of the output of the controller.  The transformation
%backwards into the continuous domain is again performed with an
%operation which sets at discrete time intervals the value of the
%continuous time variable.  At the times in between these moments the
%effect constraint specifies the maximum rate that can be achieved in
%the continuous domain.
%
%The two classes can be specified as follows:
%  \begin{alltt}
%  class HCBehaviour
%
%    time variables
%      controloutput: real
%
%  end HCBehaviour
%
%  class HeaterController is subclass of HCBehaviour
%
%    instance variables
%      controlvalue: nat
%      
%    operations
%      setheatercontrol: () ==> ()
%      setheatercontrol() ==
%        controloutput(now) := controloutput
%
%    thread
%      periodic (1/fs) (setheatercontrol)
%
%  end HeaterController
%  \end{alltt}
%\end{description}
%
%The relation between the momentary values coming from the discrete world to
%the continuous time functions requires some extra discussion.
%The specific relationship between the discrete value and its continuous
%counterpart requires the concept of controlled register-like variables in the
%continuous domain, which
%do not change in time between two successive updates by the operation.
%Given a sampling distance $\Delta t$ and an interval beginning at $t_i$ with
%a value $F(t_i)$, the step reaction
%of the system will take some time constant say $\tau$ with 
%$\tau \leq \Delta t$ to stabilise the output value. This value $\tau$ can be
%derived from the effect constraint. This gives the following continuous time
%behaviour:
%\begin{itemize}
%\item
%$<t_i,t_i + \tau>$: the rate defined by constraint, 
%value within $F \ll t_{i-1} \ldots t_i \gg$ or equivalently
%$[F(t_{i-1}),F(t_i)]$ excluding possible `overshoot';
%\item
%$<t_i + \tau ,t_i + \Delta t>$: value should have been stabilised on $F(t_i)$;
%\item
%at $t_i + \Delta t$: value is $F(t_i)$.
%\end{itemize}
%
%This time description is of course a kind of macro description of the
%continuous output value. By including the behaviour of more detailed output
%channel components one can refine the above mentioned intervals again.
%The above specification is effectively
%the behaviour of a certain digital-to-analogue converter.

#endif VDMPP
#ifdef VDMSL
\newpage
\section{トップレベル仕様記述}
\label{top-level}\label{modules}

前節で、型・式・文・関数、そして操作、という全てのVDM-SLの構成要
素を述べてきた。
これらのたくさんの構成要素は、トップレベルのVDM-SL仕様記述の構成要素となることができる。
トップレベル仕様記述は2つの方法により作り出される:
\begin{enumerate}
\item 仕様記述は、別々に指定される多くのモジュールに分けられるが、互いに依存することができる。
\item 仕様記述はフラットな方法で記述される。 すなわち、どのモジュールも使用されていない。
\end{enumerate}
したがって、完全な仕様記述、または文書には、以下の構文がある。

\begin{description}
\item[構文:]
\Rule{文書}{
  \Ruleref{任意のモジュール}, \SeqPt{\Ruleref{任意のモジュール}} \dsep
   \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Rule{任意のモジュール}{
  \Ruleref{モジュール} \dsep
  \Ruleref{動的リンクモジュール}
  }
\end{description}

\subsection{フラット仕様記述}\label{flat}

前に述べたように、フラット仕様記述はモジュールを使用しない。
これは、すべての構成要素が仕様記述中で使用することができることを意味する。 
フラットな場合では、文書は以下の構文を持っている:

\Rule{文書}{\ldots \dsep
  \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Rule{定義ブロック}{
  \Ruleref{型定義群} \dsep
  \Ruleref{状態定義} \dsep
  \Ruleref{値定義群} \dsep
  \Ruleref{関数定義群} \dsep
  \Ruleref{操作定義群}
  }

したがって、フラットな仕様記述はいくつかの定義ブロックで作られる。しかしなが
ら、1つの状態定義のみ許されている。
以下はフラットトップレベル仕様記述に関する例である:

\begin{alltt}
  \keyw{values}

    st1 = \keyw{mk\_}St([3,2,-9,11,5,3])

  \keyw{state} St \keyw{of}
    l:\keyw{seq1 of nat}
  \keyw{end}

  \keyw{functions}

  min_index : \keyw{seq1 of nat} -> \keyw{nat}
  min_index(l) ==
    \keyw{if} \keyw{len} l = 1
    \keyw{then} 1
    \keyw{else} \keyw{let} mi = min_index(\keyw{tl} l)
        \keyw{in} \keyw{if} l(mi+1) < \keyw{hd} l
          \keyw{then} mi+1
          \keyw{else} 1

  \keyw{operations}

  SelectionSort : \keyw{nat} ==> ()
  SelectionSort (i) ==
    if i < len l
    then (\keyw{dcl} temp: \keyw{nat};
          \keyw{dcl} mi : \keyw{nat} := min_index(l(i,...,\keyw{len} l)) + i - 1;
         
          temp := l(mi);
          l(mi) := l(i);
          l(i) := temp;
          SelectionSort(i+1)
         )
\end{alltt}






\subsection{構造仕様記述}

標準のVDM-SL言語への拡張として、モジュールを使用しているVDM-SL仕様記述を構造化することは可能である。
この節で、トップレベル仕様記述を作成するためのモジュール使用方法を説明する。
VDM-SLで提供されている構造化機能で以下が可能になる:
\begin{itemize}
\item モジュールから構成要素を輸出する
\item モジュールから構成要素を輸入する
\item 輸入時に構成要素名を変更する
\item モジュールの状態を定義する
\end{itemize}

これらの普通のモジュールに加えて、いわゆる「ダイナミックリンクモジュール」 (第~\ref{sec:DLmodules}節参照)
を使用することが可能である

\subsubsection{モジュールのレイアウト}
実際の機能を説明する前に、一般的なモジュールのレイアウトを説明する。モ
ジュールは3 つの要素から成る: モジュール宣言、インタフェース節、および
定義節である。モジュール仕様記述の初期段階で定義部分を省略することは可能である。

モジュール宣言の中で、モジュールには名前が付けられる。その名前は完全な仕様
記述の中では一意なモジュール名でなければならない。2つ目(インタフェー
ス節) は、他のモジュールのモジュール関係を定義し、多くの節から成る。
これらの節は以下の通りである:

\begin{itemize}
\item {\it 輸入節} 輸入節では、他のモジュールから使用されるすべての構成要
素が述べられる。もしも、構成要素の名前を変更するなら、輸入節で行う。

\item {\it 輸出節} ここで、他のモジュールで使用されるすべての構成要素が定義
される。1つも輸出節が存在していないなら、そのモジュールは他のモジュールから使用することができない。

\end{itemize}
モジュール宣言の3つ目(定義節)には全てのモジュール定義を含む。したがって、
一般にはモジュールの構文は以下の通りである:

\begin{description}
\item[構文:]
\Rule{モジュール}{
  \Lop{module}, \Ruleref{識別子}, \Ruleref{インタフェース}, \lfeed
  \OptPt{\Ruleref{モジュール本体}}, \Lop{end}, \Ruleref{識別子}
  }

  \Rule{モジュール本体}{
    \Lop{definitions}, \Ruleref{定義ブロック}, \SeqPt{定義ブロック}
  }
\end{description}

モジュールの使用を解説するために、フラットトップレベル仕様記述の例はやや手直しして記述する。
フラット仕様記述の重要でない部分は分かりやすくするため省略する。

\subsubsection{輸出節}

\begin{description}
\item[構文:]
  \Rule{インタフェース}{
    \OptPt{\Ruleref{輸入定義リスト}}, \lfeed
    \Ruleref{輸出定義}
    }

  \Rule{輸出定義}{
    \Lop{exports}, \Ruleref{輸出モジュールシグネチャ}
    }

  \Rule{輸出モジュールシグネチャ}{
    \Lop{all} \dsep
    \Ruleref{輸出シグネチャ}, \lfeed
    \SeqPt{\Ruleref{輸出シグネチャ}}
    }
  
  \Rule{輸出シグネチャ}{
    \Ruleref{輸出型シグネチャ} \dsep
    \Ruleref{値群シグネチャ} \dsep
    \Ruleref{輸出関数シグネチャ} \dsep
    \Ruleref{操作群シグネチャ}
%    \dsep
%    state signature
    }
  
  \Rule{輸出型シグネチャ}{
    \Lop{types}, \Ruleref{型輸出}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{型輸出}}, \OptPt{\Lit{;}}
    }
  
  \Rule{型輸出}{
    \OptPt{\Lop{struct}}, \Ruleref{名称}
    }
  
  \Rule{値群シグネチャ}{
    \Lop{values}, \Ruleref{値シグネチャ}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{値シグネチャ}}, \OptPt{\Lit{;}}
    }
  
  \Rule{値シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{型}
    }
  
  \Rule{輸出関数シグネチャ}{
    \Lop{functions} \Ruleref{関数輸出}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{関数輸出}}, \OptPt{\Lit{;}}
    }

  \Rule{関数輸出}{
    \Ruleref{名称リスト}, \OptPt{\Ruleref{型変数リスト}}, \Lit{:}, \lfeed
    \Ruleref{関数型}
    }
  
  \Rule{関数群シグネチャ}{
    \Lop{functions} \Ruleref{関数シグネチャ}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{関数シグネチャ}}, \OptPt{\Lit{;}}
    }
  
  \Rule{関数シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{関数型}
    }
  
  \Rule{操作群シグネチャ}{
    \Lop{operations} \Ruleref{操作シグネチャ}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{操作シグネチャ}}, \OptPt{\Lit{;}}
    }
  
  \Rule{操作シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{関数型}
    }
  
%  \Rule{状態シグネチャ}{
%    \Lop{状態}, 名称, \SeqPt{\Lit{,}, 名称}
%    }

\item[意味定義:] 輸出節は構成要素を他のモジュールから見えるよう公開するために使用する。
モジュールで定義された構成要素のいくつか、またはすべてを輸出することが出来る。 
後者の場合では、キーワード\keyw{all}が使用される。しかしながら、
輸入された構成要素はモジュールから輸出されない。構成要素の一部だけを輸出するなら、
対応する適切なシグネチャの構造が公開される。

  通常、構成要素が他のモジュールから見えるなら、その構造は、モジュール内で定義されていると見ることができる。
 しかしながら、型と操作にはいくつかの例外がある:

  \begin{description}
  \item[型:] 型{\tt T}がモジュール{\tt A}で定義され、この型がモジュール{\tt B}で使用されるなら、モジュール{\tt A}からの型は輸出しなければならない
    これは、以下の2つの方法でできる:
    \begin{enumerate}
    \item その型の名前は輸出される
    \item その型の構造は輸出される
    \end{enumerate}
    型の名前だけを輸出するなら、もう一方のモジュールは型{\tt T}の値を作成することができない。
	これは、輸出しているモジュール({\tt A})は{\tt T}の表現に関する構成要素を用いて型{\tt T}の値を直接生成し
	操作するために関数と(または)操作を与えなければならない。

	私たちが\keyw{struct}というキーワードを使用することによって型の構造を輸出するなら、もう片方のモジュールは
	型{\tt T}の値(もしもレコード型であるなら、この型に対して\keyw{mk\_}キーワードと\keyw{is\_}キーワードも使用できる)を生成し操作することができる。

    型が不変条件も定義する場合、型の構造を輸出する場合にだけ、不変な述語関数を輸出する。

  \item[操作:] モジュール内では、モジュールにとってグローバルな状態は定義することができる。 
  モジュール内のすべての操作がその状態を操作することができる。モジュールから操作を輸出するなら、
  輸出しているモジュール(すなわち、それらが定義されるモジュールによる状態)で状態を操る。
  \end{description}

 輸出された関数、または操作が事前条件と(または)事後条件を定義するなら、
 対応する述語関数(第~\ref{functiondef}節参照)も輸出する。


\item[例:] 銀行口座のモデルを考える。口座は所有者の名前、口座番号、銀行のキャッシュカードで残高、
暗証番号を管理している口座の銀行支店によって特徴付けられている。
以下のようにこれをモデル化する:
\begin{alltt}
\keyw{module} BankAccount

  \keyw{exports} \keyw{types} digit; account
          \keyw{functions} digval: digit -> \keyw{nat};
                  withdrawal: account * \keyw{real} -> account;
                  isPin: account * \keyw{nat} -> \keyw{bool};
                  requestWithdrawal: account * \keyw{nat} -> \keyw{bool}
  \keyw{definitions}

  \keyw{types}

  digit = \keyw{nat}
  \keyw{inv} d == d < 10;
  
  account::  holder : \keyw{seq1 of char}
             number : \keyw{seq1 of digit}
             branchcode : \keyw{seq1 of digit}
             balance: \keyw{real}
             epin: \keyw{nat}
  \keyw{inv mk\_}account(holder, number, branchcode,-,-) ==
    \keyw{len} number = 8 and \keyw{len} branchcode = 6

  \keyw{functions}

    digval : digit -> \keyw{nat}
    digval(d) == d;

    deposit: account * \keyw{real} -> account
    deposit(acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance + r);

    withdrawal : account * \keyw{real} -> account
    withdrawal (acc,r) == 
      \keyw{mu}(acc,balance |-> acc.balance - r);

    isPin : account * \keyw{nat} -> \keyw{bool}
    isPin(acc,ep) ==
      ep = acc.epin;

    requestWithdrawal : account * \keyw{nat} -> \keyw{bool}
    requestWithdrawal (acc,amt) ==
      acc.balance > amt

\keyw{end} BankAccount
\end{alltt}
このモジュール内で、2つの型と5つの関数を輸出する。
エンティティを列挙してから、輸出していることに注意する。
しかし、\keyw{struct}というキーワードで使用されている\texttt{digit}や \texttt{account}は輸出されていない。
つまり、 \texttt{account}値の内部は他のモジュールによってアクセスされないかもしれない。
また、\texttt{digit}の不変条件もアクセスされないかもしれない。
このようなアクセスが必要であるならば、その型は\keyw{struct}というキーワードで輸出されるべきであり、
また、モジュール内の全ての構成要素は\keyw{exports all}節を使用して輸出されるべきである。

以下に与えられたモジュール \texttt{keypad}はATMのキーパッドインタフェースをモデル化する。 
その状態変数はユーザーによってキーパッドにタイプされたデータのバッファを維持する。


\begin{alltt}
\keyw{module} Keypad

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit

  \keyw{exports all}

  \keyw{definitions}

  \keyw{state} buffer \keyw{of}
    data : \keyw{seq of} BankAccount`digit
  \keyw{end}

  \keyw{operations}

    DataAvailable : () ==> \keyw{bool}
    DataAvailable () ==
      \keyw{return}(data <> []);

    ReadData : () ==> \keyw{seq of} BankAccount`digit
    ReadData () ==
      \keyw{return}(data);

    WriteData : \keyw{seq of} BankAccount`digit ==> ()
    WriteData (d) ==
      data := data^d

\keyw{end} Keypad
\end{alltt}
このモジュールで、すべての構成要素を輸出する。定義された唯一のエンティティが、状態と操作であるので、
これは、操作のすべてが輸入しているモジュールでアクセスされるかもしれないこと意味する。
その状態は、輸入しているモジュールを利用しやすくないが、このモジュールはprivateのままである。
しかしながら、状態のコンストラクタである\texttt{\keyw{mk\_}Keypad`buffer}はアクセスできる。

\end{description}

\subsubsection{輸入節}

\begin{description}
\item[構文:]
  \Rule{インタフェース}{
    \OptPt{\Ruleref{輸入定義リスト}}, \lfeed
    \Ruleref{輸出定義}
    }

  \Rule{輸入定義リスト}{
    \Lop{Import}, \Ruleref{輸入定義}, \lfeed
    \SeqPt{\Lit{,}, \Ruleref{輸入定義}}
    }

  \Rule{輸入定義}{
    \Lop{from}, \Ruleref{識別子}, \Ruleref{輸入モジュールシグネチャ}
    }

  \Rule{輸入モジュールシグネチャ}{
    \Lop{all} \dsep
    \Ruleref{輸入シグネチャ}, \lfeed
    \SeqPt{\Ruleref{輸入シグネチャ}}
    }

  \Rule{輸入シグネチャ}{
    \Ruleref{輸入型シグネチャ} \dsep
    \Ruleref{輸入値シグネチャ} \dsep
    \Ruleref{輸入関数シグネチャ} \dsep
    \Ruleref{輸入操作シグネチャ}
%    \dsep
%    state signature
    }

  \Rule{輸入型シグネチャ}{
    \Lop{types}, \Ruleref{型輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{型輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{型輸入}{
    \Ruleref{名称}, \OptPt{\Lop{renamed}, \Ruleref{名称}} \dsep
    \Ruleref{型輸入}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

  \Rule{輸入値シグネチャ}{
    \Lop{values}, \Ruleref{値輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{値輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{値輸入}{
    \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{型}}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

  \Rule{輸入関数シグネチャ}{
    \Lop{functions}, \Ruleref{関数輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{関数輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{関数輸入}{
    \Ruleref{名称}, \OptPt{\OptPt{\Ruleref{型変数リスト}},  \lfeed
    \Lit{:}, \Ruleref{関数型}},
    \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

  \Rule{輸入操作シグネチャ}{
    \Lop{operations}, \Ruleref{操作輸入}, \lfeed
    \SeqPt{\Lit{;}, \Ruleref{操作輸入}}, \OptPt{\Lit{;}}
    }

  \Rule{操作輸入}{
    \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{操作型}}, \lfeed
    \OptPt{\Lop{renamed}, \Ruleref{名称}}
    }

\item[意味定義:] 輸入節はどの構成要素が目に見える構成要素のみ輸入することが出来るという制限を
  持った他のモジュールから使われるのかを述べるために使われる。
  モジュールからの全ての目に見える構成要素が利用されるならば、キーワードの\keyw{all}が使われる。
  但し、1つ以上の構成要素がrenameされない場合は除く。
  rename時には、輸入された構成要素は輸出しているモジュール名だけ先行した
  元の名前の代わりに利用することができる新しい名前が与えられる。
  一般に、これは形式がある:
  \begin{alltt}
    name \keyw{renamed} new_name
  \end{alltt}
  上記の{\tt name} は輸入された構成要素の名前であり、また、{\tt new\_name}は構成要素の新しい名前である。
  このように、より意味のある名前が構成要素に与えられる。
  輸入しているモジュール内では、これ以上{\tt DefModule`name}({\tt DefModule}は定義モジュールの名前である)を言及することは不可能である。
  しかし、{\tt newname}は可能である。

  輸入節では、型情報を含むことが可能である。
  この情報は、完全なモジュールの静的意味定義チェックによってのみ使用される。
  型情報が与えられなかったら、静的意味定義も輸出しているモジュール内のこの情報を見つけることができる。
  (第~\ref{static}節参照)
  
  型の輸入内で輸出しているモジュールから型定義が繰り返されるならば、
  \keyw{struct}キーワードで輸出している型が輸入される時には、この構成要素を使用するかもしれない。
  このような型の場合は、合成型であり、renameもされる。これは、さらにタグがrenameされる因果関係を持つ。
  
\item[例:] 私たちはカード番号と有効期限日から成り立つ銀行のキャッシュカードをモデル化すること
ができる。 これは\texttt{BankAccount}というモジュールで定義された \texttt{digit}型が必要である。
また、それは同じモジュールから\texttt{digval}という関数を使用する。
\begin{alltt}
\keyw{module} ATMCard

  \keyw{imports}
    \keyw{from} BankAccount \keyw{types} digit 
                     \keyw{functions} digval \keyw{renamed} atmc_digval

  \keyw{exports all}

  \keyw{definitions}

  \keyw{types}

    digit = BankAccount`digit;

    atmc:: cardnumber : \keyw{seq1 of} digit
           expiry : digit * digit * digit * digit
    \keyw{inv mk\_}atmc(cardnumber, \keyw{mk\_}(m1,m2,-,-)) ==
        atmc_digval(m1) * 10 + atmc_digval(m2) <= 12 \keyw{and}
        \keyw{len} cardnumber >= 8

  \keyw{functions}

    getCardnumber : atmc -> \keyw{seq1 of} digit
    getCardnumber (atmc) ==
      atmc.cardnumber

\keyw{end} ATMCard
\end{alltt}
ここでは、\texttt{atmc}型上の不変条件は、有効期限が有効日を表さなければならない。
また、カードナンバーは少なくとも8桁以上でなければならないということである。 
\texttt{degit}が\texttt{BankAccount}モジュールからstructキーワードが輸出されていないので、
\texttt{ATMCard}モジュール内の\texttt{digit}に対する不変条件にアクセスできない。
しかしながら、これにもかかわらず、\texttt{ATMCard}内で操作された\texttt{digit}型のすべての値が不変条件を満たさなければならない。

\end{description}


\section{動的リンクモジュール}\label{sec:DLmodules}

動的リンクモジュールはVDM-SLで完全に仕様を定められたモジュールとC++のコードとしてのみ利用可能なシステム全体
の一部分との間のインタフェースを記述するために使用された。
仕様記述がインタープリタ、またはデバッグしている間、この機能は存在しているC++ライブラリをユーザが使用することを
可能にする。この機能の使用法は\cite{DLMan-SCSK}で詳細に説明する。
動的リンクモジュールの一般的なレイアウトは普通のVDM-SLモジュールと似ている。
それは3つの部分から成る:それは\emph{モジュール宣言}、\emph{インタフェース節}、\emph{任意のライブラリ参照}である。

\begin{description}
\item[構文:]

動的リンクモジュールのモジュール宣言は、単にモジュール名の後のキーワード、\keyw{dlmodule}である。
動的リンクモジュールのインタフェース節は普通のモジュールのインタフェース節より単純である。
動的リンクモジュールに輸入することができる唯一の構成要素の種類は型である。
このように輸入された型は、モジュールから輸出された値、関数や操作のシグネチャとして使用することが出来る。
最終的にライブラリ参照(\Lop{uselib} キーワードで特定される)は、このようなインタープリタが行われるライブラリからコードを利用する仕様記述の場合、
インタープリタによって使われなければならない動的リンクC++ライブラリを特定するのに使われる。

動的リンクモジュールの構文は以下の通りである:
 
\Rule{動的リンクモジュール}{
  \Lop{dlmodule}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンクインタフェース},\lfeed
  \OptPt{\Ruleref{useシグネチャ}},\lfeed
  \Lop{end}, \Ruleref{識別子}
  }

\Rule{動的リンクインタフェース}{
  \OptPt{\Ruleref{動的リンク輸入定義リスト}}, \lfeed
  \Ruleref{動的リンク輸出定義}
  }

\Rule{useシグネチャ}{
   \Lop{uselib}, \Ruleref{テキストリテラル}
   }

\Rule{動的リンク輸入定義リスト}{
  \Lop{imports}, \lfeed
  \Ruleref{動的リンク輸入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{動的リンク輸入定義}}
  }

\Rule{動的リンク輸入定義}{
  \Lop{from}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンク輸入型シグネチャ群}
  }

\Rule{動的リンク輸入型シグネチャ群}{
  \Lop{types}, \Ruleref{名称}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{名称}}, \OptPt{\Lit{;}}
  }
  
\Rule{動的リンク輸出定義}{
  \Lop{exports}, \lfeed
  \Ruleref{動的リンク輸出シグネチャ}, \lfeed
  \SeqPt{\Ruleref{動的リンク輸出シグネチャ}}
  }

\Rule{動的リンク輸出シグネチャ}{
  \Ruleref{値群シグネチャ} \dsep
  \Ruleref{関数群シグネチャ} \dsep
  \Ruleref{操作群シグネチャ}
  }
  
\item[意味定義:] インタフェース構成要素の意味定義は、普通のモジュールに対する意味定義と同じである。
     useシグネチャの意味定義は動的リンクC++ライブラリを作成するために使われたC++コンパイラによって与えられた。
	 したがって、useシグネチャの中を参照するC++のコードはVDM-SL水準において、直接意味定義を供給しない。

\item[例:] ここで紹介されている例は、\cite{DLMan-SCSK}で利用されている。
最初のモジュールは、{\tt MATH}モジュールと{\tt CYLIO}モジュールからの構成要素を輸入する。 
これら他のモジュールの両方がその後提示され、それらの両方が動的リンクモジュールである。
\begin{alltt}
\keyw{module} CYLINDER
  \keyw{imports}
    \keyw{from} MATH
        \keyw{functions}
          ExtSin : \keyw{real} -> \keyw{real}
        \keyw{values} 
          ExtPI : \keyw{real},

    \keyw{from} CYLIO
        \keyw{functions}
          ExtGetCylinder : () -> CircCyl
   
        \keyw{operations}
          ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()

   \keyw{exports}
     \keyw{types}  
         CircCyl  

  \keyw{definitions}
    \keyw{types}
        CircCyl :: rad    : \keyw{real}
                   height : \keyw{real}
                   slope  : \keyw{real}
	
    \keyw{functions}
        CircCylVol : CircCyl -> \keyw{real}
        CircCylVol(cyl) ==
          MATH`ExtPI * cyl.rad * cyl.rad * cyl.height * 
          MATH`ExtSin(cyl.slope)

    \keyw{operations}
        CircCyl : () ==> ()
        CircCyl() == ( \keyw{let} cyl = CYLIO`ExtGetCylinder() \keyw{in} 
                         \keyw{let} vol = CircCylVol(cyl) \keyw{in}
                            CYLIO`ExtShowCircCylVol(cyl, vol))
\keyw{end} CYLINDER
\end{alltt}

The {\tt MATH} モジュールは次のように定義される:

\begin{alltt}
\keyw{dlmodule} MATH
  \keyw{exports}
    \keyw{functions}
      ExtCos : \keyw{real} -> \keyw{real};
      ExtSin : \keyw{real} -> \keyw{real}  
      
   \keyw{values}   
      ExtPI : \keyw{real}
  
   \keyw{uselib}
      "libmath.so" 

\keyw{end} MATH
\end{alltt}

The {\tt CYLIO} module is defined as:

\begin{alltt}
\keyw{dlmodule} CYLIO
  \keyw{imports}
    \keyw{from} CYLINDER
      \keyw{types}
        CircCyl

   \keyw{exports}
     \keyw{functions}
       ExtGetCylinder : () -> CircCyl
   
     \keyw{operations}
       ExtShowCircCylVol : CircCyl * \keyw{real} ==> ()
  88 

   \keyw{uselib}
      "libcylio.so"

\keyw{end} CYLIO
\end{alltt}

VDM-SLインタープリタでこのようなモジュールを使用する方法は\cite{DLMan-SCSK}中に述べられる。
\end{description}
#endif VDMSL

#ifdef VDMPP
\section{traces定義}
テスト工程を自動化するために、VDM++は網羅的テストを可能にするtraces記法を含んでいる。
tracesはテストしたい操作に対する、全ての組み合わせを表すことに用いられる。
これはある意味、記号ではなく、実数を取り扱うこと以外は、
限定的にモデル検査と類似している。
しかしながら、エラーを起こしたテストケースをフィルターにかけた上で取り除かれ、
さらに同じプレフィックスを持つ他のテストケースは自動的にスキップされる。

\begin{description}
\item[構文:]
\Rule{traces定義}{\Lop{traces},
   \SeqPt{\Ruleref{traces名}}
}

\Rule{traces名}{\Ruleref{識別子},
  \SeqPt{\Lit{/}, \Ruleref{識別子}},
  \Lit{:},\Ruleref{traces定義リスト}
}

\Rule{traces定義リスト}{
  \Ruleref{traces定義項}, 
  \SeqPt{\Lit{;}, \Ruleref{traces定義項}}
}

\Rule{traces定義項}{
  \Ruleref{traces定義項} \dsep
  \Ruleref{traces定義項}, \Lit{|}, \Ruleref{traces定義項}
}

\Rule{traces定義項}{
  \Ruleref{tracesコア定義} \dsep
  \Ruleref{traces束縛群}, \Ruleref{tracesコア定義} \dsep
  \Ruleref{tracesコア定義}, \Ruleref{traces繰り返しパターン} \dsep
  \Ruleref{traces束縛群}, \Ruleref{tracesコア定義}, 
  \Ruleref{traces繰り返しパターン}
}

\Rule{tracesコア定義}{
  \Ruleref{traces適用式} \dsep
  \Ruleref{traces括弧式}
}

\Rule{traces適用式}{
  \Ruleref{識別子}, \Lit{.}, \Ruleref{識別子}, 
  \Lit{(}, \Ruleref{式リスト}, \Lit{)}
}

\Rule{traces繰り返しパターン}{
  \Lit{*} \dsep 
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{数値リテラル}, \Lit{\}} \dsep
  \Lit{\{}, \Ruleref{数値リテラル}, \Lit{,} 
  \Ruleref{数値リテラル}, \Lit{\}}
} 

\Rule{traces括弧式}{
  \Lit{(}, \Ruleref{traces定義リスト}, \Lit{)}
}

\Rule{traces束縛群}{
  \Ruleref{traces束縛}, \SeqPt{\Ruleref{traces束縛}}
}

\Rule{traces束縛}{
  \Lop{let}, \Ruleref{ローカル定義}, 
             \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{束縛}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{束縛}, \Lop{be}, \Lop{st}, \Ruleref{式}, \Lop{in}
}

\item[意味定義:] 
意味定義的に、クラスで提供されるtraces定義は効果がない。
これらの定義は、組み合わせテスト（オールペアテストと同様に）からの法則を用い、
単にVDM++モデルのテストを増強するために使用される。
したがって、traces定義は、VDM++モデルをテストするために、異なる操作が実行されるべき
テストシーケンスについて記述する正規表現と見なすことができる。
traces定義の中には束縛が現れる可能性がある。
そのような束縛が実現することは、個々のテストケースを自動的に導き出すことである。
つまり、1つのtraces定義が1つのテストケース集合に拡大するということだ。
このような意味で、テストケースは互いに実行された操作の系列である。
各テストケース間で、VDM++モデルは初期化される。したがって、それらは完全に独立したようになる。
静的意味定義の観点から、traces定義の中で使われる式は、その式の過程で実行されなければならないことに注意することは重要だ。
これは、直接インスタンス変数を参照することができないことを意味する。
なぜなら、インスタンス変数は実行の間、変更することができるからだ。

異なる種類の繰り返しパターンは以下の意味を持つ。
\begin{itemize}
\item  \Lit{*} 0からn回発生する（nはツールの仕様）
\item  \Lit{+} 1からn回発生する（nはツールの仕様）
\item  \Lit{?} 0か1回発生する
\item  \Lit{\{}, n, \Lit{\}} n回発生する
\item  \Lit{\{}, n, \Lit{,} m \Lit{\}} nからm回発生する
\end{itemize}

\item[例:] 
以下の例では、\texttt{Reset}の呼び出しでスタートし、1から4回スタックに\texttt{Push}し、
1から3回スタックから\texttt{Pop}されるような、全ての可能なテストケースの組み合わせが生成される。

\begin{alltt}
\keyw{class} Stack

  \keyw{instance variables}
    stack : \keyw{seq of int} := [];

  \keyw{operations}

    \keyw{public} Reset : () ==> ()
    Reset () ==
      stack := [];

    \keyw{public} Pop : () ==> \keyw{int}
    Pop() ==
      \keyw{def} res = \keyw{hd} stack \keyw{in}
        (stack := \keyw{tl} stack;
         \keyw{return} res)
    \keyw{pre} stack <> []
    \keyw{post} stack~ = [\keyw{RESULT}] ^ stack;

    \keyw{public} Push: \keyw{int} ==> ()
    Push(elem) ==
      stack := stack ^ [elem];

    \keyw{public} Top : () ==> \keyw{int}
    Top() ==
      \keyw{return} (\keyw{hd} stack);

\keyw{end} Stack
\keyw{class} UseStack

\keyw{instance variables}

  s : Stack := \keyw{new} Stack();

\keyw{traces}

  PushBeforePop : s.Reset(); (\keyw{let} x \keyw{in set} {1,2} \keyw{in} s.Push(x))\{1,4\}; 
                  s.Pop()\{1,3\}
 
\keyw{end} UseStack
\end{alltt}
\end{description}

#endif VDMPP
#ifdef VDMSL
%\section{Differences between IFAD VDM-SL
%         and\\      ISO/VDM-SL}\label{diff}
\section{VDM-SLと ISO /VDM-SL の相違点}\label{diff}
#endif VDMSL
#ifdef VDMPP
\section{VDM++と ISO /VDM-SL の相違点}\label{diff}
#endif VDMPP

  \vdmslpp{\vdmsl}{\vdmpp} のこの版は ISO/VDM-SL 標準を基本とするが、少しだけ異なる点がある。
これらの相違は構文上および意味定義上の両面にあり、主に言語の拡張に起因するもので\vdmslpp{\vdmsl}{\vdmpp}構成要素を実行可能なものにしようとする要求に原因がある\footnote{ここでの意味定義とはインタープリタの意味定義のことである。}。

#ifdef VDMSL
%The major difference between IFAD {\vdmsl} and
%ISO/VDM-SL is the availability of a structuring in IFAD VDM-SL. This
%causes some syntactical differences.
{\vdmsl}とISO/VDM-SLの主要な違いはVDM-SLの構造化の利用である。これは構文の違いが原因である。

%For the flat part of IFAD VDM-SL, the following differences with ISO/VDM-SL exist:
VDM-SLのフラット部分に対して、ISO/VDM-SLは以下の違いが存在している:
#endif VDMSL

#ifdef VDMPP
{\vdmpp} と ISO/VDM-SLの間の大きな違いは、 \vdmpp で利用できるオブジェクト指向と同時処理 %and 
の拡張である。
これはいくつかの構文上の違いを引起す。

一番には、  \vdmpp\ 仕様記述はクラス定義の集合で構成される。
平坦な ISO/VDM-SL 仕様記述は取り入れていない。
\vdmpp の定義節に関して、以下に述べるような ISO/VDM-SLとの違いが存在する:
#endif VDMPP

\begin{description}
\item[構文上の相違:]\mbox{}\\
  \begin{itemize}
  
  \item 標準では部分列構成要素間 (たとえば関数定義間) の分離符としてセミコロン (``;'') が使われる。
  \vdmslpp{\vdmsl}{\vdmpp} ではこの規則に、このような構成要素の列の最後尾に随意でセミコロンをつけることができることを付け加える。
この変更は以下に述べる構文上の定義に対しても適用される (付録 \ref{app-a}を参照)
: \vdmslpp{{\em 状態定義},}{} {\em 型定義}, {\em 値定義},
    {\em 関数定義}, {\em 操作定義}, {\em def式
    }, {\em def文}, {\em ブロック文}。

  \item 陽関数定義および操作定義においては、 \vdmslpp{VDM-SL}{\vdmpp} におけるオプションの事後条件を指定することが可能である(第~\ref{functiondef} 節と第~\ref{op-def}節、または第~\ref{functiondef2}節か~\ref{op-def2}節を参照)。

  \item 陽関数定義および操作定義の本体は \vdmslpp{節}{節
    \keyw{is subclass responsibility}と}\keyw{is not yet specified}を用いて仮の方法で指定することができる。

#ifdef VDMPP
%  \item In function and operation definitions it is possible
%    to specify an optional time post condition in IFAD {\vdmpp}.
#endif VDMPP
    
  \item 陽関数定義および操作定義に対する拡張形式が組み入れられてきた。
拡張は、陰仕様定義に用いられたのと同様の見出しの使用を、関数と操作の定義で可能にするものである。
これはまず最初に陰仕様定義を書くことをより容易にし、そしてアルゴリズム部分を後に続けて加えることを容易にする。 
加えて、結果識別子の型ペアは2つ以上の識別子とともに働くために生成されたものである。

#ifdef VDMSL
  フラット仕様記述では、\keyw{definitions}というキーワードは使用されない。このように、いくつかの
ファイルの上にフラット仕様記述を分配することができる。
しかしながら、モジュール内では、定義部は \keyw{definitions}というキーワードで始まらなければならない。
(第~\ref{flat}節参照)

%  \item IFAD \vdmsl\ has been extended with the {\em specification statement}.
  \vdmsl\ は {\em specification statement} (仕様記述文)で拡張された。
#endif VDMSL

  \item  {\it if文\/} の中で ``else'' 部はオプションである (第~\ref{condstmt}節または第~\ref{condstmt2}節参照)
        
  \item 空集合と空列は直接にパターンとして用いることができる (第~\ref{patterns}節か~\ref{patterns2}節参照)
  \item ``制限する写像定義域'' と ``制限される写像定義域'' は適切にグループ化される (第~\ref{grouping}節参照)
  \item 写像型構成子に対する演算子優先順位は標準と異なる (第~\ref{preceedence}章参照)
  \item \vdmpp\ においては、組選択、型判断、事前条件式が加わる
  \item \vdmpp\ においては、原子代入文が加わる
#ifdef VDMPP
  \item  \vdmpp\ においては、 {\em 定義} が  {\em インスタンス変数定義}、
   %{\em time variable definitions}、
   {\em スレッド定義}、{\em 同期定義}にて拡張される

  \item  \vdmpp\ においては、以下の式が加わる:
    {\em new式}, {\em self式}, {\em isofbaseclass式}, {\em 
    isofclass式}, {\em samebaseclass式}, {\em
    sameclass式}, {\em act式}, {\em fin式},
    {\em active式}, {\em req式}, {\em waiting式}

  \item  \vdmpp\ においては、以下の文が加わる:
 {\em  仕様記述文}, {\em select文},
 {\em start文}そして {\em startlist文} % and {\em delay statement}.

  \item  \vdmsl\ 状態定義は \vdmpp\ インスタンス変数に置き換えられた。
#endif VDMPP


  \end{itemize}
  
\item[意味定義上の相違 (wrt.\ インタープリタ):]\mbox{}\\[-3mm] 
  \begin{itemize}
  
  \item  \vdmslpp{\vdmsl}{\vdmpp} は条件論理によってのみ動作する (第~\ref{bool}節参照)。
    
#ifdef VDMSL
  \item グローバル状態の初期化を、特別に構造的な方法で書かなければならない。
    少なくとも、モジュールからある操作が行われたら、モジュールの状態は初期化のみされることに注意する。
    (第~\ref{statedef}節参照)。
#endif VDMSL

  \item  \vdmslpp{\vdmsl}{\vdmpp}においては、相互に再帰する{\it 値定義\/}は実行不可能であり、またそれらは用いられる前に定義されているように順序付けられなければならない (第~\ref{valuedef}節参照)。
    
  \item  {\it let文\/}と{\it  let式\/}におけるローカル定義は再帰的に定義されることは許されない。
さらにそれらは用いられる前に定義されているように順序付けられなければならない(第~\ref{let-exp}節と第~\ref{letstmt}節参照)。 
    
  \item \vdmslpp{\vdmsl}{\vdmpp}における数値型 \keyw{rat} は型 \keyw{real}と同じ型を表す (第~\ref{numeric}節参照)。   
      
  \item   ISO/VDM-SL において用いられるインタープリタ実行の自由度の2つの形式 は `劣決定系' と `非決定系である。 
 ISO/VDM-SL の操作における自由度では、関数に対して劣決定系である場合はすべて非決定系となる。
 \vdmslpp{\vdmsl}{\vdmpp}においては、操作と関数の両方における自由度は劣決定系である。
これはしかしながら、標準と一致するものでもある、なぜならインタープリタは単に仕様記述に対する可能な様式のひとつに相応するからである。

  \end{itemize}
\end{description}

\section{静的意味}\label{static}

構文規則に従った構文的に正しいVDM 仕様記述でも、必ずしも言語の型やスコープの規則に従ってはいない。
VDM仕様記述が良形であるかについては、 {\em 静的意味チェッカー}によって検査することができる。
Toolbox にはこのような静的意味チェッカー(プログラム言語では通常は型検査と呼ばれる)が存在する。

一般的に、与えられた VDM仕様記述が良形か否かは、静的に決定可能であるとはいえない。
\vdmslpp{\vdmsl}{\vdmpp}\ の静的意味は他の言語の静的意味とは異なる。他の言語は絶対的に良形だとはいえない仕様記述のみを拒絶し、また絶対的に良形で
ある仕様記述のみを受け入れる。 
\vdmslpp{\vdmsl}{\vdmpp}\ の静的意味は、VDM 仕様記述に対する {\em 良形である度合} があるものと考える。
このような良形である度合は、仕様記述が絶対的に良形であるか、絶対的に良形でないか、恐らく良形か、を示すものである。

このことは Toolbox において、静的意味チェッカーが、恐らくの正しさかあるいは絶対的な正しさかどちらかをチェックできることを意味する。
しかしながら、ただのほんとに単純な仕様記述のみが、絶対的良形であることのチェックにパスすることができるのだ、ということを記しておくべきであろう。
したがって、実際的な使用においては``恐らく良形''がもっとも役に立つ。

恐らく良形のチェックと絶対的良形のチェックの間の相違は、以下に続く VDM 仕様記述の断片によって実例をもって示すことができる:
\begin{alltt}
   \keyw{if} a = \keyw{true} 
   \keyw{then} a + 1 
   \keyw{else} \keyw{not} a
\end{alltt}
ここで {\tt a} は型 {\tt \keyw{nat} | \keyw{bool}} (\keyw{nat} と\keyw{bool}の合併型)をもっている。 
もし {\tt a}が \keyw{true} と等しいならば、そのとき{\tt a}に1を加えることは不可能となるであろうから、この式は悪形であると読者は簡単に理解することができる。
しかしながら、このような式は恣意的に複雑になり得るので、一般的にはこれが静的にチェックされる可能性はない。
この特別な例において、絶対的な良形であることは \keyw{false} となる一方で、恐らく良形であることは\keyw{true}となるであろう。

#ifdef VDMPP
\section{スコープ衝突}
\label{sec:nameconflicts}

名前衝突は、同じ名称の(つまり\ 同じ {\em 識別子}によって識別された)2つの構成要素が同じスコープ内に見えているときにおきる。 
2つのこのような構成要素、たとえば同じ名称の型と操作、が同じ言語の範疇にはないときに、これはまた真である。
名前衝突のある仕様記述は誤っているものとみなされる。

両方の構成要素が同じクラスで定義されていたら、その場合には構成要素の1つの名称をつけ直す以外に衝突を解決することはできない。
もしそれらが異なるクラスで定義されているならば、その場合に衝突は {\em 名前限定}を通して解決することができる、つまり構成要素のひとつは、そこで定義されたクラスの名称と\Lit{`} (バッククォート)分離符を前に付ける、たとえば次のように。
  \begin{alltt}
    types
      Queue = seq of ComplexTypes`RealNumber
  \end{alltt}
名前限定は、クラス {\tt ComplexTypes}の中で定義された型{\tt RealNumber}に関して 型{\tt キュー} を定義するために用いられる。

{\em クラス名称}が名前衝突を解決するために用いられるような名前限定のみが、分離符として\Lit{`} 記号を用いることに注意しよう;\Lit{.} (ドット) 記号は通常の値やあるいはオブジェクトを `限定' するために用いられる。
たとえばこの表記
  \begin{alltt}
    o.i
  \end{alltt}
これはオブジェクトのインスタンス変数 {\tt i} または合成値 (レコード) {\tt o}の項目 {\tt i}を参照することが許される。
#endif VDMPP


\newpage

\bibliographystyle{iptes}
%\bibliographystyle{iptes}
#ifdef VDMSL
\bibliography{ifad}
#endif
#ifdef VDMPP
\bibliography{ifad}
#endif

\newpage
\appendix

% Do not delete next line:
% Start Of Rules

#ifdef VDMSL
%\section{The IFAD VDM-SL Syntax} \label{app-a} This appendix specifies the complete syntax for IFAD VDM-SL.
\section{VDM-SL構文} \label{app-a} この付録はVDM-SLの完全な構文を明確にするものである。
#endif VDMSL
#ifdef VDMPP
\section{VDM++構文} \label{app-a}
この付録では \vdmpp の全構文を示す。
#endif VDMPP
#ifdef VDMSL
\subsection{文書}

\Ruledef{文書}{
  \Ruleref{任意のモジュール}, \SeqPt{\Ruleref{任意のモジュール}} \dsep
   \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }

\Ruledef{任意のモジュール}{
  \Ruleref{モジュール} \dsep
  \Ruleref{動的リンクモジュール}
  }

\subsection{モジュール}

この全体の小区分はVDM-SL標準の最新版で存在しない。\marginpar{\hspace*{-3mm}\fbox{{\footnotesize 標準ではない}}}

\Ruledef{モジュール}{
  \Lop{module}, \Ruleref{識別子}, \Ruleref{インタフェース}, \lfeed
  \OptPt{\Ruleref{モジュール本体}}, \Lop{end}, \Ruleref{識別子}
  }

\Ruledef{インタフェース}{
  \OptPt{\Ruleref{輸入定義リスト}}, \lfeed
  \Ruleref{輸出定義}
  }

\Ruledef{輸入定義リスト}{
  \Lop{imports}, \Ruleref{輸入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{輸入定義}}
  }

\Ruledef{輸入定義}{
  \Lop{from}, \Ruleref{識別子}, \Ruleref{輸入モジュールシグネチャ}
  }

\Ruledef{輸入モジュールシグネチャ}{
  \Lop{all} \dsep
  \Ruleref{輸入シグネチャ}, \SeqPt{\Ruleref{輸入シグネチャ}}
  }

\Ruledef{輸入シグネチャ}{
  \Ruleref{輸入型シグネチャ} \dsep
  \Ruleref{輸入値シグネチャ} \dsep
  \Ruleref{輸入関数シグネチャ} \dsep
  \Ruleref{輸入操作シグネチャ}
%  \dsep
%  \Ruleref{state signature}
  }

\Ruledef{輸入型シグネチャ}{
  \Lop{types}, \Ruleref{型輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{型輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{型輸入}{
  \Ruleref{名称}, \OptPt{\Lop{renamed}, \Ruleref{名称}} \dsep
  \Ruleref{型定義}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸入値シグネチャ}{
  \Lop{values}, \Ruleref{値輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{値輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{値輸入}{
  \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{型}}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸入関数シグネチャ}{
  \Lop{functions}, \Ruleref{関数輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{関数輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{関数輸入}{
  \Ruleref{名称}, \OptPt{\OptPt{型変数リスト}, 
  \Lit{:}, \Ruleref{関数型}}, \lfeed
  \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸入操作シグネチャ}{
  \Lop{operations}, \Ruleref{操作輸入}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{操作輸入}}, \OptPt{\Lit{;}}
  }

\Ruledef{操作輸入}{
  \Ruleref{名称}, \OptPt{\Lit{:}, \Ruleref{操作型}}, \OptPt{\Lop{renamed}, \Ruleref{名称}}
  }

\Ruledef{輸出定義}{
  \Lop{exports}, \Ruleref{輸出モジュールシグネチャ}
  }

\Ruledef{輸出モジュールシグネチャ}{
  \Lop{all} \dsep
  \Ruleref{輸出シグネチャ}, \lfeed
  \SeqPt{\Ruleref{輸出シグネチャ}}
  }

\Ruledef{輸出シグネチャ}{
  \Ruleref{輸出型シグネチャ} \dsep
  \Ruleref{値群シグネチャ} \dsep
  \Ruleref{輸出関数シグネチャ} \dsep
  \Ruleref{操作群シグネチャ}
%  \dsep
%  \Ruleref{状態シグネチャ}
  }

\Ruledef{輸出型シグネチャ}{
  \Lop{types}, \Ruleref{型輸出}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{型輸出}}, \OptPt{\Lit{;}}
  }

\Ruledef{型輸出}{
  \OptPt{\Lop{struct}}, \Ruleref{名称}
  }

\Ruledef{値群シグネチャ}{
  \Lop{values}, \Ruleref{値シグネチャ}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{値シグネチャ}}, \OptPt{\Lit{;}}
  }

\Ruledef{値シグネチャ}{
  \Ruleref{名称リスト}, \Lit{:}, \Ruleref{型}
  }

\Ruledef{輸出関数シグネチャ}{
  \Lop{functions} \Ruleref{関数輸出}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{関数輸出}}, \OptPt{\Lit{;}}
  }

\Ruledef{関数輸出}{
  \Ruleref{名称リスト}, \OptPt{\Ruleref{型変数リスト}}, \Lit{:}, \lfeed
  \Ruleref{関数型}
  }
  
\Ruledef{関数群シグネチャ}{
  \Lop{functions} \Ruleref{関数シグネチャ}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{関数シグネチャ}}, \OptPt{\Lit{;}}
  }

\Ruledef{関数シグネチャ}{
    \Ruleref{名称リスト}, \Lit{:}, \Ruleref{関数型}
  }

\Ruledef{操作群シグネチャ}{
  \Lop{operations} \Ruleref{操作シグネチャ}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{操作シグネチャ}}, \OptPt{\Lit{;}}
  }

\Ruledef{操作シグネチャ}{
  \Ruleref{名称リスト}, \Lit{:}, \Ruleref{操作型}
  }
  
%\Ruledef{状態シグネチャ}{
%  \Lop{state}, \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
%  }
 
\Ruledef{動的リンクモジュール}{
  \Lop{dlmodule}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンクインタフェース},\lfeed
  \OptPt{\Ruleref{useシグネチャ}},\lfeed
  \Lop{end}, \Ruleref{識別子}
  }

\Ruledef{動的リンクインタフェース}{
  \OptPt{\Ruleref{動的リンク輸入定義リスト}}, \lfeed
  \Ruleref{動的リンク輸出定義}
  }

\Ruledef{useシグネチャ}{
   \Lop{uselib}, \Ruleref{テキストリテラル}
   }

\Ruledef{動的リンク輸入定義リスト}{
  \Lop{imports}, \lfeed
  \Ruleref{動的リンク輸入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{動的リンク輸入定義}}
  }

\Ruledef{動的リンク輸入定義}{
  \Lop{from}, \Ruleref{識別子}, \lfeed
  \Ruleref{動的リンク輸入型シグネチャ群}
  }

\Ruledef{動的リンク輸入型シグネチャ群}{
  \Lop{types}, \Ruleref{名称}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{名称}}, \OptPt{\Lit{;}}
  }

\Ruledef{動的リンク輸出定義}{
  \Lop{exports}, \lfeed
  \Ruleref{動的リンク輸出シグネチャ}, \lfeed
  \SeqPt{\Ruleref{動的リンク輸出シグネチャ}}
  }

\Ruledef{動的リンク輸出シグネチャ}{
  \Ruleref{値群シグネチャ} \dsep
  \Ruleref{関数群シグネチャ} \dsep
  \Ruleref{操作群シグネチャ}
  }
#endif VDMSL
#ifdef VDMPP
\subsection{文書}

\Ruledef{文書}{
   \Ruleref{クラス}
#ifdef VICEMAN
   \dsepl\ \Ruleref{システム}
#endif VICEMAN
   , \SeqPt{\Ruleref{クラス}
#ifdef VICEMAN
   \dsepl\ \Ruleref{システム}
#endif VICEMAN
   }
}

#ifdef VICEMAN
\subsection{システム}
\Ruledef{システム}{
  \Lop{system}, \Ruleref{識別子},  \lfeed
  \OptPt{\Ruleref{クラス本体}}, \lfeed
  \Lop{end}, \Ruleref{識別子}
}
#endif VICEMAN

\subsection{クラス}
\Ruledef{クラス}{
  \Lop{class}, \Ruleref{識別子}, \OptPt{\Ruleref{継承節}}, \lfeed
  \OptPt{\Ruleref{クラス本体}}, \lfeed
  \Lop{end}, \Ruleref{識別子}
}

\Ruledef{継承節}{
      \Lop{is subclass of}, \Ruleref{識別子}, \Lit{,}, \SeqPt{\Ruleref{識別子}}
      }
#endif VDMPP
\subsection{定義}

#ifdef VDMPP
\Ruledef{クラス本体}{
  \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }
#endif VDMPP 

#ifdef VDMSL
\Ruledef{モジュール本体}{
  \Lop{definitions}, \Ruleref{定義ブロック}, \SeqPt{\Ruleref{定義ブロック}}
  }
#endif VDMSL

\Ruledef{定義ブロック}
{
  \Ruleref{型定義群} \dsep
#ifdef VDMSL
  \Ruleref{状態定義群} \dsep
#endif VDMSL
  \Ruleref{値定義群} \dsep
  \Ruleref{関数定義群} \dsep
  \Ruleref{操作定義群}
#ifdef VDMPP
  \dsep
  \Ruleref{インスタンス変数定義} \dsep
%  \Ruleref{time variable definitions} \dsep
  \Ruleref{同期定義} \dsep
  \Ruleref{スレッド定義} \dsep
  \Ruleref{traces定義}
#endif VDMPP
  }

\subsubsection{型定義}
\label{mathCSTypeDefs}

\Ruledef{型定義群}{
  \Lop{types}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス型定義}}%
                                     {\Ruleref{型定義}}
         , \lfeed
         \SeqPt{\Lit{;}, 
               \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス型定義}}%
                                           {\Ruleref{型定義}}}, 
         \OptPt{\Lit{;}}
        }
  }%
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{アクセス型定義}{
     (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed 
     \Ruleref{型定義}
    }
  }{}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{アクセス}{
    \Lop{public} \dsep \Lop{private} \dsep \Lop{protected}
  }
}{}

\Ruledef{型定義}{
  \Ruleref{識別子}, \Lit{=}, \Ruleref{型}, \OptPt{\Ruleref{不変条件}} \dsep
  \Ruleref{識別子}, \Lit{::}, \Ruleref{項目リスト}, \OptPt{\Ruleref{不変条件}}
  }

\Ruledef{型}{
  \Ruleref{括弧型} \dsep
  \Ruleref{基本型} \dsep
  \Ruleref{引用型} \dsep
  \Ruleref{レコード型} \dsep
  \Ruleref{合併型} \dsep
  \Ruleref{組型} \dsep
  \Ruleref{選択型} \dsep
  \Ruleref{集合型} \dsep
  \Ruleref{列型} \dsep
  \Ruleref{写像型} \dsep
  \Ruleref{部分関数型} \dsep
  \Ruleref{型名称} \dsep
  \Ruleref{型変数}
  }

\Ruledef{括弧型}{
  \Lit{(}, \Ruleref{型}, \Lit{)}
  }

\Ruledef{基本型}{
  \Lop{bool} \dsepl
  \Lop{nat} \dsepl
  \Lop{nat1} \dsepl
  \Lop{int} \dsepl
  \Lop{rat} \dsep
  \Lop{real} \dsepl
  \Lop{char} \dsepl
  \Lop{token} 
  }

\Ruledef{引用型}{
   \Lit{<}, \Ruleref{引用リテラル}, \Lit{>}
  }

\Ruledef{レコード型}{
  \Lop{compose}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \Lop{end}
  }

\Ruledef{項目リスト}{
  \SeqPt{\Ruleref{項目}}
  }

\Ruledef{項目}{
  \OptPt{\Ruleref{識別子}, \Lit{:}}, \Ruleref{型} \dsep
  \OptPt{\Ruleref{識別子}, \Lit{:-}}, \Ruleref{型}
  }

\Ruledef{合併型}{
  \Ruleref{型}, \Lit{|}, \Ruleref{型}, \SeqPt{\Lit{|}, \Ruleref{型}}
  }

\Ruledef{組型}{
  \Ruleref{型}, \Lit{*}, \Ruleref{型}, \SeqPt{\Lit{*}, \Ruleref{型}}
  }

\Ruledef{選択型}{
  \Lit{[}, \Ruleref{型}, \Lit{]}
  }

\Ruledef{集合型}{
  \Lop{set of}, \Ruleref{型}
  }

\Ruledef{列型}{
  \Ruleref{空列を含む列型} \dsep
  \Ruleref{空列を含まない列型}
  }

\Ruledef{空列を含む列型}{
  \Lop{seq of}, \Ruleref{型}
  }

\Ruledef{空列を含まない列型}{
  \Lop{seq1 of}, \Ruleref{型}
  }

\Ruledef{写像型}{
  \Ruleref{一般写像型} \dsep
  \Ruleref{1対1写像型}
  }

\Ruledef{一般写像型}{
  \Lop{map}, \Ruleref{型}, \Lop{to}, \Ruleref{型}
  }

\Ruledef{1対1写像型}{
  \Lop{inmap}, \Ruleref{型}, \Lop{to}, \Ruleref{型}
  }

\Ruledef{関数型}{
  \Ruleref{部分関数型} \dsep
  \Ruleref{全関数型}
  }

\Ruledef{部分関数型}{
  \Ruleref{任意の型}, \Lit{->}, \Ruleref{型}
  }

\Ruledef{全関数型}{
  \Ruleref{任意の型}, \Lit{+>}, \Ruleref{型}
  }

\Ruledef{任意の型}{
  \Ruleref{型} \dsep
  \Lit{(}, \Lit{)}
  }

\Ruledef{型名称}{
  \Ruleref{名称}
  }

\Ruledef{型変数}{
  \Ruleref{型変数識別子}
  }

#ifdef VDMPP
\Ruledef{不変条件}{
  \Lop{inv}, \Ruleref{不変条件初期関数}
  }

\Ruledef{不変条件初期関数}{
  \Ruleref{パターン}, \Lit{==}, \Ruleref{式}
  }
#endif VDMPP

#ifdef VDMSL
\subsubsection{状態定義}

\Ruledef{状態定義}{
  \Lop{state}, \Ruleref{識別子}, \Lop{of}, \Ruleref{項目リスト}, \lfeed
  \OptPt{\Ruleref{不変条件}}, \OptPt{\Ruleref{初期化}}, \Lop{end}, \OptPt{\Lit{;}}
  }\nonstandard{1}
\Ruledef{不変条件}{
  \Lop{inv}, \Ruleref{不変条件初期関数}
  }

\Ruledef{初期化}{
  \Lop{init}, \Ruleref{不変条件初期関数}
  }

\Ruledef{不変条件初期関数}{
  \Ruleref{パターン}, \Lit{==}, \Ruleref{式}
  }
#endif VDMSL

\subsubsection{値定義}

\Ruledef{値定義群}{
  \Lop{values}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                     {\Ruleref{値定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス値定義}}%
                                            {\Ruleref{値定義}}
               }, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Rule{アクセス値定義}{
       (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed 
         \Ruleref{値定義}
    }}{}

\Ruledef{値定義}{ 
  \Ruleref{パターン}, \OptPt{\Lit{:}, \Ruleref{型}}, \Lit{=}, \Ruleref{式}
  }
  \nonstandard{1}

\subsubsection{関数定義}\label{functiondef2}

\Ruledef{関数定義群}{
  \Lop{functions}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス関数定義}}%
                                     {\Ruleref{関数定義}}}, 
         \OptPt{\Lit{;}}
        }
  }
  \nonstandard{1}

\ifthenelse{\boolean{VDMpp}}{
  \Ruledef{アクセス関数定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\  (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{関数定義}
  }}{}

\Ruledef{関数定義}{
  \Ruleref{陽関数定義} \dsep
  \Ruleref{陰関数定義} \dsep
  \Ruleref{拡張陽関数定義}
  }
  \nonstandard{1}

\Ruledef{陽関数定義}{
  \Ruleref{識別子},
  \OptPt{\Ruleref{型変数リスト}},
  \Lit{:}, \lfeed
  \Ruleref{関数型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーターリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}
    , \lfeed \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed

  \OptPt{\Lop{measure}, \Ruleref{名称}}
  }
  \nonstandard{1}

\Ruledef{陰関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed 
  \Ruleref{パラメーター型}, \lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}
  }

%This should be removed and exchanged with a more general solution.
#ifdef VDMSL
\setlength{\nonstandlen}{-2\baselineskip}\addtolength{\nonstandlen}{-.8ex}

\vspace{\nonstandlen}\mbox{}\marginpar{\hspace*{-3mm}\raisebox{\nonstandlen}[0pt][0pt]{{\fbox{{\footnotesize Non standard}}}}}
\Ruledef{拡張陽関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed
  \Ruleref{パラメーター型}, \lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
}
#endif VDMSL
#ifdef VDMPP
\Ruledef{拡張陽関数定義}{
  \Ruleref{識別子}, \OptPt{\Ruleref{型変数リスト}}, \lfeed
  \Ruleref{パラメーター型}, \lfeed
  \Ruleref{識別子型ペアリスト}, \lfeed
  \Lit{==}, \Ruleref{関数本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
}
#endif VDMPP

\Ruledef{型変数リスト}{
  \Lit{[}, \Ruleref{型変数識別子}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{型変数識別子}}, \Lit{]}
  }             

\Ruledef{識別子型ペア}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}
  }

\Ruledef{パラメーター型}{
  \Lit{(}, \OptPt{\Ruleref{パターン型ペアリスト}}, \Lit{)}
  }

\Ruledef{識別子型ペアリスト}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{識別子}, \Lit{:}, \Ruleref{型}}
}

\Ruledef{パターン型ペアリスト}{
  \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{パターンリスト},\Lit{:}, \Ruleref{型}}
  }

\Ruledef{パラメーターリスト}{
  \Ruleref{パラメーター群}, \SeqPt{\Ruleref{パラメーター群}}
  }

\Ruledef{パラメーター群}{
  \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }

\Ruledef{関数本体}{
  \Ruleref{式} \dsep
#ifdef VDMPP
  \Lop{is not yet specified} \dsep \Lop{is subclass responsibility}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified} 
#endif VDMSL
  } \nonstandard{1}

\subsubsection{操作定義}\label{op-def2}

\Ruledef{操作定義群}{
  \Lop{operations}, 
  \OptPt{\ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                     {\Ruleref{操作定義}}, \lfeed
         \SeqPt{\Lit{;}, 
                \ifthenelse{\boolean{VDMpp}}{\Ruleref{アクセス操作定義}}%
                                     {\Ruleref{操作定義}}
               }, 
         \OptPt{\Lit{;}}
        }
  }\nonstandard{1}

  \ifthenelse{\boolean{VDMpp}}{
    \Ruledef{アクセス操作定義}{(
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsep\  
     (
#ifdef VICEMAN
      \OptPt{\Lop{async}}
#endif VICEMAN
      \OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
      \Ruleref{操作定義}
    }}{}

\Ruledef{操作定義}{
  \Ruleref{陽操作定義} \dsep
  \Ruleref{陰操作定義} \dsep
  \Ruleref{拡張陽操作定義}
  }\nonstandard{1}

\Ruledef{陽操作定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{操作型}, \lfeed
  \Ruleref{識別子}, \Ruleref{パラメーター群}, \lfeed
  \Lit{{\tt ==}}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}
#ifdef VDMPP
  , \lfeed
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}
#endif VDMPP
  }\nobreak\nonstandard{1}

\Ruledef{陰操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Ruleref{陰操作本体}
  }

\Ruledef{陰操作本体}{
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \Lop{post}, \Ruleref{式}, \lfeed
#ifdef VDMPP
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{例外}}
  }

\Ruledef{拡張陽操作定義}{
  \Ruleref{識別子}, \Ruleref{パラメーター型}, \lfeed
  \OptPt{\Ruleref{識別子型ペアリスト}}, \lfeed
  \Lit{==}, \Ruleref{操作本体}, \lfeed
  \OptPt{\Ruleref{外部節}}, \lfeed
  \OptPt{\Lop{pre}, \Ruleref{式}}, \lfeed
  \OptPt{\Lop{post}, \Ruleref{式}}, \lfeed
#ifdef VDMPP
%  \OptPt{\Lop{time}, \Lop{post}, \Ruleref{expression}}, \lfeed
#endif VDMPP
  \OptPt{\Ruleref{例外}}
}\nonstandard{7}

\Ruledef{操作型}{
  \Ruleref{任意の型}, \Lit{==>}, \Ruleref{任意の型}
  }

\Ruledef{操作本体}{
  \Ruleref{文} \dsep 
#ifdef VDMPP
  \Lop{is not yet specified} \dsep \Lop{is subclass responsibility}
#endif VDMPP
#ifdef VDMSL
  \Lop{is not yet specified}
#endif VDMSL
  } \nonstandard{1}

\Ruledef{外部節}{
  \Lop{ext}, \Ruleref{var情報}, \SeqPt{\Ruleref{var情報}}
  }

\Ruledef{var情報}{
  \Ruleref{モード}, \Ruleref{名称リスト}, \OptPt{\Lit{:}, \Ruleref{型}}
  }

\Ruledef{モード}{
  \Lop{rd} \dsepl \Lop{wr}
  }

\Ruledef{例外}{
  \Lop{errs}, \Ruleref{エラーリスト}
  }

\Ruledef{エラーリスト}{
  \Ruleref{エラー}, \SeqPt{エラー}
  }

\Ruledef{エラー}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{式}, \Lit{->}, \Ruleref{式}
  }

#ifdef VDMPP
\subsubsection{インスタンス変数定義}

\Ruledef{インスタンス変数定義群}{
  \Lop{instance}, \Lop{variables}, \lfeed
  \OptPt{\Ruleref{インスタンス変数定義}, \lfeed
         \SeqPt{\Lit{;}, 
               \Ruleref{インスタンス変数定義}
               }
        }
  }

\Ruledef{インスタンス変数定義}{
  \Ruleref{アクセス指定定義} \dsep
  \Ruleref{不変条件定義}
  }

  \Ruledef{アクセス指定定義}{
    (\OptPt{\Ruleref{アクセス}}, \OptPt{\Lop{static}})  \dsepl\ (\OptPt{\Lop{static}}, \OptPt{\Ruleref{アクセス}}), \lfeed
    \Ruleref{代入定義}
  }
  
\Ruledef{代入定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=},
  \Ruleref{式}}
  }

\Ruledef{不変条件定義}{
  \Lop{inv}, \Ruleref{式}
  }

%\Ruledef{init文}{
%  \Lop{init}, \Ruleref{文}
%  }

%\subsubsection{Time Variable Definitions}
%
%\Ruledef{time variable definitions}{
%      \Lop{time}, \Lop{variables},
%      \Ruleref{time spec}, \SeqPt{\Lit{;}, \Ruleref{time spec}}, \OptPt{\Lop{;}}}
%\Ruledef{time spec}{
%      \Ruleref{time var decl} \dsep \Ruleref{assumption} \dsep \Ruleref{effect}}
%\Ruledef{time var decl}{
%      \OptPt{\Lop{input}}, \Ruleref{name list}, \Lit{:}, \Ruleref{type}}
%\Ruledef{assumption}{
%      \Lop{assumption}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}
%\Ruledef{effect}{
%      \Lop{effect}, \Ruleref{name list}, \Lit{==}, \Ruleref{expression}}
      
\subsubsection{同期定義}

\Ruledef{同期定義}{
      \Lop{sync}, \OptPt{\Ruleref{同期}}}

\Ruledef{同期}{
      \Ruleref{許可述語} %\dsep
%      \Ruleref{trace structures}
}

\Ruledef{許可述語}{
      \Ruleref{許可述語},\lfeed
      \SeqPt{\Lit{;}, \Ruleref{許可述語}}}
\Ruledef{許可述語}{
      \Lop{per}, \Ruleref{名称},
      \Lop{=$>$}, \Ruleref{式} \dsep
      \Ruleref{排他制御述語}}

\Ruledef{排他制御述語}{
       \Lop{mutex}, \Lit{(}, \Lop{all}, \Lit{)}  \dsep
       \Lop{mutex}, \Lit{(}, \Ruleref{名称リスト} \Lit{)}}

% \Ruledef{trace structures}{
%       \SeqPt{\Ruleref{subtrace structure}, \Lit{;}},
%       \Ruleref{general trace structure}}
% \Ruledef{subtrace structure}{
%       \Lop{subtrace}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}
% \Ruledef{general trace structure}{
%       \Lop{general}, \Ruleref{name}, \Lit{=}, \Ruleref{trace structure}}

% \Ruledef{trace structure}{
%      \Ruleref{identifier} \dsep
%      \Lit{$<$}, \Ruleref{trace set}, \Lit{,}, \Ruleref{alphabet}, \Lit{$>$} \dsep
%      \Lop{pref}, \Lit{(}, \Ruleref{trace structure}, \Lit{)} \dsep
%      \Lop{del}, \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{w\_}, \Ruleref{trace structure} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{sync}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Lit{(}, \Ruleref{numeric literal}, \Lit{,}, \Ruleref{numeric literal}, \Lit{)}, \Lop{{qsync}}, \lfeed
%      \Lit{(}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \lfeed
%      \Lit{,}, \Ruleref{name}, \Lit{,}, \Ruleref{name}, \Lit{)} \dsep
%      \Ruleref{trace structure}, \Lop{**}, \Ruleref{alphabet}}
% \Ruledef{alphabet}{
%       \Lit{\{}, \Ruleref{name}, \SeqPt{\Lit{,}, \Ruleref{name}}, \Lit{\}} \dsep
%       \Lop{a\_}, \Ruleref{trace structure}}

% \Ruledef{trace set}{
%      \Ruleref{trace expression} \dsepl
%      \Ruleref{alphabet}, \Lit{$\ast$} \dsepl
%      \Lop{t\_}, \Ruleref{trace structure}}
% \Ruledef{trace expression}{
%       \Ruleref{term}, \SeqPt{\Lit{;}, \Ruleref{term}}}
% \Ruledef{term}{
%       \Ruleref{cterm} \dsepl \Ruleref{cterm}, \Lit{+} \dsepl \Ruleref{cterm}, \Lit{*}}
% \Ruledef{cterm}{
%       \Lit{(}, \Ruleref{trace expression}, \Lit{)} \dsepl \Ruleref{name}}

\subsubsection{スレッド定義}

\Ruledef{スレッド定義}{ \Lop{thread},
    \OptPt{\Ruleref{スレッド定義}} } 

\Rule{スレッド定義}{
    \Ruleref{手続きスレッド定義} }

#ifdef VICEMAN
\Ruledef{周期スレッド定義}{
    \Ruleref{周期義務} }
  
\Ruledef{周期義務}{
  \Lop{periodic},\Lit{(}, \Ruleref{数字},
  \Ruleref{数字}, \Ruleref{数字}, \lfeed \Ruleref{数字}, 
  \Lit{)}, \Lit{(}, \Ruleref{名称}, \Lit{)}
}
#endif VICEMAN

\Ruledef{手続きスレッド定義}{
      \Ruleref{文}}

\subsubsection{traces定義}

\Ruledef{traces定義}{\Lop{traces},
   \SeqPt{\Ruleref{traces名}}
}

\Ruledef{traces名}{\Ruleref{識別子},
  \SeqPt{\Lit{/}, \Ruleref{識別子}},
  \Lit{:},\Ruleref{traces定義リスト}
}

\Ruledef{traces定義リスト}{
  \Ruleref{traces定義項}, 
  \SeqPt{\Lit{;}, \Ruleref{traces定義項}}
}

\Ruledef{traces定義項}{
  \Ruleref{traces定義} \dsep
  \Ruleref{traces定義項}, \Lit{|}, \Ruleref{traces定義}
}

\Ruledef{traces定義}{
  \Ruleref{tracesコア定義} \dsep
  \Ruleref{traces束縛群}, \Ruleref{tracesコア定義} \dsep
  \Ruleref{tracesコア定義}, \Ruleref{traces繰り返しパターン} \dsep
  \Ruleref{traces束縛群}, \Ruleref{tracesコア定義}, 
  \Ruleref{traces繰り返しパターン}
}

\Ruledef{tracesコア定義}{
  \Ruleref{traces適用式} \dsep
  \Ruleref{traces括弧式}
}

\Ruledef{traces適用式}{
  \Ruleref{識別子}, \Lit{.}, \Ruleref{識別子}, 
  \Lit{(}, \Ruleref{式リスト}, \Lit{)}
}

\Ruledef{traces繰り返しパターン}{
  \Lit{*} \dsep 
  \Lit{+} \dsep
  \Lit{?} \dsep
  \Lit{\{}, \Ruleref{数値リテラル}, \Lit{\}} \dsep
  \Lit{\{}, \Ruleref{数値リテラル}, \Lit{,} 
  \Ruleref{数値リテラル}, \Lit{\}}
} 

\Ruledef{traces括弧式}{
  \Lit{(}, \Ruleref{traces定義リスト}, \Lit{)}
}

\Ruledef{traces束縛群}{
  \Ruleref{traces束縛}, \SeqPt{\Ruleref{traces束縛}}
}

\Ruledef{traces束縛}{
  \Lop{let}, \Ruleref{ローカル定義}, 
             \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{束縛}, \Lop{in} \dsep
  \Lop{let}, \Ruleref{束縛}, \Lop{be}, \Lop{st}, \Ruleref{式}, \Lop{in}
}

#endif VDMPP

\subsection{式}

\Ruledef{式リスト}{
  \Ruleref{式}, \SeqPt{\Lit{,}, \Ruleref{式}}
  }

\Ruledef{式}{
  \Ruleref{括弧式} \dsep
  \Ruleref{let式} \dsep
  \Ruleref{let be式} \dsep
  \Ruleref{def式} \dsep
  \Ruleref{if式} \dsep
  \Ruleref{cases式} \dsep
  \Ruleref{単項式} \dsep
  \Ruleref{2項式} \dsep
  \Ruleref{限量式} \dsep
  \Ruleref{iota式} \dsep
  \Ruleref{集合列挙} \dsep
  \Ruleref{集合内包} \dsep
  \Ruleref{集合範囲式} \dsep
  \Ruleref{列列挙} \dsep
  \Ruleref{列内包} \dsep
  \Ruleref{部分列} \dsep
  \Ruleref{写像列挙} \dsep
  \Ruleref{写像内包} \dsep
%  \Ruleref{tuple constructor} \dsep
  \Ruleref{組構成子} \dsep
%  \Ruleref{record constructor} \dsep 
  \Ruleref{レコード構成子} \dsep 
  \Ruleref{レコード修正子}  \dsep
  \Ruleref{適用} \dsep
  \Ruleref{項目選択} \dsep
  \Ruleref{組選択} \dsep
  \Ruleref{関数型インスタンス化} \dsep
  \Ruleref{ラムダ式} \dsep
#ifdef VDMPP
  \Ruleref{new式} \dsep
  \Ruleref{narrow式} \dsep
  \Ruleref{self式} \dsep
  \Ruleref{スレッドID式} \dsep
#endif VDMPP
  \Ruleref{一般is式} \dsep
  \Ruleref{未定義式} \dsep
  \Ruleref{事前条件式} \dsep
#ifdef VDMPP
  \Ruleref{isofbaseclass式} \dsep
  \Ruleref{isofclass式} \dsep
  \Ruleref{samebaseclass式}  \dsep
  \Ruleref{sameclass式} \dsep
  \Ruleref{act式} \dsep
  \Ruleref{fin式} \dsep
  \Ruleref{active式} \dsep
  \Ruleref{req式} \dsep
  \Ruleref{waiting式} \dsep
#endif VDMPP
#ifdef VICEMAN
  \Ruleref{time式} \dsep
#endif VICEMAN
  \Ruleref{名称} \dsep
  \Ruleref{旧名称}  \dsep
  \Ruleref{記号リテラル}
}
\nonstandard{4}

\subsubsection{括弧式}

\Ruledef{括弧式}{
  \Lit{(}, \Ruleref{式}, \Lit{)}
  }

\subsubsection{ローカル束縛式}
 
\Ruledef{let式}{
  \Lop{let}, \Ruleref{ローカル定義},
   \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
  \Lop{in}, \Ruleref{式}
  }

\Ruledef{let be式}{
  \Lop{let}, \Ruleref{束縛},
  \OptPt{\Lop{be}, \Lop{st}, \Ruleref{式}}, \Lop{in}, \lfeed
  \Ruleref{式}
  }

\Ruledef{def式}{
  \Lop{def}, 
  \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{パターン束縛}, \Lit{=}, \Ruleref{式}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{式}
  }
  \nonstandard{2}

\subsubsection{条件式}

\Ruledef{if式}{
  \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{式},\lfeed
  \SeqPt{\Ruleref{elseif式}}, \lfeed
  \Lop{else}, \Ruleref{式}
  }

\Ruledef{elseif式}{
  \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{式}
  }

\Ruledef{cases式}{
  \Lop{cases}, \Ruleref{式}, \Lit{:},\lfeed 
  \Ruleref{cases式選択肢群}, \lfeed
  \OptPt{\Lit{,}, \Ruleref{others式}}, \Lop{end}
  }

\Ruledef{cases式選択肢群}{
  \Ruleref{cases式選択肢}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases式選択肢}}
  }

\Ruledef{cases式選択肢}{
  \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{式}
  }

\Ruledef{others式}{
  \Lop{others}, \Lit{->}, \Ruleref{式}
  }

\subsubsection{単項式}

\Ruledef{単項式}{
  \Ruleref{接頭辞式} \dsep
  \Ruleref{逆写像}
  }

\Ruledef{接頭辞式}{
  \Ruleref{単項演算子}, \Ruleref{式}
  }

\Ruledef{単項演算子}{
  \Ruleref{正符号} \dsep
  \Ruleref{負符号} \dsep
  \Ruleref{算術絶対値} \dsep
  \Ruleref{底値} \dsep
  \Ruleref{否定} \dsep
  \Ruleref{集合濃度} \dsep
  \Ruleref{有限べき集合} \dsep
  \Ruleref{分配的集合合併} \dsep
  \Ruleref{分配的集合共通部分} \dsep
  \Ruleref{列先頭} \dsep
  \Ruleref{列尾部} \dsep
  \Ruleref{列長} \dsep
  \Ruleref{列要素} \dsep
  \Ruleref{列索引} \dsep
  \Ruleref{分配的列連結} \dsep
  \Ruleref{写像定義域} \dsep
  \Ruleref{写像値域} \dsep
  \Ruleref{分配的写像併合}
  }

\Ruledef{正符号}{
  \Lit{+}
  }

\Ruledef{負符号}{
  \Lit{-}
  }

\Ruledef{算術絶対値}{
  \Lop{abs}
  }

\Ruledef{底値}{
  \Lop{floor}
  }

\Ruledef{否定}{
  \Lop{not}
  }

\Ruledef{集合濃度}{
  \Lop{card}
  }

\Ruledef{有限べき集合}{
  \Lop{power}
  }

\Ruledef{分配的集合合併}{
  \Lop{dunion}
  }

\Ruledef{分配的集合共通部分}{
  \Lop{dinter}
  }

\Ruledef{列先頭}{
  \Lop{hd}
  }

\Ruledef{列尾部}{
  \Lop{tl}
  }

\Ruledef{列長}{
  \Lop{len}
  }

\Ruledef{列要素}{
  \Lop{elems}
  }

\Ruledef{列索引}{
  \Lop{inds}
  }

\Ruledef{分配的列連結}{
  \Lop{conc}
  }

\Ruledef{写像定義域}{
  \Lop{dom}
  }

\Ruledef{写像値域}{
  \Lop{rng}
  }

\Ruledef{分配的写像併合}{
  \Lop{merge}
  }

\Ruledef{逆写像}{
  \Lop{inverse}, \Ruleref{式}
  }

\subsubsection{2項式}

\Ruledef{2項式}{
  \Ruleref{式}, \Ruleref{2項演算子}, \Ruleref{式}
  }

\Ruledef{2項演算子}{
  \Ruleref{加算} \dsep
  \Ruleref{減算} \dsep
  \Ruleref{乗算} \dsep
  \Ruleref{除算} \dsep
  \Ruleref{整数除算} \dsep
  \Ruleref{剰余算} \dsep
  \Ruleref{法算} \dsep
  \Ruleref{より小さい} \dsep
  \Ruleref{より小さいか等しい} \dsep
  \Ruleref{より大きい} \dsep
  \Ruleref{より大きいか等しい} \dsep
  \Ruleref{相等} \dsep
  \Ruleref{不等} \dsep
  \Ruleref{論理積} \dsep
  \Ruleref{論理和} \dsep
  \Ruleref{含意} \dsep
  \Ruleref{同値} \dsep
  \Ruleref{帰属} \dsep
  \Ruleref{非帰属} \dsep
  \Ruleref{包含} \dsep
  \Ruleref{真包含} \dsep
  \Ruleref{集合合併} \dsep
  \Ruleref{集合差} \dsep
  \Ruleref{集合共通部分} \dsep
  \Ruleref{列連結} \dsep
  \Ruleref{写像修正または列修正} \dsep
  \Ruleref{写像併合} \dsep
  \Ruleref{写像定義域限定} \dsep
  \Ruleref{写像定義域削減} \dsep
  \Ruleref{写像値域限定} \dsep
  \Ruleref{写像値域削減} \dsep
  \Ruleref{合成} \dsep
  \Ruleref{反復} 
}

\Ruledef{加算}{
  \Lit{+}
  }

\Ruledef{減算}{
  \Lit{-}
  }

\Ruledef{乗算}{
  \Lit{*}
  }

\Ruledef{除算}{
  \Lit{/}
  }

\Ruledef{整数除算}{
  \Lop{div}
  }

\Ruledef{剰余算}{
  \Lop{rem}
  }

\Ruledef{法算}{
  \Lop{mod}
  }

\Ruledef{より小さい}{
  \Lit{<}
  }

\Ruledef{より小さいか等しい}{
  \Lit{<=}
  }

\Ruledef{より大きい}{
  \Lit{>}
  }

\Ruledef{より大きいか等しい}{
  \Lit{>=}
  }

\Ruledef{相等}{
  \Lit{=}
  }

\Ruledef{不等}{
  \Lit{<>}
  }

%#ifdef VDMPP
%\Ruledef{約}{
%  \Lop{\~{}=}
%}
%#endif VDMPP
\Ruledef{論理和}{
  \Lop{or}
  }

\Ruledef{論理積}{
  \Lop{and}
  }

\Ruledef{含意}{
  \Lit{=>}
  }

\Ruledef{同値}{
  \Lit{<=>}
  }

\Ruledef{帰属}{
  \Lop{in set}
  }

\Ruledef{非帰属}{
  \Lop{not in set}
  }

\Ruledef{包含}{
  \Lop{subset}
  }

\Ruledef{真包含}{
  \Lop{psubset}
  }

\Ruledef{集合合併}{
  \Lop{union}
  }

\Ruledef{集合差}{
  \Lit{\char'134}
  }

\Ruledef{集合共通部分}{
  \Lop{inter}
  }

\Ruledef{列連結}{
  \Lit{\char'136}
  }

\Ruledef{写像修正または列修正}{
  \Lit{++}
  }

\Ruledef{写像併合}{
  \Lop{munion}
  }

\Ruledef{写像定義域限定}{
  \Lit{<:}
  }

\Ruledef{写像定義域削減}{
  \Lit{<-:}
  }

\Ruledef{写像値域限定}{
  \Lit{:>}
  }

\Ruledef{写像値域削減}{
  \Lit{:->}
  }

\Ruledef{合成}{
  \Lop{comp}
  }

\Ruledef{反復}{
  \Lit{**}
  }

\subsubsection{限量式}

\Ruledef{限量式}{
  \Ruleref{全称限量式} \dsep
  \Ruleref{存在限量式} \dsep
  \Ruleref{1存在限量式}
  }

\Ruledef{全称限量式}{
  \Lop{forall}, \Ruleref{束縛リスト}, \Lit{\&}, \Ruleref{式}
  }

\Ruledef{存在限量式}{
  \Lop{exists}, \Ruleref{束縛リスト}, \Lit{\&}, \Ruleref{式}
  }

\Ruledef{1存在限量式}{
  \Lop{exists1}, \Ruleref{束縛}, \Lit{\&}, \Ruleref{式}
  }

\subsubsection{iota式}

\Ruledef{iota式}{
  \Lop{iota}, \Ruleref{束縛}, \Lit{\&}, \Ruleref{式}
  }

\subsubsection{集合式}

\Ruledef{集合列挙}{
  \Lit{\{}, \OptPt{\Ruleref{式リスト}}, \Lit{\}}
  }

\Ruledef{集合内包}{
  \Lit{\{}, \Ruleref{式}, \Lit{|}, \Ruleref{束縛リスト}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{式}},
  \Lit{\}}
  }

\Ruledef{集合範囲式}{
  \Lit{\{}, \Ruleref{式}, \Lit{,}, \Lit{\Range}, \Lit{,},
  \lfeed
  \Ruleref{式},
  \Lit{\}}
  }

\subsubsection{列式}

\Ruledef{列列挙}{
  \Lit{[}, \OptPt{\Ruleref{式リスト}}, \Lit{]}
  }

\Ruledef{列内包}{
  \Lit{[}, \Ruleref{式}, \Lit{|}, \Ruleref{集合束縛}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{式}},
  \Lit{]}
  }

\Ruledef{部分列}{
  \Ruleref{式}, \Lit{(}, \Ruleref{式}, \Lit{,},
  \Lit{\Range}, \Lit{,}, \lfeed
  \Ruleref{式}, \Lit{)} 
  }

\subsubsection{写像式}

\Ruledef{写像列挙}{
  \Lit{\{}, \Ruleref{写}, \SeqPt{\Lit{,}, \Ruleref{写}}, \Lit{\}} \dsep
  \Lit{\{}, \Lit{|->}, \Lit{\}}
  }

\Ruledef{写}{
  \Ruleref{式}, \Lit{|->}, \Ruleref{式}
  }

\Ruledef{写像内包}{
  \Lit{\{}, \Ruleref{写}, \Lit{|}, \Ruleref{束縛リスト}, \lfeed
  \OptPt{\Lit{\&}, \Ruleref{式}},
  \Lit{\}}
  }

\subsubsection{組構成子式}

\Ruledef{組構成子}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{式リスト}, \Lit{)}
  }

\subsubsection{レコード式}

\Ruledef{レコード構成子}{
  \Lop{mk\_},\nmk \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }
\ntext{境界文字は許されない}

\Ruledef{レコード修正子}{
  \Lit{mu}, \Lit{(}, \Ruleref{式}, \Lit{,}, \lfeed
  \Ruleref{レコード修正}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{レコード修正}}, \Lit{)}
  }

\Ruledef{レコード修正}{
  \Ruleref{識別子}, \Lit{|->}, \Ruleref{式}
  }

\subsubsection{適用式}

\Ruledef{適用}{
  \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\Ruledef{項目選択}{
  \Ruleref{式}, \Lit{.}, \Ruleref{識別子}
  }

\Ruledef{組選択}{
  \Ruleref{式}, \Lit{.\#}, \Ruleref{数字}
  }

\Ruledef{関数型インスタンス化}{
  \Ruleref{名称}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
  }
  
\subsubsection{ラムダ式}

\Ruledef{ラムダ式}{
  \Lop{lambda}, \Ruleref{型束縛リスト}, \Lit{\&}, \Ruleref{式}
  }

\subsubsection{narrow式}

  \Ruledef{narrow式}{
    \Lit{\keyw{narrow}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

#ifdef VDMPP
\subsubsection{new式}

  \Ruledef{new式}{
    \Lop{new}, \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\subsubsection{self式}
  \Ruledef{self式}{
    \Lop{self}
  }

\subsubsection{スレッドID式}
  \Ruledef{スレッドID式}{
    \Lop{threadid}
  }
#endif VDMPP

\subsubsection{is式}

\Ruledef{一般is式}{
  \Ruleref{is式} \dsep
  \Ruleref{型判定}
  }

\Ruledef{is式}{
  \Lit{\keyw{is}\_},\nmk \Ruleref{名称}, \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
  \Ruleref{is基本型}, \Lit{(}, \Ruleref{式}, \Lit{)}
  }
\ntext{境界文字は許されない}

\Ruledef{型判定}{
  \Lit{\keyw{is}\_}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Ruleref{型}, \Lit{)}
  }

\subsubsection{未定義式}

\Ruledef{未定義式}{
  \Lop{undefined}
  }
  \nonstandard{1}

\subsubsection{事前条件式}

\Ruledef{事前条件式}{
  \Lop{pre\_}, \Lit{(}, \Ruleref{式}, \lfeed
                        \OptPt{\SeqPt{\Lit{,}, \Ruleref{式}}},
               \Lit{)}
  }

#ifdef VDMPP
\subsubsection{基底クラス構成要素}

\Ruledef{isofbaseclass式}{
      \Lop{isofbaseclass}, \Lit{(}, \Ruleref{識別子}, \Ruleref{式}, \Lit{)}}

\subsubsection{クラス構成要素}

\Ruledef{isofclass式}{
      \Lop{isofclass}, \Lit{(}, \Ruleref{識別子}, \Ruleref{式}, \Lit{)}}

\subsubsection{同基底クラス構成要素}

\Ruledef{samebaseclass式}{
      \Lop{samebaseclass}, \Lit{(}, \Ruleref{式}, \lfeed \Ruleref{式}, \Lit{)}}

\subsubsection{同クラス構成要素}

\Ruledef{sameclass式}{
      \Lop{sameclass}, \Lit{(}, \Ruleref{式}, \lfeed \Ruleref{式}, \Lit{)}}

\subsubsection{履歴式}

  \Ruledef{act式}{
    \Lit{\#act}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#act}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Ruledef{fin式}{
    \Lit{\#fin}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#fin}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Ruledef{active式}{
    \Lit{\#active}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#active}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Ruledef{req式}{
    \Lit{\#req}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#req}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }
  \Ruledef{waiting式}{
    \Lit{\#waiting}, \Lit{(}, \Ruleref{名称}, \Lit{)} \dsep
    \Lit{\#waiting}, \Lit{(}, \Ruleref{名称リスト}, \Lit{)}
  }

#endif VDMPP

#ifdef VICEMAN

\subsubsection{time式}

 \Ruledef{time式}{\Lop{time}}
#endif VICEMAN

\subsubsection{名称}

\Ruledef{名称}{
  \Ruleref{識別子}, \OptPt{\Lit{`}, \Ruleref{識別子}}
  }

\Ruledef{名称リスト}{
  \Ruleref{名称}, \SeqPt{\Lit{,}, \Ruleref{名称}}
  }

\Ruledef{旧名称}{
  \Ruleref{識別子}, \Lit{\char'176}
  }

\subsection{状態指示子}

\Ruledef{状態指示子}{
  \Ruleref{名称} \dsep
  \Ruleref{項目参照} \dsep
  \Ruleref{写像参照または列参照}
  }

\Ruledef{項目参照}{
  \Ruleref{状態指示子}, \Lit{.}, \Ruleref{識別子}
  }

\Ruledef{写像参照または列参照}{
  \Ruleref{状態指示子}, \Lit{(}, \Ruleref{式}, \Lit{)}
  }

\subsection{文}

\Ruledef{文}{
  \Ruleref{let文} \dsep
  \Ruleref{let be文} \dsep
  \Ruleref{def文} \dsep
  \Ruleref{ブロック文} \dsep
  \ifthenelse{\boolean{VDMpp}}{\Ruleref{一般代入文}}%
                              {\Ruleref{代入文}} \dsep
  \Ruleref{if文} \dsep
  \Ruleref{cases文} \dsep
  \Ruleref{列forループ} \dsep
  \Ruleref{集合forループ} \dsep
  \Ruleref{索引forループ} \dsep
  \Ruleref{whileループ} \dsep
  \Ruleref{非決定文} \dsep 
  \Ruleref{call文} \dsep
  \Ruleref{仕様記述文} \dsep
#ifdef VDMPP
%  \Ruleref{select statement} \dsep
  \Ruleref{start文} \dsep
  \Ruleref{startlist文} \dsep
%  \Ruleref{delay statement} \dsep
#endif VDMPP
#ifdef VICEMAN
  \Ruleref{duration文} \dsep
  \Ruleref{cycles文} \dsep
#endif VICEMAN
  \Ruleref{return文} \dsep
  \Ruleref{always文} \dsep
  \Ruleref{trap文} \dsep
  \Ruleref{再帰trap文} \dsep
  \Ruleref{exit文} \dsep
  \Ruleref{error文} \dsep
  \Ruleref{恒等文} 
  }
  \nonstandard{2}

\subsubsection{ローカル束縛文}

\Ruledef{let文}{
  \Lop{let}, \Ruleref{ローカル定義}, \SeqPt{\Lit{,}, \Ruleref{ローカル定義}}, \lfeed
  \Lop{in}, \Ruleref{文}
  }

\Ruledef{ローカル定義}{
  \Ruleref{値定義} \dsep 
  \Ruleref{関数定義}
  }

\Ruledef{let be文}{
  \Lop{let}, \Ruleref{束縛}, \OptPt{\Lop{be}, \Lop{st},
  \Ruleref{式}}, \Lop{in}, \lfeed
  \Ruleref{文}
  }

\Ruledef{def文}{
  \Lop{def}, \Ruleref{相等定義}, \lfeed
  \SeqPt{\Lit{;}, \Ruleref{相等定義}}, \OptPt{\Lit{;}},
  \lfeed
  \Lop{in}, \Ruleref{文}
  }
  \nonstandard{1}

\Ruledef{相等定義}{
  \Ruleref{パターン束縛}, \Lit{=},
   \Ruleref{式}}

\subsubsection{ブロック文と代入文}

\Ruledef{ブロック文}{
  \Lit{(}, \SeqPt{\Ruleref{dcl文}}, \lfeed
  \Ruleref{文}, \SeqPt{\Lit{;},  \Ruleref{文}}, \OptPt{\Lit{;}}, 
  \Lit{)}
  }\nonstandard{1}

\Ruledef{dcl文}{
  \Lop{dcl}, \Ruleref{代入定義}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{代入定義}}, \Lit{;}
  }

\Ruledef{代入定義}{
  \Ruleref{識別子}, \Lit{:}, \Ruleref{型}, \OptPt{\Lit{:=}, 
    \Ruleref{式} }
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{一般代入文}{
  \Ruleref{代入文} \dsep
  \Ruleref{多重代入文}
  }
%}%
%{}

\Ruledef{代入文}{
  \Ruleref{状態指示子}, \Lit{:=}, 
    \Ruleref{式}
  }

%\ifthenelse{\boolean{VDMpp}}{%
  \Ruledef{多重代入文}{
    \Lit{atomic}, 
    \Lit{(}
      \Ruleref{代入文}, \Lit{;}, \lfeed
      \Ruleref{代入文},
      \lfeed
      \SeqPt{\Lit{;},\Ruleref{代入文}}
    \Lit{)}
    }
%  }%
%{}


\subsubsection{条件文}\label{condstmt2}

\Ruledef{if文}{
  \Lop{if}, \Ruleref{式}, \Lop{then}, \Ruleref{文}, \lfeed
  \SeqPt{\Ruleref{elseif文}}, \lfeed
  \OptPt{\Lop{else}, \Ruleref{文}}
  }

\Ruledef{elseif文}{
  \Lop{elseif}, \Ruleref{式}, \Lop{then}, \Ruleref{文}
  }

\Ruledef{cases文}{
  \Lop{cases}, \Ruleref{式}, \Lit{:}, \lfeed
  \Ruleref{cases文選択肢群}, \lfeed 
  \OptPt{\Lit{,}, \Ruleref{others文}}, \Lop{end}
  }

\Ruledef{cases文選択肢群}{
  \Ruleref{cases文選択肢}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{cases文選択肢}}
  }

\Ruledef{cases文選択肢}{
  \Ruleref{パターンリスト}, \Lit{->}, \Ruleref{文}
  }

\Ruledef{others文}{
  \Lop{others}, \Lit{->}, \Ruleref{文}
  }

\subsubsection{ループ文}

\Ruledef{列forループ}{
  \Lop{for}, \Ruleref{パターン束縛}, \Lop{in},
  \OptPt{\Lop{reverse}}, \lfeed
  \Ruleref{式}, \Lop{do}, \Ruleref{文}
  }

\Ruledef{集合forループ}{
  \Lop{for}, \Lop{all}, \Ruleref{パターン}, \Lop{in set},
  \Ruleref{式},\lfeed
  \Lop{do}, \Ruleref{文}
  }

\Ruledef{索引forループ}{
  \Lop{for}, \Ruleref{識別子}, \Lit{=}, \Ruleref{式},
  \Lop{to}, \Ruleref{式}, \lfeed
  \OptPt{\Lop{by}, \Ruleref{式}}, \lfeed
  \Lop{do}, \Ruleref{式}
  }

\Ruledef{whileループ}{
  \Lop{while}, \Ruleref{式}, \Lop{do}, \Ruleref{式}
  }
\subsubsection{非決定文}

\Ruledef{非決定文}{
  \Lit{||}, \Lit{(}, \Ruleref{文}, \lfeed
  \SeqPt{\Lit{,}, \Ruleref{文}}, \Lit{)}
  }

\subsubsection{call文とreturn文}

#ifdef VDMSL
\Ruledef{call文}{
  \Ruleref{名称}, \Lit{(}, \lfeed
  \OptPt{\Ruleref{式リスト}}, \Lit{)}
}
#endif VDMSL
#ifdef VDMPP
  \Ruledef{call文}{
    \OptPt{\Ruleref{オブジェクト指定子}, \Lit{.}},\lfeed
    \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)},
    }
  \Ruledef{オブジェクト指定子}{
    \Ruleref{名称} \dsep
    \Ruleref{self式} \dsep
    \Ruleref{narrow式} \dsep
    \Ruleref{new式} \dsep
    \Ruleref{オブジェクト項目参照} \dsep
    \Ruleref{オブジェクト適用}
  }

  \Ruledef{オブジェクト項目参照}{
    \Ruleref{オブジェクト指定子}, \Lit{.}, \Ruleref{識別子}
  }

  \Ruledef{オブジェクト適用}{
    \Ruleref{オブジェクト指定子}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }
#endif VDMPP

\Ruledef{return文}{
  \Lop{return}, \OptPt{\Ruleref{式}}
  }

\subsubsection{仕様記述文}

\Ruledef{仕様記述文}{
  \Lit{[}, \Ruleref{陰操作本体}, \Lit{]}
  }\nonstandard{1}

#ifdef VDMPP
%\subsubsection{The Select Statement}
%
%\Ruledef{select statement}{
%      \Lop{sel}, \Lit{(}, \Ruleref{guarded command},\lfeed
%      \SeqPt{\Lit{,}, \Ruleref{guarded command}}, \Lit{)}}
%\Ruledef{guarded command}{
%      \OptPt{\Ruleref{expression}}, \OptPt{\Ruleref{answer statement}},\lfeed
%      \OptPt{\Lop{$->$}, \Ruleref{statement}}}
%\Ruledef{answer statement}{
%      \Lop{answer}, \Brack{\Ruleref{name} \dsepl \Lop{all}}}
%
\subsubsection{start文とstartlist文}

\Ruledef{start文}{
    \Lop{start}, \Lit{(}, \Ruleref{式}, \Lit{)}}

\Ruledef{startlist文}{
      \Lop{startlist}, \Lit{(}, \Ruleref{式}, \Lit{)}}

%\subsubsection{The Delay Statement}
%
%\Ruledef{delay statement}{
%      \Lop{delay}, \Lit{(},\Ruleref{expression}, \Lit{)}}
#endif VDMPP

#ifdef VICEMAN
\subsubsection{duration文とcycles文}

\Ruledef{duration文}{
  \Lop{duration}, \Lit{(}, \Ruleref{数字}, \Lit{)},\lfeed
  \Ruleref{文}
}

\Ruledef{cycles文}{
    \Lop{cycles}, \Lit{(}, \Ruleref{数字}, \Lit{)},\lfeed
    \Ruleref{文}
  }

#endif VICEMAN

\subsubsection{例外処理文}

\Ruledef{always文}{
  \Lop{always}, \Ruleref{文}, \Lop{in}, \Ruleref{文}
  }

\Ruledef{trap文}{
  \Lop{trap}, \Ruleref{パターン束縛}, \Lop{with}, \Ruleref{文},
  \lfeed
  \Lop{in}, \Ruleref{文}
  }

\Ruledef{再帰trap文}{
  \Lop{tixe}, \Ruleref{trap群}, \Lop{in}, \Ruleref{文}
  }

\Ruledef{trap群}{
  \Lit{\{}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文}, \lfeed  \SeqPt{\Lit{,}, \Ruleref{パターン束縛}, \Lit{|->}, \Ruleref{文}},
  \Lit{\}}
  }

\Ruledef{exit文}{
  \Lop{exit}, \OptPt{\Ruleref{式}}
  }

\subsubsection{error文}

  \Ruledef{error文}{
    \Lop{error}
    }\nonstandard{1}

\subsubsection{恒等文}

\Ruledef{恒等文}{
  \Lop{skip}
  }

\subsection{パターンと束縛}

\subsubsection{パターン}\label{patterns2}

\Ruledef{パターン}{
  \Ruleref{パターン識別子} \dsep
  \Ruleref{一致値} \dsep
  \Ruleref{集合列挙パターン} \dsep
  \Ruleref{集合合併パターン} \dsep
  \Ruleref{列列挙パターン} \dsep
  \Ruleref{列連結パターン} \dsep
   \Ruleref{写像列挙パターン} \dsep
   \Ruleref{写像併合パターン} \dsep
  \Ruleref{組パターン} \dsep
  \Ruleref{レコードパターン}
  }

\Ruledef{パターン識別子}{
  \Ruleref{識別子} \dsepl \Lit{-}
  }

\Ruledef{一致値}{
  \Lit{(}, \Ruleref{式}, \Lit{)} \dsep
  \Ruleref{記号リテラル}
  }

\Ruledef{集合列挙パターン}{
  \Lit{\{}, \OptPt{\Ruleref{パターンリスト}}, \Lit{\}}
  }\nonstandard{1}

\Ruledef{集合合併パターン}{
  \Ruleref{パターン}, \Lit{union}, \Ruleref{パターン}
  }

\Ruledef{列列挙パターン}{
  \Lit{[}, \OptPt{\Ruleref{パターンリスト}}, \Lit{]}
  }\nonstandard{1}

\Ruledef{列連結パターン}{
  \Ruleref{パターン}, \Lit{\char'136}, \Ruleref{パターン}
  }

  \Ruledef{写像列挙パターン}{
    \Lit{\{}, [\Ruleref{写パターンリスト}], \Lit{\}}
    }
    
  \Ruledef{写パターンリスト}{
    \Ruleref{写パターン}, \SeqPt{\Lit{,}, \Ruleref{写パターン}}
    }
    
  \Ruledef{写パターン}{
    \Ruleref{パターン}, \Lit{|->}, \Ruleref{パターン}
  }

   \Ruledef{写像併合パターン}{
    \Ruleref{パターン}, \Lit{\keyw{munion}}, \Ruleref{パターン}
    }

\Ruledef{組パターン}{
  \Lit{mk\_}, \Lit{(}, \Ruleref{パターン}, \Lit{,}, \Ruleref{パターンリスト}, \Lit{)}
  } 

\Ruledef{レコードパターン}{
  \Lit{mk\_},\nmk \Ruleref{名称}, \Lit{(}, \OptPt{\Ruleref{パターンリスト}}, \Lit{)}
  }
\ntext{境界文字は許されない}

\Ruledef{パターンリスト}{
  \Ruleref{パターン}, \SeqPt{\Lit{,}, \Ruleref{パターン}}
  }

\subsubsection{束縛}

\Ruledef{パターン束縛}{
  \Ruleref{パターン} \dsepl \Ruleref{束縛}
  }

\Ruledef{束縛}{
  \Ruleref{集合束縛} \dsepl \Ruleref{型束縛}
  }

  \Ruledef{集合束縛}{
    \Ruleref{パターン}, \Lop{in set}, \Ruleref{式}
    }

  \Ruledef{型束縛}{
    \Ruleref{パターン}, \Lit{:}, \Ruleref{型}
    }

  \Ruledef{束縛リスト}{
    \Ruleref{多重束縛}, \SeqPt{\Lit{,}, \Ruleref{多重束縛}}
    }

  \Ruledef{多重束縛}{
    \Ruleref{多重集合束縛} \dsep
    \Ruleref{多重型束縛}
    }

  \Ruledef{多重集合束縛}{
    \Ruleref{パターンリスト}, \Lop{in set}, \Ruleref{式}
    }

  \Ruledef{多重型束縛}{
    \Ruleref{パターンリスト}, \Lit{:}, \Ruleref{型}
    }

\Ruledef{型束縛リスト}{
  \Ruleref{型束縛}, \SeqPt{\Lit{,}, \Ruleref{型束縛}}
  }

\section{語彙}\label{app-b}\label{ap:lexis}

\subsection{文字}

文字集合は、この文書で用いられた文字形式と共に、~\ref{charSetTable}表に示される。
%この文字集合はちょうど ASCII (or ISO 646) 構文に相当するものであることには注意したい。
 \vdmsl\ 標準において文字は次のとおりに定義される:

\Ruledef{文字}{
  \hyperlink{charSetTable}{通常文字} \dsep
  \hyperlink{charSetTable}{キーワード文字} \dsep
  \hyperlink{charSetTable}{識別文字} \dsep
  ギリシャ文字 \dsep
  \hyperlink{charSetTable}{アラビア数字} \dsep
  \hyperlink{charSetTable}{境界文字} \dsep
  \hyperlink{charSetTable}{その他の文字} \dsep
  \Ruleref{分離符}
  }

通常文字とキーワード文字は ~\ref{charSetTable}表 に表示されている (この文書ではキーワード文字は単に相当するアルファベット小文字を用いている)。 
識別文字は相当するアルファベットの大文字と小文字を用いるが引用リテラルは``{\tt <}''で始め ``{\tt >}''で閉じる (引用文字にはアンダーバーや数字も用いることができることに注目)。 
ギリシャ文字も数値記号``{\tt \#}''の後に相当する文字を続けることで使用できる(この情報は \LaTeX\ pretty printer で用いられ、ギリシャ文字が提示できるようになっている)。 
全境界文字(標準 ASCII 版のもの)は表~\ref{charSetTable} に記述されている。
標準では境界文字とそれらの組み合わせには違いをもたせている。
ここではこれを違いとして扱わない。
数学構文中のいくつかの境界文字が、ここで用いられているASCII構文中ではキーワードとなることにも気づいてもらいたい。

\begin{table}[ht]
\setlength{\tabcolsep}{3.5mm}
\setlength{\arraycolsep}{3.5mm}

\rule{\textwidth}{.5mm}
    {\sf
    \begin{tabular}{*{13}{l}} 
        % that's 13 italic columns
        \multicolumn{13}{l}{\rm 文字:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z \\
        A & B & C & D & E & F & G & H & I & J & K & L & M \\
        N & O & P & Q & R & S & T & U & V & W & X & Y & Z \\
        \multicolumn{3}{l}{漢字} & \multicolumn{10}{l}{ハングル文字}
    \end{tabular}
    }

\blankline
    {\sf  
    \begin{tabular}{*{13}{l}}
        % that's 13 keyword columns
        \multicolumn{13}{l}{\rm キーワード文字:} \\
        a & b & c & d & e & f & g & h & i & j & k & l & m \\
        n & o & p & q & r & s & t & u & v & w & x & y & z
    \end{tabular}
    }

\blankline
{\tt
    \begin{tabular}{*{10}{l}}
        % that's 10 math columns
        \multicolumn{10}{l}{\mbox{{\rm 境界文字:}}} \\
          ,         & :         & ;         & =         & (         &
          )         & |         & -         & [         & ]         \\
          \{        & \}        & +         & /         & <         &
          >         & <=        & >=        & <>        &  .        \\
          \verb+*+  & ->        & +>        & ==>       & ||        &
          =>        &   <=>     & |->       & <:        & :>        \\
          <-:       & :->       & \&        & ==        & **        & 
          \verb+^+  & ++        &           &           &           \\
    \end{tabular}
}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{アラビア数字:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
        & {\tt 8} 
        & {\tt 9} 
     \end{tabular}

\blankline
    \begin{tabular}{*{10}{l}}
        \multicolumn{10}{l}{16進数字:} \\
        {\tt 0} & {\tt 1} & {\tt 2} & {\tt 3} & {\tt 4} & {\tt 5} & {\tt 6} & {\tt 7} & {\tt 8} & {\tt 9} \\
        {\tt A} & {\tt B} & {\tt C} & {\tt D} & {\tt E} & {\tt F} \\
        {\tt a} & {\tt b} & {\tt c} & {\tt d} & {\tt e} & {\tt f} 
     \end{tabular}

\blankline
    \begin{tabular}{*{8}{l}}
        \multicolumn{8}{l}{8進数字:} \\
        {\tt 0}
        & {\tt 1} 
        & {\tt 2} 
        & {\tt 3} 
        & {\tt 4} 
        & {\tt 5}
        & {\tt 6} 
        & {\tt 7} 
     \end{tabular}

\blankline
    \begin{tabular}{*{6}{l}}
        \multicolumn{6}{l}{その他の文字:} \\
        {\tt \_} 
        & {\tt \char'140} % `
        & {\tt \char'047} % '
        & {\tt \char'042} % ''
        & {\tt \char'100} % @
        & {\tt \~{}}
    \end{tabular}

\blankline
    \begin{tabular}{p{14cm}}   %{p{\textwidth}}
        改行: \\
        \\
        空白: \\
        \\
        これらはグラフィックな形態をもたないが、空白と行替えを組み合わせる。
ここに2つの分離符がある: 行替えしない(空白) と行替えを行う (改行)である。
    \end{tabular}

\rule{\textwidth}{.5mm}
\hypertarget{charSetTable}{\caption{文字集合}}
\label{charSetTable}

\end{table}

\clearpage % to force table to appear *here*


\subsection{記号}\label{Symbols}

以下のような種類の記号が存在する: キーワード、境界文字、
% simple names -- these do not seem to exist anymore DJA
記号リテラル、そしてコメント。  
文字から記号への変換も以下の規則のもとに与えられている; これらは構文定義と同じ表記を用いるが、意味においては続く終了符との間に分離符がないという点で異なる。
それ例外の曖昧さが生ずる場所では、2つの連続する記号は分離符によって分離されていなければならない。

\newcommand{\Lks}[1]{\Lop{#1}\dsepl}
\newcommand{\Lksb}[1]{\Lop{#1}\dsep}
\Ruledef{キーワード}{
#ifdef VDMSL
  \Lks{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
  \Lks{as}
  \Lks{atomic}
  \Lks{be}
  \Lks{bool}
  \Lksb{by}
  \Lks{card}
  \Lks{cases}
  \Lks{char}
  \Lks{comp}
  \Lks{compose} 
  \Lksb{conc}
  \Lks{dcl}
  \Lks{def}
  \Lks{definitions}
  \Lks{dinter} 
  \Lks{div}
  \Lksb{dlmodule}
  \Lks{do}
  \Lks{dom}
  \Lks{dunion}
  \Lks{elems}
  \Lks{else}
  \Lks{elseif}
  \Lksb{end}
  \Lks{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lks{exit} 
  \Lks{exports}
  \Lksb{ext} 
  \Lks{false} 
  \Lks{floor}
  \Lks{for} 
  \Lks{forall}
  \Lks{from}
  \Lksb{functions}
  \Lks{hd} 
  \Lks{if}
  \Lks{imports}
  \Lks{in} 
  \Lks{inds}
  \Lks{init}
  \Lksb{inmap}
  \Lks{int}
  \Lks{inter}
  \Lks{inv}
  \Lks{inverse}
  \Lks{iota}
  \Lksb{is\_}
  \Lks{lambda}
  \Lks{len} 
  \Lks{let}
  \Lks{make\_}
  \Lks{map}
  \Lks{narrow\_}
  \Lksb{measure}
  \Lks{merge} 
  \Lks{mod} 
  \Lksb{module}
  \Lks{mu\_}
  \Lks{munion}
  \Lks{nat}
  \Lks{nat1}
  \Lks{nil} 
  \Lks{not}
  \Lksb{of}
  \Lks{operations}
  \Lks{or}
  \Lks{others}
  \Lksb{post}
  \Lks{power} 
  \Lks{pre}
  \Lks{psubset}
  \Lks{rat}
  \Lks{rd}
  \Lks{real} 
  \Lksb{rem}
  \Lks{renamed}
  \Lks{return}
  \Lks{reverse}
  \Lks{rng}
  \Lks{seq}
  \Lksb{seq1}
  \Lks{set}
  \Lks{skip}
  \Lks{specified}
  \Lks{st}
  \Lks{state}
  \Lksb{struct}
  \Lks{subset}
  \Lks{then}
  \Lks{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
  \Lksb{trap} 
  \Lks{true}
  \Lks{types}
  \Lks{undefined}
  \Lks{union}
  \Lksb{uselib}
  \Lks{values} 
  \Lks{while} 
  \Lks{with}
  \Lks{wr}
  \Lksb{yet}
  \Lop{RESULT} 
#endif // VDMSL
#ifdef VDMPP
  \Lks{\#act}
  \Lks{\#active}
  \Lks{\#fin}
  \Lks{\#req}
  \Lks{\#waiting}
  \Lksb{abs}
  \Lks{all}
  \Lks{always}
  \Lks{and}
  \Lksb{async}
  \Lks{atomic}
  \Lks{be}
  \Lks{bool}
  \Lks{by}
  \Lks{card}
  \Lksb{cases}
  \Lks{char}
  \Lks{class}
  \Lks{comp}
  \Lks{compose} 
  \Lks{conc}
#ifdef VICEMAN
  \Lks{cycles}
#endif VICEMAN
  \Lksb{dcl}
  \Lks{def}
%  \Lks{delay}
  \Lks{dinter} 
  \Lks{div}
  \Lks{do}
  \Lks{dom}
  \Lksb{dunion}
#ifdef VICEMAN
  \Lks{duration}
#endif VICEMAN
  \Lks{elems}
  \Lks{else}
  \Lks{elseif}
  \Lks{end}
  \Lksb{error}
  \Lks{errs}
  \Lks{exists}
  \Lks{exists1}
  \Lks{exit} 
  \Lks{ext} 
  \Lks{false} 
  \Lksb{floor}
  \Lks{for} 
  \Lks{forall}
  \Lks{from}
  \Lks{functions}
%  \Lks{general}
  \Lks{hd} 
  \Lks{if}
  \Lksb{in} 
  \Lks{inds}
%  \Lks{init}
  \Lks{inmap}
  \Lks{input}
  \Lks{instance}
  \Lks{int}
  \Lksb{inter}
  \Lks{inv}
  \Lks{inverse}
  \Lks{iota}
  \Lks{is\_}
  \Lksb{isofbaseclass}
  \Lks{isofclass}
  \Lks{lambda}
  \Lks{len} 
  \Lks{let}
  \Lks{map}
  \Lksb{measure} 
  \Lks{merge} 
  \Lks{mod} 
  \Lks{mu}
  \Lks{munion}
  \Lksb{mutex}
  \Lks{make\_}
  \Lks{mu\_}
  \Lks{narrow\_}
  \Lks{nat}
  \Lks{nat1}
  \Lksb{new}
  \Lks{nil} 
  \Lks{not}
  \Lks{of}
  \Lksb{operations}
  \Lks{or}
  \Lks{others}
  \Lks{per}
#ifdef VICEMAN
  \Lks{periodic}
#endif VICEMAN
  \Lks{post}
  \Lks{power} 
  \Lksb{pre}
  \Lks{private}
  \Lks{protected}
  \Lks{psubset}
  \Lks{public}
 % \Lksb{qsync}
  \Lksb{rat}
  \Lks{rd}
  \Lks{real} 
  \Lks{rem}
  \Lks{responsibility}
  \Lksb{return}
  \Lks{reverse}
  \Lks{rng}
  \Lks{samebaseclass}
  \Lks{sameclass}
 % \Lksb{sel}
  \Lksb{self}
  \Lks{seq}
  \Lks{seq1}
  \Lks{set}
  \Lks{skip}
  \Lks{specified}
  \Lks{st}
  \Lksb{start}
  \Lks{startlist}
  \Lks{subclass}
  \Lks{subset}
  \Lksb{sync}
#ifdef VICEMAN
  \Lks{system}
#endif VICEMAN
 % \Lks{synonym}
 % \Lks{t\_}
  \Lks{then}
  \Lks{thread}
  \Lks{threadid}
#ifdef VICEMAN
  \Lks{time}
#endif VICEMAN
  \Lksb{tixe}
  \Lks{tl}
  \Lks{to}
  \Lks{token}
#ifdef VDMPP
  \Lks{traces}
#endif VDMPP
  \Lks{trap} 
  \Lks{true}
  \Lksb{types}
  \Lks{undefined}
  \Lks{union}
  \Lks{values} 
  \Lks{variables}
%  \Lks{w\_}
  \Lks{while} 
  \Lksb{with}
  \Lks{wr}
  \Lks{yet}
  \Lop{RESULT} 
#endif VDMPP
  }

\Ruledef{分離符}{
  \hyperlink{charSetTable}{改行} \dsepl 
  \hyperlink{charSetTable}{空白}
  }

\Ruledef{識別子}{
  \Brack{\hyperlink{charSetTable}{文字} \dsepl ギリシャ文字}, \lfeed
  \SeqPt{\Brack{\hyperlink{charSetTable}{文字} \dsepl ギリシャ文字} \dsepl % \Ruleref{IS THIS RIGHT}??
    \hyperlink{charSetTable}{アラビア数字}      \dsepl
    \Lit{'}  \dsepl
    \Lit{\_}
    }
  }

\medskip

#ifdef VICEMAN
\noindent
※注）\texttt{CPU}と \texttt{BUS}クラスは、VDMに予約されたクラス名であるため、ユーザは再定義できない。
これらの事前に定義された2クラスが、上記セクション~\ref{sec:system}で説明された機能性を含む。
#endif VICEMAN

% ueki 2010/3/4
\noindent %識別子において用いられることが可能なハイフンは下線(アンダースコア ``\_''ともいわれる)として書かれることに注意しよう、数学構文では``-''と翻訳されるものであっても。
次の予約前置詞の1つと共に始まるすべての識別子は予約されている: 
 \keyw{init\_}, \keyw{inv\_}, \keyw{is\_}, \keyw{mk\_},
\keyw{post\_} そして \keyw{pre\_}。

\Ruledef{型変数識別子}{
  \Lit{@}, \Ruleref{識別子}
  }

\Ruledef{is基本型}{
  \Lop{is\_}, 
  \Brack{%
    \Lop{bool} \dsepl
    \Lop{nat} \dsepl 
    \Lop{nat1} \dsepl 
    \Lop{int} \dsepl 
    \Lop{rat} \dsep 
    \Lop{real} \dsepl
    \Lop{char} \dsepl
    \Lop{token}
    }
  }

\Ruledef{記号リテラル}{
  \Ruleref{数値リテラル} \dsepl
  \Ruleref{ブールリテラル} \dsep
  \Ruleref{nilリテラル} \dsepl
  \Ruleref{文字リテラル} \dsepl
  \Ruleref{テキストリテラル} \dsep
  \Ruleref{引用リテラル}
  }

\Ruledef{数字}{
  \hyperlink{charSetTable}{アラビア数字}, \SeqPt{\hyperlink{charSetTable}{アラビア数字}}
  }

\Ruledef{数値リテラル}{
  \hyperlink{charSetTable}{10進数値リテラル} \dsepl \hyperlink{charSetTable}{16進数値リテラル}
}

\Ruledef{指数}{
  \Brack{\Lit{E} \dsepl \Lit{e}},
  \OptPt{\Lit{+} \dsepl \Lit{-}},
  \Ruleref{数字}
  }

\Ruledef{10進数値リテラル}{
  \Ruleref{数字},
  \OptPt{\Lit{.}, \hyperlink{charSetTable}{アラビア数字}, \SeqPt{\hyperlink{charSetTable}{アラビア数字}}},
  \OptPt{\Ruleref{指数}}
}

\Ruledef{16進数値リテラル}{
  \Brack{\Lit{0x} \dsepl \Lit{0X}}, \hyperlink{charSetTable}{16進数字}, \SeqPt{\hyperlink{charSetTable}{16進数字}}
}

\Ruledef{ブールリテラル}{
  \Lop{true} \dsepl \Lop{false}
  }

\Ruledef{nilリテラル}{
  \Lop{nil}
  }

\Ruledef{文字リテラル}{
  \Lit{\mbox{\,}'\mbox{\,}}, \Ruleref{文字} \dsepl 
  \Ruleref{エスケープ列} \dsep 
  \Ruleref{多文字}, 
  \Lit{\mbox{\,}'\mbox{\,}}
  }%\nonstandard{1}

\Ruledef{エスケープ列}{
  \Lit{\char'134\char'134} \dsepl \Lit{{\char'134}r} \dsepl
  \Lit{{\char'134}n} \dsepl \Lit{{\char'134}t} \dsepl
  \Lit{{\char'134}f} \dsepl \Lit{{\char'134}e} \dsepl \Lit{{\char'134}a} \dsep
  \Lit{{\char'134}x} \hyperlink{charSetTable}{16進数字},\hyperlink{charSetTable}{16進数字} \dsepl
  \Lit{{\char'134}c} \Ruleref{文字} \dsep
  \Lit{{\char'134}} \hyperlink{charSetTable}{8進数字}, \hyperlink{charSetTable}{8進数字}, \hyperlink{charSetTable}{8進数字} \dsep
  \Lit{{\char'134}"} \dsepl
  \Lit{{\char'134}'} \dsepl
  }

\Ruledef{多文字}{ギリシャ文字 \dsep
   \Lit{<=} \dsepl \Lit{>=} \dsepl \Lit{<>} \dsepl \Lit{->} \dsepl
   \Lit{+>} \dsepl \Lit{==>} \dsepl \Lit{||} \dsep \Lit{=>} \dsepl
   \Lit{<=>} \dsepl \Lit{|->} \dsepl \Lit{<:} \dsepl \Lit{:>} \dsepl
   \Lit{<-:} \dsep \Lit{:->} \dsepl \Lit{==} \dsepl \Lit{**} \dsepl
   \Lit{++}}  

\Ruledef{テキストリテラル}{
  \Lit{\mbox{\,}"\mbox{\,}},
  \SeqPt{%
%    \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl%  was , - changed by br!
%    character -- \Brack{\Lit{\mbox{\,}"\mbox{\,}}\dsepl newline}
     \Lit{\mbox{\,}"\mbox{\,}"\mbox{\,}}\dsepl
     \Ruleref{文字} \dsepl \Ruleref{エスケープ列}
    },
  \Lit{\mbox{\,}"\mbox{\,}}
  }

\Ruledef{引用リテラル}{
  \hyperlink{charSetTable}{識別文字}, \lfeed
  \SeqPt{\Lit{\_} \dsepl \hyperlink{charSetTable}{識別文字}
   \dsepl \hyperlink{charSetTable}{アラビア数字}}% \Ruleref{M30} (\Ruleref{hyphen allowed})
  }

\Ruledef{一行コメント}{
  \Lit{--}, \SeqPt{\Ruleref{文字} -- \hyperlink{charSetTable}{改行}}, \hyperlink{charSetTable}{改行}
  }

#ifdef VDMPP
\Ruledef{複数行コメント}{
  \Lit{/*}, \SeqPt{\Ruleref{文字}}, \Lit{*/}
  }
#endif VDMPP

上記のエスケープ列は次のように翻訳される:

\begin{center}
\begin{tabular}{ll}\hline
列 & 翻訳\\ \hline
  \Lit{\char'134\char'134} & バックスラッシュ文字\\
  \Lit{{\char'134}r}       & リターン文字\\
  \Lit{{\char'134}n}       & 改行文字\\
  \Lit{{\char'134}t}       & タブ文字\\
  \Lit{{\char'134}f}       & 用紙送り文字\\
  \Lit{{\char'134}e}       & エスケープ文字\\
  \Lit{{\char'134}a}       & アラーム (ベル)\\
  \Lit{{\char'134}x} 16進数字,16進数字 
                           & 文字の16進表示\\
                           & (たとえば \texttt{{\char'134}x41} は `A')\\
  \Lit{{\char'134}c} 文字 
                           & 制御文字\\
                           & (たとえば \texttt{{\char'134}c A} $\equiv$ 
                                    \texttt{{\char'134}x01})\\
  \Lit{{\char'134}} 8進数字, 8進数字, 8進数字 
                           & 文字の8進表示\\
  \Lit{{\char'134}{\char'042}}       &  \texttt{{\char'042}} 文字\\
  \Lit{{\char'134}'}       &  \verb+'+ 文字 \\
\end{tabular}
\end{center}

\newpage
\section{演算子優先順位}\label{app-c}

具象構文における演算子の優先順位は2段階で定義される: 演算子はファミリーに区分けされて、上位の優先順位 $>$ がそれらのファミリーに対し与えられるが、その結果
ファミリーである $F\sb{1}$ と $F\sb{2}$ が次を満足させるとする

\begin{quote}
$F\sb{1} > F\sb{2}$
\end{quote}

\noindent するとファミリー $F\sb{1}$ のすべての演算子はファミリー $F\sb{2}$ のすべての演算子より高位の優先順をもつ。

ファミリー内での相対的な演算子の優先順は、型情報を考慮して決定され、これが曖昧さの解決に役立つ。 
型構成子は別に扱われ、他の演算子とともに優先順に並べられることはない。

演算子には6つのファミリーすなわち、結合子、適用子、評価子、関係子、連結子、構成子がある:

\begin{description}%{Connectivesxx}
\item[結合子:] 関数値、写像値の結合および、関数値、写像値、数値の反復を許す操作。
\item[適用子:] 関数適用、項目選択、列索引、その他、
\item[評価子:] 非述語である演算子。
\item[関係子:] 関係の演算子。
\item[連結子:] 論理連結子。
\item[構成子:] 式の構成において、陰に陽に用いられる演算子; たとえば  \keyw{if-then-elseif-else}, `{\tt
    |->}', `\ldots', その他。
\end{description}

\noindent ファミリー上の優先順は次の通り:

\begin{quote}
$\mbox{\small 結合子} >
\mbox{\small 適用子} >
\mbox{\small 評価子}  >
\mbox{\small 関係子}   >
\mbox{\small 連結子} >
\mbox{\small 構成子}$
\end{quote}

\subsection{結合子のファミリー}

これらの結合子は最高位の優先順位をもつ。

\Ruledef{結合子}{
  \Ruleref{反復} \dsepl \Ruleref{合成}
  }

\Ruledef{反復}{
  \Lit{**}
  }

\Ruledef{合成}{
  \Lop{comp}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    優先順位 & 結合子 \\
    \hline
    1       & \keyw{comp}     \\
    2       & \keyw{iterate}  \\
    \hline
  \end{tabular}
\end{center}

\subsection{適用子のファミリー}

すべての適用子は等しい優先順位をもつ。

\Ruledef{適用子}{
  \Ruleref{部分列}
% \dsep \Ruleref{tuple constructor}
% \dsep \Ruleref{組構成子}
  \dsep \Ruleref{適用}
  \dsep \Ruleref{関数型インスタンス化}
  \dsep \Ruleref{項目選択}
  }

\Rule{部分列}{
  \Ruleref{式}, \Lit{(}, \Ruleref{式}, \Lit{,}, \Lit{\Range},
  \Lit{,}, \lfeed
  \Ruleref{式}, \Lit{)}
  }

\Rule{適用}{
  \Ruleref{式}, \Lit{(}, \OptPt{\Ruleref{式リスト}}, \Lit{)}
  }

\Rule{関数型インスタンス化}{
  \Ruleref{式}, \Lit{[}, \Ruleref{型}, \SeqPt{\Lit{,}, \Ruleref{型}}, \Lit{]}
  }

\Rule{項目選択}{
  \Ruleref{式}, \Lit{.}, \Ruleref{識別子} 
  }

\subsection{評価子のファミリー}

評価子のファミリーは、それらが用いられている式の型に従い、9つのグループに区分けされる。

\Ruledef{評価子}{
  \Ruleref{算術前置演算子} \dsep
  \Ruleref{集合前置演算子} \dsep
  \Ruleref{列前置演算子} \dsep
  \Ruleref{写像前置演算子} \dsep
  \Ruleref{逆写像} \dsep
  \Ruleref{算術中置演算子} \dsep
  \Ruleref{集合中置演算子} \dsep
  \Ruleref{列中置演算子} \dsep
  \Ruleref{写像中置演算子}
  }

\Ruledef{算術前置演算子}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lop{abs} \dsepl
  \Lop{floor}
  }

\Ruledef{集合前置演算子}{
  \Lop{card} \dsepl
  \Lop{power} \dsepl
  \Lop{dunion} \dsepl
  \Lop{dinter}
  }

\Ruledef{列前置演算子}{
  \Lop{hd} \dsepl
  \Lop{tl} \dsepl
  \Lop{len} \dsep
  \Lop{inds} \dsepl
  \Lop{elems} \dsepl
  \Lop{conc}
  }

\Ruledef{写像前置演算子}{
  \Lop{dom} \dsepl
  \Lop{rng} \dsepl
  \Lop{merge} \dsepl
  \Lop{inverse}
  }

\Ruledef{算術中置演算子}{
  \Lit{+} \dsepl
  \Lit{-} \dsepl
  \Lit{*} \dsepl
  \Lit{/} \dsepl
  \Lop{rem} \dsepl
  \Lop{mod} \dsepl
  \Lop{div}
  }

\Ruledef{集合中置演算子}{
  \Lop{union} \dsepl
  \Lop{inter} \dsepl
  \Lit{\char'134}
  }

\Ruledef{列中置演算子}{
  \Lit{\char'136}
  }

\Ruledef{写像中置演算子}{
  \Lop{munion} \dsepl
  \Lit{++} \dsepl
  \Lit{<:} \dsepl
  \Lit{<-:} \dsepl
  \Lit{:>} \dsepl
  \Lit{:->}
  }

\noindent 優先順位はアナログの演算子のパターンを追いかける。以下の表においてファミリーは定義されている。

\blankline
\begin{center}
  \begin{tabular}{ccccc}
    \hline
    優先順位 & 算術       & 集合           & 写像                & 列 \\
    1                & {\tt + -}        & \keyw{union} \verb+\+ & \keyw{munion} {\tt ++} & \verb+^+ \\
    2                & \verb+*+ {\tt /} & \keyw{inter}          &                        & \\
                     & \keyw{rem}       &                       &                        & \\
                     & \keyw{mod}       &                       &                        & \\
                     & \keyw{div}       &                       &                        & \\
    3                &                  &                       & \keyw{inverse}         & \\
    4                &                  &                       & {\tt <: <-:}           & \\
    5                &                  &                       & {\tt :> :->}           & \\
    6                & (単項) {\tt +}  & \keyw{card}           & \keyw{dom}             & \keyw{len}         \\
                     & (単項) {\tt -}  & \keyw{power}          & \keyw{rng}             & \keyw{elems}       \\
                     & \keyw{abs}       & \keyw{dinter}         & \keyw{merge}           & \keyw{hd} \keyw{tl} \\
                     & \keyw{floor}     & \keyw{dunion}         &                        & \keyw{conc}        \\
                     &                  &                       &                        & \keyw{inds}        \\
    \hline
  \end{tabular}
\end{center}

\subsection{関係子のファミリー}

このファミリーは、結果値が\keyw{bool}型であるすべての関係演算子を含む。

\Ruledef{関係子}{
  \Ruleref{関係中置演算子} \dsepl \Ruleref{集合関係演算子}
  }

\Ruledef{関係中置演算子}{
  \Lit{=} \dsepl
  \Lit{<>} \dsepl
  \Lit{<} \dsepl
  \Lit{<=} \dsepl
  \Lit{>} \dsepl
  \Lit{>=}
  }

\Ruledef{集合関係演算子}{
  \Lop{subset} \dsepl
  \Lop{psubset} \dsepl
  \Lop{in set} \dsepl
  \Lop{not in set}
  }

\blankline
\begin{center}
  \begin{tabular}{ccc}
    \hline
    優先順位 & 関係子 \\
    \hline
    1       & {\tt <=}        & {\tt <}         \\
            & {\tt >=}        & {\tt >}         \\
            & {\tt =}         & {\tt <>}        \\
            & \keyw{subset}   & \keyw{psubset}  \\
            & \keyw{in set}   & \keyw{not in set}\\
    \hline \\
  \end{tabular}
\end{center}

\noindent 関係子ファミリーのすべての演算子は等しい優先順位をもつ。タイプしていくということが、これらを隣り合わせに用いるとき意味をもたせる方法のないことを語るものである。

\subsection{連結子のファミリー}

このファミリーは、結果が\keyw{bool}型であるすべての論理演算子を含む。

\Ruledef{連結子}{
  \Ruleref{論理前置演算子} \dsepl \Ruleref{論理中置演算子}
  }

\Ruledef{論理前置演算子}{
  \Lop{not}
  }

\Ruledef{論理中置演算子}{
  \Lop{and} \dsepl
  \Lop{or} \dsepl
  \Lit{=>} \dsepl
  \Lit{<=>}
  }

\blankline
\begin{center}
  \begin{tabular}{cc}
    \hline
    優先順位 & 連結子 \\ \hline
    1                & {\tt <=>}      \\
    2                & {\tt =>}  \\
    3                & \keyw{or}       \\
    4                & \keyw{and}     \\
    5                & \keyw{not}      \\
    \hline
  \end{tabular}
\end{center}

\subsection{構成子のファミリー}

このファミリーは値を構成するために用いられるすべての演算子を含む。 
これらの優先順は、演算子の暗黙部である括弧によってかまたは構文によって与えられる。

\subsection{グループ化}\label{grouping}

2項演算子の演算対象のグループ化は以下の通り:

\begin{list}{\bf no label!}{%
    \def\mylabel#1{\hspace\labelsep #1\hfill}
    \let\makelabel\mylabel
    \settowidth{\labelwidth}{Constructors: }
    \setlength{\leftmargin}{\labelwidth}
    \addtolength{\leftmargin}{2\labelsep}
    }
\item[結合子:] 右グループ化
\item[適用子:] 左グループ化
\item[連結子:]  `{\tt =>}' 演算子は右グループ化 \\ 他の演算子は組み合わされるもののため、グループ化の左右は同等である
\item[評価子:] 左グループ化\footnote{ 右グループ化を行う ``写像定義域限定'' および ``写像定義域削減'' 演算子を除く（これは標準ではない）}.
\item[関係子:] グループ化は行わない、意味をなさないからである
\item[構成子:] グループ化は行わない、意味をなさないからである
\end{list}

\subsection{型演算子}\label{preceedence}

型演算子は独自の優先順位をもち、以下の通り:
\begin{enumerate}
\item 関数型: {\tt ->, +>} (右グループ化).
\item 合併型: {\tt |} (左グループ化).
\item 他の2項型演算子: \verb+*+ (グループ化なし).
\item 写像型: \keyw{map} \ldots \keyw{to} \ldots および \keyw{inmap} \ldots
  \keyw{to} \ldots\ (右グループ化).%\nonstandard{0}
\item 単項型演算子: \keyw{seq of}, \keyw{seq1 of}, \keyw{set of}.
\end{enumerate}

\section{2つの具象構文間の相違}\label{sec:diff}

以下は数学構文とASCII構文との間で異なる記号のリストである:\\
%\samepage
%\begin{center}
\begin{longtable}{|l|l|}\hline
 \ldots$\Gmap$\ldots & {\tt map ... to ...} \kill
 数学構文 & ASCII構文  \\ \hline\hline
\endhead
\hline
\endfoot
 $\Dot$            & {\tt\char'046} \\
 $\Mult$              & {\tt *}        \\
 $\Le$            & {\tt <=}        \\
 $\Ge$            & {\tt >=}        \\
 $\Neq$            & {\tt <>}       \\
 $\Oto$            & {\tt ==>}      \\
 $\To$             & {\tt ->}       \\
 $\Implies$     & {\tt =>}          \\
 $\Equiv$ & {\tt <=>}               \\
 $\Mapsto$         & {\tt |->}       \\
 $\Fdef$           & {\tt ==}        \\
 $\Iterate$        & {\tt **}        \\
 $\Override$       & {\tt ++}        \\
 $\Mapmerge$         & {\tt munion} \\
 $\Dto$            & {\tt <:}                           \\
 $\Rto$            & {\tt :>}                          \\
 $\Dby$            & {\tt <-:}                          \\
 $\Rby$            & {\tt :->}                         \\
 $\Psubset$         & {\tt psubset}                     \\
 $\Subset$       & {\tt subset}                         \\
 $\Sconc$          & {\tt\char'136}                     \\
 $\Dinter$          & {\tt dinter}                      \\
 $\Dunion$          & {\tt dunion}                      \\
 $\Power$          & {\tt power}                        \\
 \ldots$\Set$            & {\tt set of ...}                    \\
 \ldots$\Seq*$              & {\tt seq of ...}                 \\
 \ldots$\Seq+$              & {\tt seq1 of ...}                 \\
 \ldots$\Gmap$\ldots           & {\tt map ... to ...}                 \\
 \ldots$\Bmap$\ldots           & {\tt inmap ... to ...}                 \\
 $\Muop$           & {\tt mu}                           \\
 $\Bool$           & {\tt bool}                         \\
 $\Nat$            & {\tt nat}                          \\
 $\Int$            & {\tt int}                          \\
 $\Real$           & {\tt real}                         \\
 $\Not$            & {\tt not}                          \\
 $\Inter$          & {\tt inter}                        \\
 $\Union$          & {\tt union}                        \\
 $\In$             & {\tt in set}                       \\
 $\Notin$          & {\tt not in set}                   \\
 $\And$            & {\tt and}                          \\
 $\Or$             & {\tt or}                           \\
 $\All$            & {\tt forall}                       \\
 $\Exists$         & {\tt exists}                       \\
 $\Exists!$        & {\tt exists1}                      \\
 $\Lambdaop$       & {\tt lambda} \\
 $\Iotaop$         & {\tt iota} \\
 $\ldots\Inverse$  & {\tt inverse ...} \\
%#ifdef VDMPP
% $\kWeave$         & {\tt w\_} \\
% $\kTraceset$      & {\tt t\_} \\
% $\kAlphabet$      & {\tt a\_} \\
%#endif VDMPP
\hline
\end{longtable}
% \end{center}

\newpage

\section{標準ライブラリ}\label{stdlib}\index{Standard libraries}\index{library}\index{Math}\index{IO}

\subsection{数学ライブラリ}
%When more than just the Math is available name should be given to each library by \subsubsection*

数学ライブラリは \ifthenelse{\boolean{VDMsl}}{{\tt math.vdm}}{{\tt math.vpp}} ファイルに定義されている。
以下の数学関数を提供する:

\begin{center}
\begin{tabular}{|l|l|p{6cm}|}\hline
\multicolumn{2}{|l|}{\bf 関数} & \bf 事前条件\\ \hline
\verb/sin: real +> real/ & Sine &  \index{Sine} \\ \hline
\verb/cos: real +> real/ & Cosine &  \index{Cosine} \\ \hline
\verb/tan: real -> real/ & Tangent & 引数は $^\pi\!/\!_2$ の整数倍でない\index{Tangent} \\ \hline 
\verb/cot: real -> real/ & Cotangent & 引数は $\pi$ の整数倍でない\index{Cotangent} \\ \hline
\verb/asin: real -> real/ & Inverse sine & 引数は-1から1の間(両端を含む)にない
                                           \index{Inverse sine}\\ \hline
\verb/acos: real -> real/ & Inverse cosine & 引数は-1から1の間(両端を含む)にない
                                      \index{Inverse cosine}\\ \hline
\verb/atan:real +> real/ & Inverse tangent & \index{Inverse tangent}\\ \hline
\verb/acot:real +> real/ & Inverse cotangent & 引数は0でない
					\index{Inverse cotangent}\\ \hline
\verb/sqrt: real -> real/ & 平方根 & 引数は負でない
                                          \index{平方根}\\ \hline
\verb/exp: real +> real/ & eを底とする指数関数 & 
                                          \index{指数関数}\\ \hline
\verb/ln: real +> real/ & 自然対数& 引数は正
                                          \index{自然対数}\\ \hline
\verb/log: real +> real/ & 対数 & 引数は正
                                          \index{対数}\\ \hline
\verb/srand: int ==> ()/ & 乱数の種(seed)初期化 & 引数は-1以上
                                          \index{乱数の種(seed)初期化}\\ \hline
\verb/rand: int ==> int/ & 擬似乱数生成 & 引数は0より大きい乱数最大値
                                          \index{擬似乱数生成}\\ \hline

\end{tabular}
\end{center}

また次の値が与えられる:

\begin{quote}
\texttt{pi} = 3.14159265358979323846\index{pi}
\end{quote}

関数が、ありうる事前条件を満たさないような引数とともに適用される場合に、適当な\vdmslpp{\vdmsl}{\vdmpp} 値、{\tt Inf} (無限値、たとえば\ {\tt  tan(pi/2)}) および {\tt NaN} (数でない値、たとえば\ {\tt sqrt (-1)})、でない値を返すであろう。


#ifdef VDMSL
% \subsubsection{Using the Math Standard Library with Flat Specifications}%
% \index{Math!use with flat specifications}
% 
% To use the standard library in a flat specification, the library file 
% \begin{quote}
% \verb+$TOOLBOXHOME/stdlib/mathflat.vdm+
% \end{quote}
% should be added to the
% current project. Functions from the standard library may then be
% accessed directly as the example below demonstrates:
% \begin{alltt}
% \keyw{types}
% 
% coord :: x : \keyw{real}
%          y : \keyw{real}
% 
% \keyw{functions}
% 
% -- euclidean metric between two points
% dist : coord * coord -> \keyw{real}
% dist (c1,c2) ==
%   sqrt((c1.x - c2.x) * (c1.x - c2.x) +
%        (c1.y - c2.y) * (c1.y - c2.y));
% 
% 
% -- outputs angle of line joining coord with origin
% -- from horizontal, in degrees
% angle : coord -> \keyw{real}
% angle (c) ==
%   atan (c.y / c.x) * 360 / ( 2 * pi)
% \end{alltt}
% 
% \subsubsection{Using the Math Standard Library with Modular Specifications}%
% \index{Math!use with modular specifications}
% 
モジュールの仕様記述内で標準ライブラリを使用する場合、以下のライブラリファイルを
\begin{quote}
\verb+$TOOLBOXHOME/stdlib/math.vdm+
\end{quote}
現在のプロジェクトに追加すべきである。
これは \texttt{MATH}モジュールから成り立つ。
このライブラリからの関数は、
必要に応じてそれらをモジュールに輸入することによって、このライブラリからの関数はいつもの通りにアクセス可能になるだろう。
以下の例で紹介する:

\begin{alltt}
\keyw{module} UseLib

  \keyw{imports}
    \keyw{from} MATH \keyw{all}

  \keyw{definitions}

  \keyw{types}

  coord :: x : \keyw{real}
           y : \keyw{real}

  \keyw{functions}

  -- euclidean metric between two points
  dist : coord * coord -> \keyw{real}
  dist (c1,c2) ==
    MATH`sqrt((c1.x - c2.x) * (c1.x - c2.x) +
              (c1.y - c2.y) * (c1.y - c2.y));

  -- outputs angle of line joining coord with origin
  -- from horizontal, in degrees
  angle : coord -> \keyw{real}
  angle (c) ==
    MATH`atan (c.y / c.x) * 360 / ( 2 * MATH`pi)

\keyw{end} UseLib
\end{alltt}

#endif VDMSL
#ifdef VDMPP
標準ライブラリを用いるには
\begin{quote}
\verb+$TOOLBOXHOME/stdlib/math.vpp+
\end{quote}
を現プロジェクトに加える必要がある。
これは \texttt{MATH}クラスを含む。
このクラスの関数にアクセスするためには、クラスのインスタンスが生成されていなければならない; 
しかしながら値はクラス属性なので、 \texttt{pi} は直接にアクセスされる可能性がある。
以下の例題がこれを実演する:
\begin{alltt}
\keyw{class} UseLib


  \keyw{types}

  coord :: x : \keyw{real}
           y : \keyw{real}

  \keyw{functions}

  -- 2点間の幾何距離
  dist : coord * coord -> \keyw{real}
  dist (c1,c2) ==
    \keyw{let} math = \keyw{new} MATH()
    \keyw{in}
    math.sqrt((c1.x - c2.x) * (c1.x - c2.x) +
              (c1.y - c2.y) * (c1.y - c2.y));


  -- 原点座標に交わる線の水平線からのなす角、
 -- 度数で出力する
  angle : coord -> \keyw{real}
  angle (c) ==
    \keyw{let} math = \keyw{new} MATH()
    \keyw{in}
    math.atan (c.y / c.x) * 360 / ( 2 * MATH`pi)

\keyw{end} UseLib
\end{alltt}
#endif VDMPP

\subsection{IOライブラリ}\index{IO}

 IO ライブラリは\ifthenelse{\boolean{VDMsl}}{{\tt io.vdm}}{{\tt io.vpp}} ファイルで定義され、 \verb+$TOOLBOXHOME/stdlib/+ ディレクトリに置かれている。
以下にリストされたIO 関数と操作が提供される。
各々の read/write 関数と操作は、 相当するIO行為の成功(\keyw{true}) または失敗(\keyw{false})を表すブール値 (またはブール構成要素をもつ組) を返す。

\begin{description}
\item[\texttt{writeval[@p]:[@p] +> bool}] \mbox{}\\
  この関数はASCII形式でのVDM値を標準出力に書き出す。
 事前条件はない。
\item[\texttt{fwriteval[@p]:seq1 of char * @p * filedirective +>
    bool}] \mbox{}\\
 この関数はASCII形式での VDM値 (第2引数)を、第1引数に文字列で指定された名称のファイルに書き出す。 
第3パラメーターは以下のように定義された型 \texttt{filedirective} をもつ:
  \begin{verbatim}
    filedirective = <start>|<append> 
  \end{verbatim}
  \texttt{<start>} が用いられた場合、存在するファイルは (あった場合には) 上書される; \texttt{<append>} が用いられた場合、出力は存在するファイルの最後に付け足されすでに存在しているものがなければ新しいファイルが生成される。 
事前条件はない。
\item[\texttt{freadval[@p]:seq1 of char +> bool * [@p]}] \mbox{}\\
この関数はASCII形式の VDM値を、最初の引数の文字列で指定されたファイルから読み取る。
事前条件はない。
関数は2つを返し、第1構成要素は読取の成功を示し、第2構成要素は読取が成功した場合の読み取られた値を示す。
\item[\texttt{echo: seq of char ==> bool}] \mbox{}\\
  この操作は与えられたテキストを標準出力に書き出す。
囲みのダブルクォートは取り除かれ、バックスラッシュ文字が \hypertarget{rule:escape sequence}{escape sequences}として翻訳される。
事前条件はない。
\item[\texttt{fecho: seq of char * seq of char * [filedirective] ==> bool}]
  \mbox{}\\
 この操作は \texttt{echo} に似ているが、標準出力ではなくファイルに書き出す。 
 \texttt{filedirective} パラメーターは \texttt{fwriteval} に対するものとして翻訳されるべきである。 
この操作に対する事前条件は、ファイル名称として空列が与えられた場合、テキストは標準出力に書かれるので \texttt{[filedirective]}引数は\keyw{nil}であるべきということである。 
\item[\texttt{ferror:()  ==> seq of char}]
  read/write関数と操作は、エラーが起きた場合にfalse を返す。
この場合は内部エラー列がセットされる。 
この操作はこの文字列を返しそれを\texttt{""}にセットする。
\end{description}

IO ライブラリの使用例として、ページヒットのログを保守するwebサーバーを考えよう:
#ifdef VDMPP
\begin{alltt}
  \keyw{class} LoggingWebServer

    \keyw{values}
      logfilename : \keyw{seq1 of char} = "serverlog"

    \keyw{instance variables}
      io : IO := \keyw{new} IO();

    \keyw{functions}
      URLtoString : URL -> \keyw{seq of char}
      URLtoString = ...

    \keyw{operations}
      RetrieveURL : URL ==> File
      RetrieveURL(url) ==
        (\keyw{def} - = io.fecho(logfilename, URLtoString(url)^\verb+"\n"+, <append>);
         ... 
        );

      ResetLog : () ==> \keyw{bool}
      ResetLog() ==
        io.fecho(logfilename,\verb+"\n"+,<start>)

  \keyw{end} LoggingWebServer
\end{alltt}
#endif VDMPP

#ifdef VDMSL
\begin{alltt}
  module LoggingWebServer

    \keyw{imports}
      \keyw{from} IO \keyw{all}

    \keyw{exports} \keyw{all}

    \keyw{definitions}

    \keyw{values}
      logfilename : seq1 of char = "serverlog"

    \keyw{functions}
      URLtoString : URL -> \keyw{seq} \keyw{of} \keyw{char}
      URLtoString = ...

    \keyw{operations}
      RetrieveURL : URL ==> File
      RetrieveURL(url) ==
        (\keyw{def} - = IO`fecho(logfilename, URLtoString(url)^\verb+"\n"+, <append>);
         ... 
        );

      ResetLog : () ==> \keyw{bool}
      ResetLog() ==
        IO`fecho(logfilename,\verb+"\n"+,<start>)

  \keyw{end} LoggingWebServer
\end{alltt}
#endif VDMSL

\subsection{VDMUtilライブラリ}\index{VDMUtil}

VDMUtilライブラリは、\ifthenelse{\boolean{VDMsl}}{{\tt VDMUtil.vdm}}{{\tt VDMUtil.vpp}}ファイルに定義され、
\verb+$TOOLBOXHOME/stdlib/+に配置されている。
VDMUtilライブラリは、以下のリストにあるようなVDMのユーティリティを関数や操作として提供する。

\begin{description}
\item[\texttt{set2seq[@T]:set of @T +> seq of @T}] \mbox{}\\
この関数は、任意の型を持つ集合を簡単に列に変換することができる。

\item[\texttt{get\_file\_pos: () +> [seq of char * nat
* nat * seq of char * seq of char]}] \mbox{}\\
この関数は、ソースの特定部分のコンテキスト情報（ファイル名、行番号、クラス名、関数・操作名）を抽出することができる。

\item[\texttt{P: () +> [seq of char * nat
* nat * seq of char * seq of char]}] \mbox{}\\
この関数は、get\_file\_pos関数と同じで、関数名が短い点だけが異なる。

\item[\texttt{val2seq\_of\_char[@T]: @T +> seq of char}] \mbox{}\\
この関数は、任意の値を文字列に変換することができる。

\item[\texttt{seq\_of\_char2val[@p]:seq1 of char -> bool * [@p]}] \mbox{}\\
この関数は、文字列をVDMの任意の値に変換することができる。

\item[\texttt{cast[@T1, @T2]: @T1 -> [@T2]}] \mbox{}\\
この関数は、narrow式と同じ型変換を行う。
過去の版との互換性のために存在し、今後、新たに使用する必要はない。

#ifdef VDMPP
\item[\texttt{clone[@T]: @T -> [@T]}] \mbox{}\\
インスタンス・オブジェクトのクローンを作る。
Javaのcloneメソッドと同様にshallowコピーを行う。
#endif VDMPP

\item[\texttt{classname[@T]: @T -> [seq1 of char]}] \mbox{}\\
インスタンス・オブジェクトのクラス名を得る。

\item[\texttt{char2code: char -> nat}] \mbox{}\\
文字から、そのUTF16コードの値を得る。

\item[\texttt{code2char: nat -> char}] \mbox{}\\
UTF16コードの値から、文字を得る。

\item[\texttt{current\_time: () ==> nat}] \mbox{}\\
1970年1月1日からのミリ秒形式で、現在時間を得る。

\end{description}
% #ifdef VDMPP
% 
% \begin{alltt}
% class VDMUtil
% 
% -- 	VDMTools STANDARD LIBRARY: MiscUtils
% --      --------------------------------------------
% -- 
% -- Standard library for the VDMTools Interpreter. When the interpreter
% -- evaluates the preliminary functions/operations in this file,
% -- corresponding internal functions is called instead of issuing a run
% -- time error. Signatures should not be changed, as well as name of
% -- module (VDM-SL) or class (VDM++). Pre/post conditions is 
% -- fully user customisable. 
% -- Dont care's may NOT be used in the parameter lists.
% 
% functions
% -- Converts a set argument into a sequence in non-deterministic order.
% static public
% set2seq[@T] : set of @T +> seq of @T
% set2seq(x) == is not yet specified;
% 
% -- Returns a context information tuple which represents
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% static public
% get_file_pos : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% get_file_pos() == is not yet specified;
% 
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% static public
% P : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% P() == is not yet specified;
% 
% -- Converts a VDM value into a seq of char.
% static public
% val2seq_of_char[@T] : @T +> seq of char
% val2seq_of_char(x) == is not yet specified;
% 
% -- Converts VDM value in ASCII format into a VDM value
% -- RESULT.#1 = false implies a conversion failure
% static public
% seq_of_char2val[@p]:seq1 of char -> bool * [@p]
% seq_of_char2val(s) ==
%   is not yet specified
%   post let mk_(b,t) = RESULT in not b => t = nil;
% 
% -- Cast value 
% static public
% cast[@T1, @T2] : @T1 -> @T2
% cast(s) == is not yet specified
%   pre is_(s, @T2);
% 
% -- Clone value 
% static public
% clone[@T] : @T -> @T
% clone(s) == is not yet specified;
% 
% -- Get class name
% static public
% classname[@T] : @T -> [seq1 of char]
% classname(s) == is not yet specified;
% 
% -- Convert a char into a UTF16 code value.
% static public
% char2code: char -> nat
% char2code(c) == is not yet specified;
% 
% -- Convert a UTF16 code value into a char.
% static public
% code2char: nat -> char
% code2char(c) == is not yet specified;
% 
% operations
% -- Get current time in miliseconds since Jan. 1, 1970
% static public
% current_time: () ==> nat
% current_time() == is not yet specified;
% end VDMUtil
% \end{alltt}
% #endif VDMPP
% 
% #ifdef VDMSL
% \begin{alltt}
% module VDMUtil
% exports all
% definitions
% 
% -- 	VDMTools STANDARD LIBRARY: MiscUtils
% --      --------------------------------------------
% -- 
% -- Standard library for the VDMTools Interpreter. When the interpreter
% -- evaluates the preliminary functions/operations in this file,
% -- corresponding internal functions is called instead of issuing a run
% -- time error. Signatures should not be changed, as well as name of
% -- module (VDM-SL) or class (VDM++). Pre/post conditions is 
% -- fully user customisable. 
% -- Dont care's may NOT be used in the parameter lists.
% 
% functions
% -- Converts a set argument into a sequence in non-deterministic order.
% set2seq[@T] : set of @T +> seq of @T
% set2seq(x) == is not yet specified;
% 
% -- Returns a context information tuple which represents
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% get_file_pos : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% get_file_pos() == is not yet specified;
% 
% -- (file_name * line_num * column_num * module_name * fnop_name) of corresponding source text
% P : () +> [ seq of char * nat * nat * seq of char * seq of char ]
% P() == is not yet specified;
% 
% -- Converts a VDM value into a seq of char.
% val2seq_of_char[@T] : @T +> seq of char
% val2seq_of_char(x) == is not yet specified;
% 
% -- Converts VDM value in ASCII format into a VDM value
% -- RESULT.#1 = false implies a conversion failure
% seq_of_char2val[@p]:seq1 of char -> bool * [@p]
% seq_of_char2val(s) ==
%   is not yet specified
%   post let mk_(b,t) = RESULT in not b => t = nil;
% 
% -- Cast value 
% cast[@T1, @T2] : @T1 -> @T2
% cast(s) == is not yet specified
%   pre is_(s, @T2);
% 
% -- Convert a char into a UTF16 code value.
% char2code: char -> nat
% char2code(c) == is not yet specified;
% 
% -- Convert a UTF16 code value into a char.
% code2char: nat -> char
% code2char(c) == is not yet specified;
% 
% operations
% -- Get current time in miliseconds since Jan. 1, 1970
% current_time: () ==> nat
% current_time() == is not yet specified;
% end VDMUtil\end{alltt}
% #endif VDMSL

\newpage
\addcontentsline{toc}{section}{Index}
\printindex

\end{document}


