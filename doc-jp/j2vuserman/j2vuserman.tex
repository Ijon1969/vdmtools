% LaTeX 2e Document.
% 
% $Id: j2vuserman.tex,v 1.25 2006/04/19 10:56:48 vdmtools Exp $
% 

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% PDF compatibility code. 
\makeatletter
\newif\ifpdflatex@
\ifx\pdftexversion\@undefined
\pdflatex@false
%\message{Not using pdf}
\else
\pdflatex@true
%\message{Using pdf}
\fi

\newcommand{\latexorpdf}[2]{
  \ifpdflatex@ #2
  \else #1
  \fi
}

#ifdef A4Format
\newcommand{\pformat}{a4paper}
#endif A4Format
#ifdef LetterFormat
\newcommand{\pformat}{letterpaper}
#endif LetterFormat

\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\latexorpdf{
\documentclass[\pformat,12pt]{jarticle}
}{
\documentclass[\pformat,pdftex,12pt]{jarticle}
}

\usepackage[dvipdfmx]{graphicx, color}
\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}

\usepackage{toolbox}
\usepackage{vdmsl-2e}
\usepackage{alltt}
%\usepackage{graphics}
\usepackage{makeidx}
%\usepackage{palatino}
\usepackage{ifthen}
\usepackage{verbatim}

\usepackage{vpp}

\graphicspath{{figures/}}
\def\seename{$\Rightarrow$}
\AtBeginDvi{\special{pdf:tounicode 90ms-RKSJ-UCS2}}
% Ueki change start
%\usepackage[dvipdfm,bookmarks=true,bookmarksnumbered=true,colorlinks,plainpages=true]{hyperref}
% Ueki change end

% Ueki delete start
%\latexorpdf{
%\usepackage[plainpages=true,colorlinks,linkcolor=black,citecolor=black,pagecolor=black, urlcolor=black]{hyperref}
%}{
%\usepackage[plainpages=true,colorlinks]{hyperref}
%}
% Ueki delete end

\makeindex

\def\vdmsl{{\small VDM-SL}}
\def\vdmpp{{\small VDM}++}
\newcommand{\vdmslpp}{VDM++}
\newcommand{\vdmslppEm}{VDM++}
\newcommand{\ToolboxName}{VDM++ Toolbox}
\newcommand{\Toolbox}{Toolbox}
\newcommand{\toolbox}{Toolbox}
\newcommand{\vdmde}{vppde}
\newcommand{\vdmgde}{vppgde}
\newcommand{\vdmhome}{vpphome}
\newcommand{\vdmdeNineteen}{vppde-19}
\newcommand{\vdmdeNineteenEl}{vppde-19.el}
\DeclareRobustCommand{\VdmSlPp}{VDM++-\VdmSl}
\newcommand{\vdmext}{vpp}
\newcommand{\vdmtoolsver}{v9.0.6}
\newcommand{\cg}{\vdmslpp\ to C++ Code Generator}

\newcommand{\JAVA}{Java}
\newcommand{\tjTov}{the \JAVA\ to VDM++ translator}
\newcommand{\TjTov}{The \JAVA\ to VDM++ Translator}
\newcommand{\VDM}{VDM++}
\newcommand{\jTov}{\JAVA\ to VDM++ Translator}



\newcommand{\subsubsubsection}[1]{\paragraph{#1}\mbox{}\\}


% The use of VDMSL/VDMPP ifdef's have basicly been exchanged with the
% use of LaTeX ifthenelse's.  For this two LaTeX boolean value VDMSL and
% VDMpp have been defined  (Lowercase p's are used to avoid conflict with
% the VDMPP environment variable.  The typical use are:
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{vdmpp-text}
%   \ifthenelse{\boolean{VDMsl}}{vdmsl-text}{}
%   \ifthenelse{\boolean{VDMpp}}{vdmpp-text}{}
% The advantage of this as opposed to ifdef's is that within a general
% paragraph specific VDM-SL and VDM++ parts can be distinguished without
% problematic empty lines.
% 
% The values are initialised such that exactly one of the values is true
% and the other is false.  This should hopefully avoid strange behaviour
% due to possible preprossing errors.  The default case is VDM-SL.
\newboolean{VDMsl}
\setboolean{VDMsl}{true}
\newboolean{VDMpp}
\setboolean{VDMpp}{false}
\setboolean{VDMpp}{true}
\setboolean{VDMsl}{false}

\newcommand{\AfterInit}[1]{}
%Initialisation must be performed before
%  {\tt #1} can be called.}

% This macro can be used in `description' lists where
% the item given to `meti' is put on its own line,
% thereby giving proper (nicer) identation to the
% explanation.
\newcommand{\meti}[1]{\item[#1]\mbox{}\\}

\newcommand{\Index}[1]{#1\index{#1}}

\newcommand{\Lit}[1]{`#1\Quote}
\newcommand{\Rule}[2]{
  \begin{quote}\begin{tabbing}
    #1\ \ \= = \ \ \= #2  ; %    Adds production rule to index
  \end{tabbing}\end{quote}
  }
\newcommand{\SeqPt}[1]{\{\ #1\ \}}
\newcommand{\lfeed}{\\ \> \>}
\newcommand{\OptPt}[1]{[\ #1\ ]}
\newcommand{\dsepl}{\ $|$\ }
\newcommand{\dsep}{\\ \> $|$ \>}
\newcommand{\Lop}[1]{\Lit{\kw{#1}}}
\newcommand{\Sig}[1]{\Lit{{\tt #1}}}
\newcommand{\blankline}{\vspace{\baselineskip}}
\newcommand{\Brack}[1]{(\ #1\ )}
\newcommand{\nmk}{\footnotemark}
\newcommand{\ntext}[1]{\footnotetext{{\bf Note: } #1}}

\usepackage[]{color}
\usepackage{longtable}
\usepackage{float}
\definecolor{covered}{rgb}{0,0,0}     %black
\definecolor{not_covered}{gray}{0.5}  %gray

%\restylefloat{figure}
\setcounter{topnumber}{3}
\def\topfraction{1.0}
\setcounter{bottomnumber}{3}
\def\bottomfraction{1.0}
\setcounter{totalnumber}{3}
\def\textfraction{.1}


\parindent0mm

\newlength{\keywwidth}

\newcommand{\xfigpicture}[4]{
\begin{figure}[hbt]
\setlength{\unitlength}{1mm}
\begin{center}
\mbox{
\begin{picture}(#1,#2)
\put(0,0){\special{psfile=#3 hscale=70 vscale=55}}
\end{picture} }
\end{center}
\caption{#4}
\end{figure}
}

%\newcommand{\qq}{\marginpar{\bf ???}}
\newcommand{\aaa}{\tt }
\newcommand{\cmd}{\tt }
\newcommand{\guicmd}[1]{{\sf #1}}
\newcommand{\keyw}[1]{{\sf #1}}
%\newcommand{\id}[1]{%
%  \settowidth{\keywwidth}{\tt #1}%
%  \protect\makebox[\keywwidth][l]{{\it #1}}}
%\nolinenumbering

\begin{document}
\vdmtoolsmanualcsk{Java → \vdmslpp\ ユーザマニュアル}
       {\vdmtoolsver}
       {2016}
       {\vdmslpp}
       {1.0}
 

\section{導入} \label{sec:introduction}

This manual gives an introduction to the Java to \vdmslpp\ feature
of \VDMTools. This feature can be used for reverse
engineering existing legacy Java applications to VDM++. At the VDM++
level different kinds of analysis may then be conducted and new
features specified and forward engineered.
本書では、\VDMTools の中で Java から\vdmslpp の機能についての導入を行う。
現存する古い仕様の Java アプリケーションを VDM++へとリバースエンジニアリングを行うために、この機能を用いることが可能である。
そのために VDM++レベルで様々な種類の分析が行われ、新たな機能が指定されて、フォワードエンジニアリングが行われる可能性がある。

The Java to \vdmslpp\ translator is an add-on feature to the
\ToolboxName{}. This manual is an extension to the {\em User Manual
  for the VDM++ Toolbox} \cite{UserManPP-CSK}. In general it is
intended that the standard \texttt{javac} should always be invoked on
a collection of Java files 
before they are included in a project with \VDMTools. If Java code
which cannot be accepted by \texttt{javac} is provided \VDMTools\ may
not behave correctly.
 Java から \vdmslpp\ への翻訳は、\ToolboxName{}　に対してアドオン機能となる。
本書は、 {\em User Manual for the VDM++ Toolbox} \cite{UserManPP-CSK}の拡張版である。
一般的には、標準 \texttt{javac} が \VDMTools でプロジェクトに取り込まれる前のJava ファイルが収集される時点で、常に起動されるべきである。
 \texttt{javac} で受け入れることができない Java コードがもちこまれた場合には、\VDMTools\ が正しく動作しない可能性がある。

This manual starts by explaining how to include Java classes in a
project file in the \ToolboxName{}. This is followed by an overview of the
options for the Java to VDM++ translator, which include the ability to
apply a set of transformations to the generated \vdmslpp\ which
convert certain parts of it to equivalent but more abstract
forms. More details of this feature can be found in Section‾\ref{xforms}.
本書では最初に、 \ToolboxName{}のプロジェクトにJavaクラスを組み入れる方法を述べる。
次にJava から VDM++ へ翻訳を行うためのオプションを概説するが、生成された\vdmslpp\ に対して変換の集合を当てはめること、つまりある部分をそれと同等だがより抽象的な形態へ変換する、ということも可能だ。
この機能の詳細はSection‾\ref{xforms}で見ることができる。

Section‾\ref{limitations} describes the different limitations for \tjTov{}.
This includes all the different situations which should be
avoided in order to automatically produce an equivalent VDM++ model
for a collection of Java source files.
第‾\ref{limitations}章では、 \tjTov{}に対する制限のいろいろを述べる。
これは、Javaソースファイルの集まりに対して同等の VDM++ モデルを自動的に生成するために、避けるべき様々な状況すべてを含めている。

Section‾\ref{sec:translation}  gives specific details of the
translation process and also describes some of the design decisions
made when developing the \jTov{}, including the name conventions
used. This section should be studied intensively before using \tjTov\ 
professionally.
第‾\ref{sec:translation}章では、翻訳プロセスの具体的な詳細について述べ、また、 \jTov{}を展開する上でなされたデザイン決定をいくつか述べるが、使用される名称の慣習についても含めている。
この章は \tjTov\ を職業的に使用する場合には、集中して学習するべきであろう。

Finally, Section‾\ref{javaapi} describes the subset of \JAVA\ API
which is available at the \VDM\ level. 
最後に第‾\ref{javaapi}章では、 \VDM\ レベルで役立つ \JAVA\ APIのサブセットを説明する。
\section{Javaクラスをプロジェクトに含める}

Before your Java source files can be automatically translated to VDM++
using the translator described in this manual you need to include all
the files you would like to have translated into a \VDMTools\
project. 
本書に記述した変換装置を用いて、Javaのソースファイルが VDM++へと自動的な翻訳を可能とする前に、まずは翻訳したいすべてのファイルを \VDMTools\ プロジェクトに含めておく必要がある。

To do this, first start up the \ToolboxName{} (details of how to do
this can be found in the general User Manual for the VDM++
Toolbox \cite{UserManPP-CSK}), then press the 
\raisebox{-0.4mm}{\includegraphics[width=0.03\textwidth]{plus}}  
(\guicmd{Add Files}) button on the (\guicmd{Project Operations})
toolbar (or if you prefer you can select the action \guicmd{Add File
  to Project} on the \guicmd{Project} menu). The dialog box shown
in Figure‾\ref{fig:addJavaFiles} will then appear. 
これを行うために、最初に \ToolboxName{} をスタートし(これを行う方法の詳細は VDM++ Toolboxの一般向けユーザーマニュアル \cite{UserManPP-CSK}で見ることができる)、次に (\guicmd{Project Operations})ツールバー上の\raisebox{-0.4mm}{\includegraphics[width=0.03\textwidth]{plus}}  (\guicmd{Add Files}) ボタンを押す (あるいは、 \guicmd{Project} メニュー上でアクション \guicmd{Add File to Project}を選択することもできる)。 
すると、図‾\ref{fig:addJavaFiles} で示されたダイアログが現れる。

\begin{figure}[tbh]
\begin{center}
\mbox{}
\resizebox{11cm}{!}{\includegraphics{addJavaFiles}}
\caption{プロジェクトにファイルを加える\label{fig:addJavaFiles}}
\end{center}
\end{figure}

As an example, select the five {\tt .java} files in the 
{\tt \vdmhome/java2vdm/examples/sort} directory from the
\Toolbox\ distribution by holding down the {\cmd Ctrl} key and
clicking the left-hand mouse button on each of the 
files in turn. Then press the ``Open'' button. The files will then
be included in the project and will appear in the \guicmd{Project View}
of the \guicmd{Manager} in the main \Toolbox\ window as
shown in Figure‾\ref{fig:addedJavaFiles}. You can also add a single
file to a project by double clicking the left-hand mouse button on it
(but note that this also closes the dialog box so it is not an
efficient way of adding a number of files), and you can also mark a
list of files at the same time by selecting the first and last files
in the list (in either order), holding down the {\cmd Shift} key while
making the second selection. 
例として、\Toolbox\ 配布の{\tt \vdmhome/j2vexamples/sort} ディレクトリ中の５つのファイルを、{\cmd Ctrl} キーを押し各々のファイルを順に左側マウスボタンでクリックすることで、選択していく。
次に ``Open'' ボタンを押す。
するとファイルはプロジェクトに含まれ、 図‾\ref{fig:addedJavaFiles}に見られるように \Toolbox\ メインウィンドウにある \guicmd{Manager} の \guicmd{Project View}に現れることになる。
さらに１つのファイル上で左側マウスボタンをダブルクリックし、これをプロジェクトに加えることもできるし(ただしこれによってダイアログが閉じてしまうため、たくさんのファイルを加える場合は効率的な方法ではない)、 また最初と最後(どちらが先でもよい)を選択し後の選択で {\cmd Shift} キーを押した状態に保つことで、ファイル一覧の選択を同時に行うこともできる。

\begin{figure}[tbh]
\begin{center}
\resizebox{8cm}{!}{\includegraphics{addedJavaFiles}}
\caption{ファイル追加後の管理}\label{fig:addedJavaFiles}
\end{center}
\end{figure}

It is important here to note that it is also necessary to include some
Java API skeletons in the project. These define functionality
equivalent to the standard Java API classes except that in general
they only include the signatures of methods because this information
is all that is required in order to perform the necessary checks on
your Java project files. These files are located in the {\tt
  \vdmhome/java2vdm/javaapi/java} directory, and the particular files
required for this application are shown in
Figure‾\ref{fig:javaLibFiles}. Add these to the 
project in the same way.
ここで、プロジェクトにJava API スケルトンをいくつか含める必要があることに、注意を向ける必要がある。
これらは一般的にメソッドのシグニチャを含めるだけである以外は、標準 Java API クラスと同等な機能を定義するものだが、対象のJavaプロジェクトファイル上で必要なチェックを行うためには、これが必要とされる全情報となるからである。
これらファイルは {\tt  \vdmhome/java2vdm/javaapi/java}ディレクトリ中に配置され、このアプリケーションに必要な特定ファイルは図‾\ref{fig:javaLibFiles}で示されている。 
同じ方法を用いて、これらをプロジェクトに加えよう。

\begin{figure}[tbh]
\begin{center}
\resizebox{8cm}{!}{\includegraphics{javaLibFiles}}
\caption{必要とされた Java API スケルトン}\label{fig:javaLibFiles}
\end{center}
\end{figure}

Next you need to syntax check all your Java files, including the Java
API skeleton files. 
次に、Java APIスケルトンファイルを含め、対象Javaファイルすべての構文チェックを行う必要がある。

To do this, select all the files in the \guicmd{Project View} 
of the \guicmd{Manager}, then press the 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck}}  
(\guicmd{Syntax Check}) button on the (\guicmd{Class Operations})
toolbar. (Selecting the containing level folders and
applying the syntax check operation to those  has the same effect --
this applies the syntax check operation to each of the  files in the folders.) 
Notice that at this point the \guicmd{Log Window} opens automatically
(if it is not already open) and displays a message informing you of
the success or failure of the check for each file. In addition, if
syntax errors are discovered the \guicmd{Error List} is
also au\-to\-matically invoked and the \guicmd{Source Window} is
automatically opened. See the general User Manual for the VDM++
Toolbox \cite{UserManPP-CSK} for information about the \guicmd{Error List}
and the \guicmd{Source Window} and about using the \guicmd{External
  Editor} to correct errors.
これを行うためには、 \guicmd{Manager}の\guicmd{Project View} にある全ファイルを選択してから、(\guicmd{Class Operations})ツールバーの\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheck}}  (\guicmd{Syntax Check}) ボタンを押そう。
(フォルダレベルで選択を行いそれらに構文チェックを適用することでも、同様の効果を得る --つまりこれでフォルダ中の各ファイルに、構文チェック操作を適用することになる。) 
この時点で、\guicmd{Log Window} が(まだ開いていない場合に)自動的に開き、各ファイルに対するチェックが成功したか失敗したかを知らせるメッセージを表示することに注意しよう。
加えて構文エラーが発見された場合には、自動的に \guicmd{Error List} も起動され \guicmd{Source Window} も開かれる。 
 \guicmd{Error List}と \guicmd{Source Window}についてや、エラー修正のための \guicmd{External Editor} 使用についての情報は、VDM++ツールボックスの一般向けユーザーマニュアル \cite{UserManPP-CSK} を参照しよう。

The next step is to ``type check'' your files, that is to check that
they only use the subset of Java 
that can be translated to VDM++ (see Section‾\ref{limitations} for a
description of the current limitations). However, this is not
necessary for the Java API skeleton files because these do not need to
be translated and syntax checking gives enough context information to
allow you to check and translate the Java files from your own
application successfully. So just select the folder containing the
application files and invoke the type checker by pressing the 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheck}}
(\guicmd{Type Check}) button on the (\guicmd{Class Operations})
toolbar. 
次の段階は対象ファイルを ``型検査'' することで、 VDM++ に翻訳可能なJavaのサブセットだけを用いているかどうかをチェックする(現段階の制限の記述は第‾\ref{limitations}を参照)。
しかしJava API スケルトンファイルに対してはこれは不要で、なぜならばこれらは翻訳の必要がなく、対象アプリケーションのJavaファイルを自身でうまくチェックし翻訳するために十分な文脈情報を、構文チェックで得られるからである。
したがって、アプリケーションファイルを含むフォルダを選択し、 (\guicmd{Class Operations})ツールバー上の\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheck}}(\guicmd{Type Check}) ボタンを押して、型検査をただ発動することである。
Note that after Java files have been successfully syntax checked the
names of the classes defined in those files are listed in the
\guicmd{Java View} in the \guicmd{Class View} of the
\guicmd{Manager}. You can select individual classes here to which you
want to apply Toolbox operations (i.e.\ instead of applying the
operations to all the classes in a file as is done in the
\guicmd{Project View}). You can also see the current status of each of
the individual Java classes in the project. 
Java ファイルの構文チェックがうまくなされると、その後はそれらのファイルで定義されたクラスの名称が、\guicmd{Manager}の \guicmd{Class View}にある\guicmd{Java View} に一覧されることに注意しよう。
この段階でツールボックス操作を適用したいクラス個々を選択することができる (つまり\guicmd{Project View}で行ったのと同様の、１ファイル内の全クラスに対して操作を適用するという代わりにである)。 
さらにプロジェクト内のJavaクラス個々の、それぞれの現在状態を見ることもできる。

Figure‾\ref{fig:javaView} shows the current state of the \guicmd{Java
  View}. The symbol
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone}}
in the \guicmd{Syntax} column next to each class indicates that it has
  been syntax checked successfully, and the symbol
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone}}
  in the \guicmd{Type} column next to the classes belonging to the
  example application indicate that these have also been successfully
  type checked. In case the syntax or type check was unsuccessful, the
  symbols 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckerror}}
  respectively
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror}}
are shown in the appropriate columns instead. In addition, if a source
  file is edited the symbol
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified}}
  (this is the symbol 
\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone}}
with a red triangle superimposed)
is shown in the \guicmd{Syntax} column to indicate that there is an
  inconsistency between the version of the file 
currently in the \Toolbox\ and the version on the file system. The
file must be syntax checked (and type checked) again before proceeding.
図‾\ref{fig:javaView} は \guicmd{Java View}の現在状態を表している。 
各クラスの隣の \guicmd{Syntax} 列の記号\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone}}は、構文チェックがうまくなされたことを示し、例題アプリケーションに含まれているクラスの横の \guicmd{Type}列の記号 \raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckdone}}は、それらが型チェックもまたうまくなされたことを示す。
構文チェックと型チェックとが成功しなかった場合は、記号\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckerror}}や\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{typecheckerror}}が代わりにそれぞれ適した列に示される。
さらにもしソースファイルが編集されているならば、記号\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckmodified}}  (これは\raisebox{-0.7mm}{\includegraphics[width=0.03\textwidth]{syntaxcheckdone}}に赤い三角形が重なった記号)が構文列に表われて、 \Toolbox\ 中の現ファイルバージョンとファイルシステムのバージョンに矛盾があることを示す。
このファイルは処理が進む前に再度、構文チェック (および型チェック)がなされなければならない。

\begin{figure}[tbh]
\begin{center}
\resizebox{8cm}{!}{\includegraphics{javaView}}
\caption{Java View}\label{fig:javaView}
\end{center}
\end{figure}

Once your files/classes have passed the syntax and type checks, they
are ready to be translated to VDM++. Select the five classes belonging
to the example application (you do not need to translate the Java API
skeleton classes but you will later need to load VDM++ equivalents of
these which are also supplied with the Toolbox), then press the
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{java2vdm}}
button to translate them to VDM++. The symbol 
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmdone}}
appears in the \guicmd{VDM} column of the \guicmd{Java View} next to
each of the selected classes to indicate that it was translated
successfully‾(see Figure‾\ref{fig:translationDone}). In case of failure,
the symbol  
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmerror}}
is shown instead.
ファイルあるいはクラスを構文チェックと型チェックに渡してしまえば、その時点で VDM++に翻訳される準備が整ったことになる。 
例題アプリケーションに属する５つのクラスを選択し(Java APIスケルトンクラスを翻訳する必要はないが、後でツールボックスで提供されるこれらの VDM++ 同等物を読み込む必要があるだろう)、その後 VDM++に翻訳するために\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{java2vdm}}ボタンを押そう。 
記号 \raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmdone}}は翻訳が成功したことを示し、 \guicmd{Java View} で \guicmd{VDM} 列の選択クラス各々の横に現れる‾(図‾\ref{fig:translationDone}を参照)。 
失敗の場合は、この代わりに記号\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{java2vdmerror}}が表示される。

\begin{figure}[tbh]
\begin{center}
\resizebox{8cm}{!}{\includegraphics{translationDone}}
\caption{翻訳後のJava View}\label{fig:translationDone}
\end{center}
\end{figure}

This generates five {\tt .vpp} files, one for each class. These can be
seen by returning to the \guicmd{Project View}‾(see
Figure‾\ref{fig:vdmFiles}). 
それぞれのクラスに対して１つで、５つの {\tt .vpp} ファイルが生成される。
 \guicmd{Project View}‾(図‾\ref{fig:vdmFiles}参照)に戻れば、これらを見ることができる。

\begin{figure}[tbh]
\begin{center}
\resizebox{8cm}{!}{\includegraphics{vdmFiles}}
\caption{生成された VDM++ ファイル}\label{fig:vdmFiles}
\end{center}
\end{figure}

You have now finished with the Java files and we recommend that you
remove them from the project -- select them all and press the 
\raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{minus}}
(\guicmd{Remove Files}) button on the \guicmd{Project Operations}
toolbar.
 Javaファイルについての処理はこれで終わりなので、プロジェクトからの削除を推奨する -- これらすべてを選択してから \guicmd{Project Operations}ツールバー上の \raisebox{-0.8mm}{\includegraphics[width=0.03\textwidth]{minus}}(\guicmd{Remove Files}) ボタンを押すこと。

The final step is to add the VDM++ files which correspond to the Java
API skeletons used with the Java files. These can be found in the {\tt
  \vdmhome/java2vdm/javaapi/vpp} directory, but since a lot of files are
required we recommend that to save time you add the contents of all
the appropriate subdirectories rather than the individual files. These
subdirectories are shown in Figure‾\ref{fig:vdmApiFiles}. 
最終段階で、 Java ファイルと共に用いた Java API スケルトンに相当する VDM++ファイルを追加する。 
これらは {\tt \vdmhome/java2vdm/javaapi/vpp} ディレクトリで見つけることができるが、結構たくさんのファイルが要求されるため、個々のファイルより適当なサブディレクトリの全内容を追加することで、手間を省くことを推奨する。
 図‾\ref{fig:vdmApiFiles}ではこういったサブディレクトリが示されている。

\begin{figure}[tbh]
\begin{center}
\resizebox{8cm}{!}{\includegraphics{vdmApiFiles}}
\caption{VDM++ API ファイル}\label{fig:vdmApiFiles}
\end{center}
\end{figure}

In fact these files also contain only skeletons of the appropriate
classes in general, the main functionality being provided through the
dynamic link facility of the Toolbox (see \cite{DLMan-CSK} for
details). Thus the bodies of the methods in the skeleton classes
appear in general as \textsf{is not yet specified} and the
functionality is linked in as executable C++ code. In order to access
this code (so that, for example, you can use the interpreter to debug
your specification), you need to make sure the Toolbox knows where to
find it. In fact it is contained in the file {\tt
  \vdmhome/bin/j2vdll.so}, so you should either add this full 
path name to your global path or include the directory {\tt
  \vdmhome/java2vdm/javaapi} in the list of directories referenced by the
environment variable {\tt VDM\_DYNLIB}. (Alternatively you can copy
the file {\tt \vdmhome/bin/j2vdll.so} to the current directory.)
実際には、主な機能がツールボックスの動的リンク設定を通して提供されるので、通常これらファイルもまた適当なクラスのスケルトンを含むだけである (詳細は\cite{DLMan-CSK} 参照)。 
このように、通常 \textsf{is not yet specified} と表されたスケルトンクラスのメソッド本体とその機能は、実行可能な C++ コードとして組み入れられている。
このコードにアクセスするには (それにより、仕様デバッグのためにインタープリタ使用が可能である)、ツールボックスがどこを捜せばよいかを知っていると信じる必要がある。 
実際にはファイル {\tt  \vdmhome/bin/j2vdll.so}中にこれが含まれているので、グローバルパスにこのフルパス名を付け加えるか、あるいは、環境変数 {\tt VDM\_DYNLIB}で参照されるディレクトリ一覧にディレクトリ {\tt  \vdmhome/java2vdm/javaapi} を含めるべきである。
(代わりに、カレントディレクトリにファイル {\tt \vdmhome/bin/j2vdll.so}をコピーすることもできる。)

You now have a set of VDM++ files which correspond to your original
Java application and you can interact with these as with any other
VDM++ project. See the User Manual for the VDM++ Toolbox
\cite{UserManPP-CSK} for details.
これで元のJavaアプリケーションに相当する VDM++ ファイル集合を得たわけで、他のVDM++ プロジェクト同様、これらとの情報のやりとりが可能である。
詳細は VDM++ ツールボックス\cite{UserManPP-CSK} ユーザーマニュアルを参照のこと。

\section{翻訳オプション}

The Java to VDM++ translator has two options which can be set in the 
\guicmd{Java to VDM++} panel of the \guicmd{Project Options} window, 
which is displayed by pressing the
\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{projectoptions}} 
(\guicmd{Project Options}) button on the (\guicmd{Project Operations})
toolbar. This is shown in Figure‾\ref{fig:j2voptions}.
Java から VDM++ 翻訳には、 \guicmd{Project Options}画面の \guicmd{Java to VDM++}パネルで設定を行うことができる２つのオプションがあり、 (\guicmd{Project Operations})ツールバーの\raisebox{-1.0mm}{\includegraphics[width=0.03\textwidth]{projectoptions}} (\guicmd{Project Options}) ボタンを押すことで表示される。
これは 図‾\ref{fig:j2voptions}に示されている。

\begin{figure}[tbh]
\begin{center}
\resizebox{12.5cm}{!}{\includegraphics{j2vOptions}}
\caption{Java から VDM++ 翻訳でのオプション設定\label{fig:j2voptions}}
\end{center}
\end{figure}

The possible options are as follows:
可能なオプションは以下の通り:
\begin{description}
\item[Generate stubs only:]
If this option is selected it means that the translator will only
produce VDM++ code for class members and method signatures and will
use the ``is not yet specified'' construct for the VDM++ operation
bodies; 
\item[スタブのみ生成:]
このオプションが選択された場合の翻訳は、クラス要素およびメソッドシグニチャのみの生成を行い、  VDM++ 操作本体に対しては``is not yet specified''構成を用いることになる; 
% \item[Automatic renaming:]
% If this option is selected all occurrences of identifiers in Java
% which have the same names as VDM++ keywords will be automatically
% renamed by adding a suffix of two underscore symbols; 
% \item[Generate accessor functions:] This option is not yet implemented
% in the Java to VDM++ translator.
\item[Apply VDM++ transformations] If this option is selected the
  VDM++ which is generated by the translator is also passed through a
  series of transformations which convert certain parts of the
  specification to equivalent but more abstract forms. This feature is
  described in more detail in Section‾\ref{xforms}. 
\item[VDM++ 変換の適用] このオプションが選択されると、翻訳で生成された VDM++は、さらに仕様部分をそれと同等だがさらに抽象的な形態への変換にと引き渡される。
この機能の詳細は、さらに 第‾\ref{xforms}章で述べられる。
\end{description}

\section{制限}\label{limitations}

This section explains the current limitations on the Java to VDM++
translator and also includes recommendations on how your Java
source files should be modified before using the translator.
この章では、Java から VDM++翻訳における現時点での制限について説明を行い、翻訳にかける前にどのようにJavaファイルの修正を行うべきかという提案をさらに含める。

\subsection{Java と VDM++間のスコープの相違}

The scope rules for Java and VDM++ are not identical. Thus, there are
a number of limitations for the Java to VDM++ translator which are
related to this difference. In general it is worth noting here that
the default modifier in Java is package. In VDM++ the default modifier
is private and no semantic package structure is present. Thus, when
the Java to VDM++ translator translates all default modifiers to
default modifiers in VDM++ there is a semantic difference. This gives
less visibility than in Java, but this reflects the differences in
scoping for the two languages. A number of limitations related
to scope issues are presented below.
Java と VDM++ におけるスコープ規程は同一ではない。
したがってこの相違に関連して、JavaからVDM++ の翻訳にたくさんの制限がある。
一般的にはここで注目されるのが、Javaの既定の修飾子がパッケージ化されているということである。
VDM++では既定の修飾子はプライベートのもので、意味上のパッケージ構造は存在しない。 
このように、JavaからVDM++翻訳では、すべての既定修飾子を VDM++ の既定修飾子に翻訳する場合に、意味上の相違がある。
これは Javaよりも可視性を弱めるが、２つの言語間のスコーピングの相違を反映するものだ。
スコープ問題に関連した多くの制限を、以下に提示する。

\subsubsection{クラス名称}

Class names in Java are considered as being local to packages, which
means that it is possible in a Java program to have two classes with
the same name provided they belong to different packages. In VDM++,
however,  the notion of packages is purely syntactic: class
names are effectively globally visible and there cannot be two classes
with the same name in the same project, even if they belong to
different packages. Thus, if two Java classes have the same name, one
of these must be renamed before translation to VDM++.
Javaのクラス名称はパッケージに対して局所的であると考えられ、つまりJavaプログラムでは異なるパッケージに属する同じ名称の２つのクラスの提供が可能であることを意味している。
VDM++ではしかし、パッケージの観念は純粋に構文的なことであり：クラス名称は効果的に全体が可視されるもので、たとえ異なるパッケージに属していても同じプロジェクトに同じ名称の２つのクラスの存在はあり得ない。
このように、２つのクラスが同じ名称をもつ場合、そのうち１つは VDM++翻訳される前に改名されなければならない。

\subsubsection{名称不一致}

In Java there are less restrictions on the overloading of names than
in VDM++ so that, for example, in Java it is possible to have an instance
variable and a method with the same name in the same class  whereas in
VDM++ this causes an error.  
JavaではVDM++におけるよりも名称多重化について制限は少なく、例えばJavaでは同じクラス中で同じ名称のインスタンス変数とメソッドの存在が可能であるが、一方のVDM++ではこれはエラーを引き起こす。

\begin{small}
\begin{verbatim}
class B
{
  public int b() { return 0 };
}
class A extends B
{ 
  b: int:=0;
}
\end{verbatim}
\end{small}

\begin{small}
\begin{verbatim}
class B

operations
  public b : ()  ==> int
  b() == ( return 0);

end B

class A is subclass of B

instance variables
  b: int:=0;        -- Error: "b" is multiple defined in super classes
  b: int:=0;        -- Error: "b" はスーパークラスで多重定義されている

end  A
\end{verbatim}
\end{small}

In general, the restriction in VDM++ is that there should never be two
different constructs with the same name visible in the same scope and
the Java should generally respect this. Of course the visibility of
constructs can be determined by the access modifiers so that it is
possible for a construct in a subclass to have the same name as a
private construct in a superclass as in the following example:
一般的にVDM++における制限は、同一スコープ内に同じ名称をもつ異なる２つの構成要素が見えてはならないということであり、通常はJavaでこれを考慮すべきである。 
もちろん構成要素の可視性はアクセス修飾子で決定ができるため、以下の例題に示す通り、サブクラスの構成要素がスーパークラス内の局地的な構成要素と同じ名称をもつことは可能である:

\begin{small}
\begin{verbatim}
class B
{
  private int b() { return 0 };
}
class A extends B
{ 
  b: int:=0;
}
\end{verbatim}
\end{small}

\subsubsection{クラス要素のスコープ}

In Java, the fact that the default modifier is package means that
subclasses can reference declarations from superclasses if no explicit
modifiers are included as in the following example where
\texttt{super.i} references the declaration of i in class B: 
Javaにおいて既定修飾子がパッケージになっているということは、もし明示的な修飾子が含まれないならば、サブクラスがスーパークラスから宣言参照が可能であることを意味するが、以下の例題では\texttt{super.i} がクラスBにおけるｉの宣言を参照している: 

\begin{small}
\begin{verbatim}
class B
{
  int i=1;
}

class A extends B {
  int j=0;

  void a() { j = super.i; }
}
\end{verbatim}
\end{small}

In VDM++, however, declarations are by default assumed to be private,
so that the direct analogue of the above in VDM++:
しかしながらVDM++の宣言は既定で局所的であると仮定されるため、上記をVDM++に直接置き換えると以下のようになる:

\begin{small}
\begin{verbatim}
class B
instance variables 
  i : int  := 1;
  
end  B

class A is subclass of B
instance variables 
  j : int:=0;

operations

a: () ==> ()
a() == 
  j:= B`i;  -- Error: Access violation for "B`i"
  j:= B`i;  -- Error: "B`i" に対するアクセス違反

end  A
\end{verbatim}
\end{small}

would yield a compile-time error stating that the instance variable B`i is
not in scope in class A. This can be fixed easily by adding a
protected or public modifier to the declaration of i in class B and
the translator currently issues a warning and asks the user to specify
these access modifiers explicitly\footnote{The translation could be
  modified to automatically generate public or protected modifiers by
  default in such situations.}.
結果は、インスタンス変数B`i がクラスＡのスコープ内にないという、コンパイルエラーを引き起こすことになるだろう。
クラスＢにおけるiの宣言では、protected修飾子 または public 修飾子を加えることにより簡単に手直しができて、翻訳では現在は警告が発せられてユーザーに明示的にこれらアクセス修飾子を指定するように求めてくる\footnote{このような状況において、自動的にpublicまたはprotectedの修飾子を生成するように、既定で翻訳修飾できるだろう。}。

\subsubsection{サブクラスのインスタンス変数へのアクセス}

In Java selection of class attributes is determined at compile time,
whereas it is determined at run-time in VDM++. This means that there
is a slight difference in semantics between Java sources and
translated VDM++ descriptions in a few cases. This can be an issue when
class attributes are redefined by a subclass and instances of both the
superclass and the subclass are intermixed as in the following
example in which an instance of the subclass is assigned to a variable
representing the superclass:
クラス属性の選択はJavaではコンパイル時に決定されるが、VDM++では実行時に決定される。
これは、Javaソースと翻訳された VDM++記述との間に多少は意味上の違いが生じている場合があることを意味している。
これは、クラス属性があるサブクラスによって再定義されスーパークラスとサブクラスの両インスタンスが混じる場合や、下記の例題のようにサブクラスのインスタンスがスーパークラスを表す変数に代入された場合に、問題となる可能性がある:

\begin{small}
\begin{verbatim}
class S {int i=0;}
class T extends S {int i=1;}
class A {
  void a() {
    T t=new T();
    JavaLangSystem.out.println(t.i);  
    S s=new S();
    JavaLangSystem.out.println(s.i);  
    s=t;
    JavaLangSystem.out.println(s.i);  
  }
}
\end{verbatim}
\end{small}

The result of evaluating the above will be that the sequence of
numbers 1, 0, 0 will be printed out. Note that the the scope rules of
Java cause the last number to be 0 since the value of s is fixed at
compile time.
上記を評価した結果は、数列 1、0、0 が印刷出力されてくるはずである。
Java のスコープ規則で、 s の値はコンパイル時に固定されるために０となることには、注意しよう。

Compare this with the following VDM++ specification of the ``same''
example: 
``同じ''例題で、以下の VDM++ 仕様と比べてみよう: 

\begin{small}
\begin{verbatim}
class S
instance variables
  public i:int:=0
end  S

class T is subclass of S
instance variables
  public i:int:=1
end  T

class A
operations
public Test: () ==> seq of int
Test() == (
  dcl t:T:=new T(),
      s:S:=new S(),
      res: seq of int:=[];
      res:=res^[t.i];
      res:=res^[s.i];
      s:=t;
      res:=res^[s.i];
  return res
)

end A
\end{verbatim}
\end{small}

Here the result of calling the Test operation is a sequence of 1, 0, 1
because in VDM++ the third value is determined at run-time rather
than at compile time as done in Java. Care should therefore be taken
to avoid such situations in the Java code\footnote{A future version
  of the type checker (applied statically to the Java source code)
  will detect this kind of problem and produce a warning, but this is 
not yet implemented.}.
ここでは Test 操作を呼び出した結果は 1, 0, 1　という数列になるが、Javaでコンパイル時に決定された３番目の値がVDM++ では実行時に決定されるからである。 
したがって このような状況を避けるための処置は、Java コードにおいてとられるべきである\footnote{型検査 (Java ソースコードに静的に適用されているもの)の将来版では、この種の問題を発見し警告を発することになるだろうが、これはまだ実装されていない。}。


\subsection{副次的作用をもつ文における制限事項}

In Java expressions can have side effects. For example, the expression
\texttt{i++} returns the value of \texttt{i} and as a side-effect also
increments \texttt{i} by 1. Such an expression therefore effectively
corresponds to a sequence of VDM++ statements. However, the syntax of
VDM++ does not allow sequences of statements to occur at arbitrary
positions within a specification, which imposes certain constraints on
the Java to VDM++ translator. We present these below.
Javaにおいて、式は副次的作用をもつことが可能である。
例えば、式\texttt{i++} は \texttt{i}の値を返すと共に、副次的作用として \texttt{i} を 1増加させる。 
したがってこのような式は、実際には VDM++ 文の連続に相当するものとなる。
しかしながらVDM++ の構文では、文の連続が仕様中の任意の位置に現れることが許されてはいないため、Java から VDM++ への翻訳には確実に制限が与えられていることになる。
以下にこれらを提示する。

\subsubsection{クラスあるいはインスタンス変数の初期化}

In Java it is possible to use expressions which have side effects on
the right-hand side of initialisation expressions in a class
declaration as in the following example:
Javaでは下記の例題にあるように、クラス宣言中の初期化式の右辺で、副次的作用をもつ式を用いることができる:

\begin{small}
\begin{verbatim}
class A {
int i=1;
int j=i++;
static int k=1;
static int l=k++;
}
\end{verbatim}
\end{small}

In the translator, however, we require that only expressions without
side effects can be used in initialisation expressions\footnote{In
  some special cases, including this example in fact, it would
  actually be possible to make a translation so it may be possible to
  relax this restriction in the future.}.
しかしながら翻訳中の初期化式においては、副次的作用をもたない式だけ利用できることを要求したい\footnote{実際はこの例題を含めて、何らかの特別な場合には翻訳を行うことが可能で、将来的にはこの制限が緩められる可能性はある。}。

\subsubsection{代入文の左辺における条件式}

In Java it is possible to use a conditional expression on the
left-hand side of an assignment statement and this is supported by the
Java to VDM++ translator. However, in Java the alternatives in the
conditional statement can involve expressions with side effects as in
the following example:
Javaでは代入文の左辺に条件式を用いることが可能で、Java から VDM++ への翻訳でもこれがサポートされている。
しかしJavaでは以下の例題にあるように、条件文の選択肢で副次的作用をもつ式を含めることができる:

\begin{small}
\begin{verbatim}
(i==0 ? a[i++] : b)[0] = ...
\end{verbatim}
\end{small}

These are not supported by the translator, which requires that it must
be possible to translate the alternatives to VDM++ expressions not
sequences of VDM++ statements\footnote{Again in some special cases it
  would be possible to make a translation so it may be possible to
  relax this restriction in the future.}.
これらは翻訳でサポートされていないため、 VDM++文の連続には、 VDM++式に対しては選択肢の翻訳が可能でなければならないことを要求している\footnote{繰り返すが、特別な場合においては翻訳も可能となるかもしれず、将来的にこの制限を緩めることができる可能性がある。}。

\subsubsection{JavaLangObject 要素アクセス}

JavaLangObject member access expressions which involve expressions with side
effects, for example:
副次的作用をもつ式を含むJavaLangObject 要素アクセス式は、例えば次の通りとなる:

\begin{small}
\begin{verbatim}
... a[i++].b[i++] ...
\end{verbatim}
\end{small}

also cannot in general be translated to VDM++ and are not currently
accepted by the translator in any form\footnote{Again simple forms
  could be translated so this restriction could possibly be relaxed in
  the future.}.
これらもまた一般的には VDM++ に翻訳されるのは不可能であり、現時点ではどのような形式の翻訳においても受け入れられていない\footnote{繰り返すが将来的には、簡単な形式のものは翻訳できるようになるであろうし、制限が緩和される可能性もあるだろう。}。

\subsection{言語構成の相違点}

In a number of areas the syntactic and semantic differences
between Java and VDM++ cause problems with translation. We discuss
these areas below.
多くの領域において、JavaとVDM++の間の構文的かつ意味上の相違が、翻訳において問題を引き起こす。
以下にこれらの領域を論じる。

\subsubsection{Java と \ VDM++ のキーワード}

Some of the keywords in VDM++ are not keywords in Java (e.g.\ len,
value, is\_bool) which means they can be used as the names of classes,
instance variables, functions, etc.\ in Java. These should be renamed
before translation.
VDM++ のキーワードのいくつかは、 Javaのキーワードでない(例えば　\ len、値、 is\_bool)、つまりJavaではそれらをクラス、インスタンス変数、関数、等の名称に用いることができることを意味している。 
これらは翻訳前に、名称替えがなされるべきである。

\subsubsection{関数パラメータへの代入}

In Java, it is possible to assign a value to a parameter of a function
within the body of the same function, as, for example, in:
Javaにおいては、ある関数のパラメータへ値を代入することが、同じ関数の本体内において可能であり、例えば次にある通りである:

\begin{small}
\begin{verbatim}
int f(int i) { ...; i=1; ...; }
\end{verbatim}
\end{small}

In VDM++, this is not possible so functions which include such
assignments cannot be translated. 
VDM++ではこれは不可能で、このような代入が含まれる関数の翻訳はできない。

\subsubsection{新インスタンスへの代入の式としての利用}

In Java the assignment statement
Java において、次の代入文では

\begin{small}
\begin{verbatim}
a1 = new A();
\end{verbatim}
\end{small}

returns the value a1 which represents a new object of class A and this
assignment statement can therefore be used to interact directly with
that object as in the following example:
クラスAの新しいオブジェクトを表す値 a1 を返しているので、以下の例題のように、この代入文を用いてオブジェクトと直接的に相互作用を行うことが可能だ:

\begin{small}
\begin{verbatim}
(a1 = new A()).i = 1;
\end{verbatim}
\end{small}

% class A {public int i; public A a() {... return ...}}

In VDM++ this notation is not allowed (because the assignment does not
return a1 as a result so the field reference .i is not being applied
to an object). Expressions of this form therefore cannot be
translated. They should instead be written as a sequence of statements
in which the assignment is factored out, as in:
VDM++でこの表記法は許されていない (代入結果は a1 を返さないので、項目参照の .i がオブジェクトに適用されないからだ)。
したがってこの形式の翻訳は不可能である。
その代わりに次のように、代入文に分解される連続文として、書かれるべきである:

\begin{small}
\begin{verbatim}
a1 = new A();
a1.i = 1;
\end{verbatim}
\end{small}


\subsubsection{数値型}

In Java, the numeric types `int', `long' and `real' are considered as
being distinguishable, so that, for example, with the following
definitions 
Javaでは、数値型 `int'、 `long'、 `real' が区別可能と考えられて、例えば以下のような定義で

\begin{small}
\begin{verbatim}
class A
operations

public class A 
{
  int o(int i) {return 0;}
  int o(long i) {return 1;}
  int o(real i) {return 2;}
}
\end{verbatim}
\end{small}

the evaluation of the expression o(j) will yield 0 if j is of type
`int', 1 if j is of type `long', and 2 if j is of type `real'. In
VDM++, however, there is no type `long' (it is effectively equivalent
to `int') and the type `int' is a subtype of the type `real' so that
if j is of type `int' it is also of type `real'. In translating the
above example, therefore, the second function would override the first 
(because both `int' and `long' translate to `int') and would also
cause a conflict with the third when applied to integer arguments
(because the fact that `int' is a subtype of `real' means that the
third function can be applied to values of type `int' as well as
values of type `real'). Overloading functions in Java in such a way
that distinguishing between them relies on the distinctions between
numeric types should therefore be avoided.
式 o(j) の評価では、もし j が`int'型ならば 0、`long'型ならば 1、`real'型ならば 2、となる。 
しかしながら、VDM++で `long'型はなく (事実上 `int'型と等しい) しかも `int'型は `real'型のサブタイプであるために、もし j が `int'型ならば `real'型でもある。 
したがって上記例題を翻訳する場合に、２番目の関数は１番目の関数を上書きすることになるだろうし(`int' と `long' は両方 `int'に翻訳されるから)、 整数引数の場合はこれは３番目の関数と矛盾することになる(`int'は `real'のサブタイプであるということは、３番目の関数は `real'型の値と同様 `int'型の値にも適用できるということを意味するからだ)。
したがって、関数間の違いの認識を数値型間の相違に依存しているこのようなやり方でJava関数を上書きするのは、避けるべきである。

\subsubsection{型変換}

In Java, the type definition associated with a particular value can
cause a calculated value to change in order to conform to the declared
type, whereas in VDM++ such an inconsistency between the actual type
and the declared type would give rise to an error. For example, in the 
following Java code
Javaにおいて特定の値に関連する型定義は、宣言された型に一致させるために計算された値の変化を引き起こす可能性があって、一方 VDM++ ではこのような実際の型と宣言された型との間の不一致がエラーを引き起こすことになる。
たとえば以下の Javaコードにおいて

\begin{small}
\begin{verbatim}
int j = 5;
int i = j/2;
\end{verbatim}
\end{small}

the value of i becomes 2 and not 2.5 because i is declared to be an
integer. 
 i の値は 2.5でなく 2となるが、これは i が整数であると宣言されているからだ。 

In a similar way, Java also does explicit conversion of the actual
parameters of methods. For example, an operation `op' which is defined
to take a string as an argument can be called with a character `A' as
that parameter: the character `A' is in fact converted to the string
``A''. 
同様の方法で、Java はメソッドにおける実際のパラメーターの明白な変換もまた行う。
例えば、引数に文字列をとるように定義された操作 `op' を、パラメーターとしての文字 `A' と共に呼び出すことが可能で: この時文字 `A' は実際には文字列``A''に変換される。 
\begin{small}
\begin{verbatim}
... op(JavaLangString str) {...}
...

op('A')
\end{verbatim}
\end{small}

\TjTov\ translates the Java code precisely as written and does not
simulate such implicit type conversions, which means that the
specification generated would contain type errors (in the first
example a run-time type error would arise when trying to assign a real
value to an integer variable, whereas the second example would give a
static type error because a string should be a sequence of characters
and not just a single character). Implicit type conversions should
therefore not be used in the Java code.
\TjTov\ はJavaコードを書かれている通りに詳細に翻訳し、このような暗黙の型変換を模倣しない、つまり生成された仕様には型エラーが含まれることを意味している (最初の例題では、実数値を整数変数に代入しようとする場合に実行時に型エラーが生じ、一方２番目の例題では、文字列は単なる１文字でなく複数文字の列であるべきなので静的な型エラーを起こす)。 
したがってJava コードでは、 暗黙の型変換を用いるべきでない。

\subsubsection{内部クラス}

In Java it is possible to nest class definitions using inner classes
as in the following example: 
以下の例題にあるように、Java では内部クラスを用いてクラス定義を行うことができる:
\begin{small}
\begin{verbatim}
class WithDeepNesting{
 boolean toBe;
 WithDeepNesting(boolean b) { toBe = b;}
 class Nested {
  boolean theQuestion;
  class DeeplyNested {
   DeeplyNested(){
    Nested.this.theQuestion
          = WithDeepNesting.this.toBe || !WithDeepNesting.this.toBe; }}}}
\end{verbatim}
\end{small}

This example also includes examples of the use of the qualified
\texttt{this}, which allows an inner class to reference definitions
belonging to one of its containing classes -- the keyword
\texttt{this} is prefixed with the name of the appropriate containing
class. 
この例題には、修飾された\texttt{this}を用いる例も含まれ、それを含むクラスの１つに属する定義を参照する内部クラスを許す -- キーワード\texttt{this} はクラスを含む適切な名称で前修飾される。

VDM++ does not support inner classes, nor the qualified \texttt{this},
so neither of these is supported by the Java to VDM++
translator\footnote{It might be possible to support these
  at some stage in the future, for instance by converting the inner
  classes to normal classes and automatically renaming them and
  their attributes where appropriate, but this requires further
  investigation.}.
VDM++ は内部クラスをサポートしないし、修飾された \texttt{this}もサポートされないため、これらどちらも Java から VDM++の翻訳ではサポートされていない\footnote{将来的にある段階で、これらをサポートすることは可能かもしれない、たとえば内部クラスを通常クラスに変換すること、そして適切な場所で自動的にそれらとそれらの属性の名称を変更すること、ただしこれは更なる検討が必要である。}。


\subsubsection{修飾された \texttt{this}の暗黙使用}

The \texttt{this} keyword can also be used implicitly. Semantically
the use of a class name in a field access expression is equivalent to
an implicit use of the \texttt{this} construct. For example an
expression of the form \texttt{ClassName.super.Identifier}
semantically means \texttt{((NameOfSuperClass)ClassName.this).Identifier}. This
implicit use of \texttt{this} is not supported by the
Java to VDM++ translator.
\texttt{this} キーワードを暗黙に用いることも可能だ。
意味上では、項目アクセス式においてクラス名称を使用することは、 \texttt{this} 構成の暗黙使用と同じである。
たとえば \texttt{ClassName.super.Identifier}という形の式は、意味的には \texttt{((NameOfSuperClass)ClassName.this).Identifier}を示している。
 \texttt{this}のこのような暗黙の使用は、Java から VDM++ の翻訳ではサポートされない。

\subsubsection{匿名クラス}

Anonymous classes in Java have no counterpart in VDM++ and are not
supported by the Java to VDM++ translator\footnote{It would be fairly
  easy to support these if inner classes can be supported: the translator
  could simply allocate an arbitrary name to the anonymous class and
  then treat it in the same way as an inner class.}. 
 Java における匿名クラスは、 VDM++ において相当するものはない\footnote{もし内部クラスがサポートされているならば、これらを適正にサポートすることは簡単であろう: 翻訳では単に匿名クラスに任意の名称を割り当てて、内部クラスと同じ方法で扱うことができるであろう。}。

\subsubsection{\texttt{label}、 \texttt{break}、 \texttt{continue}}

Using \texttt{label:}, \texttt{break label}, \texttt{continue
  label} and \texttt{continue} in Java effectively corresponds to
  using GOTO's -- the flow of control is interrupted and transferred
  to another point. This is not supported in VDM++ so these constructs
  cannot be translated.
Javaにおいて \texttt{label:}、 \texttt{break label}、 \texttt{continue label}、 \texttt{continue} を用いることは事実上、GOTOを用いるのに相当する -- コントロールの流れは妨げられもうひとつの地点に移される。
これは VDM++ ではサポートされないため、このような構築を翻訳することはできない。

The use of \texttt{break} alone (i.e.\ with no label) to leave a loop
is supported, however, though this is done using exception handling
which means that the VDM++ generated looks quite different from the
Java source code. We therefore recommend that \texttt{break} should
not be used to exit from loops.
しかし、ループを抜けるための \texttt{break} のみの使用 (つまり\ ラベルは不使用) はサポートされている、とはいえそれは例外操作を用いることによってで、つまり生成された VDM++ はJava ソースコードとはまったく異なる様相をとることを意味する。したがって、ループから抜けるために \texttt{break} を用いるべきではないことを提言する。

\subsubsection{選択肢分岐のない\texttt{switch}}

In Java it is not necessary to put \texttt{break} between alternatives
in a \texttt{switch} statement, so that the following is valid:
 Javaでは必ずしも \texttt{switch} 文の選択肢間に \texttt{break} をおく必要はないので、次が有効である:

\begin{small}
\begin{verbatim}
  oneOrTwo=0;
  switch(i) {
    case 1:
      secondAlternative=false;
    case 2:
      secondAlternative=true;
    break;
  }
\end{verbatim}
\end{small}

However, if \texttt{switch(1)} is evaluated \texttt{secondAlternative} will have
the value true -- since
there is no break between the cases the execution will continue to the
final \texttt{break}. This means that both \texttt{switch(1)} and \texttt{switch(2)}
have the same effect with respect to \texttt{secondAlternative}, namely
\texttt{secondAlternative=true} and, so the line
\texttt{secondAlternative=false} is entirely redundant and
we could achieve the same effect
as the above by writing the following instead:
しかしながら、\texttt{switch(1)} が評価された場合には \texttt{secondAlternative} は trueの値をもつことになる -- 各ケース間には分岐がないため、実行は最後の \texttt{break}に続いていくことになる。
これは \texttt{switch(1)} と \texttt{switch(2)}の両方が \texttt{secondAlternative}に関して同じ効果、すなわち\texttt{secondAlternative=true} となることを意味していて、したがって行\texttt{secondAlternative=false} はまったく不必要であり、以下のように書くことで上記と同じ効果が達成できる:

\begin{small}
\begin{verbatim}
  oneOrTwo=0;

  switch(i) {
    case 1:
    case 2:
      secondAlternative=true;
    break;
  }
\end{verbatim}
\end{small}

In the translator we insist that this second form is used and we
reject switch statements in which there is some code between the case
alternatives but no \texttt{break} at the end of that code. Switch
statements in which the alternatives are separated by breaks are fully
supported, however, so that, for example, the following is allowed:
翻訳においてはこの第２の形が用いられることを強調して、 ケース選択肢間で書かれたコードの最後に \texttt{break}がないものは認めない。 
選択肢が分岐で分断されているSwitch文は完全にサポートされていて、例えばそのために、以下が許される:

\begin{small}
\begin{verbatim}
  one=0;
  two=0;

  switch(i) {
    case 1:
      one=1;
    break;
    case 2:
      two=1;
    break;
  }
\end{verbatim}
\end{small}


\subsection{サポートされていない概念}

In this subsection we present a few concepts where Java and VDM++ are
compatible but which have not yet been incorporated into the Java to
VDM++ translator. 
この節では、 Java と VDM++ での互換性のある概念だが、Java からVDM++ の翻訳でまだ組み入れられていないものを、いくつか述べる。

\subsubsection{同時並行性}

The concurrency concepts in Java with the wait and notify mechanisms
are similar to the notions for concurrency found in VDM++. However,
currently the Java to VDM++ translator does not provide support
for any of the concurrency features of Java including the
synchronized statement.
wait や notify機構をもったJavaの同時並行性の概念は、 VDM++で見られる同時並行性に対する観念と似ている。
しかし現時点でのJava から VDM++ 翻訳では、同期文を含むJava同時実行性に対するサポートは、全く提供されていない。

\subsubsection{Unicode 文字}

In Java it is possible to write arbitrary Unicode identifiers. This is
not yet supported by the Java parser built into \VDMTools.
 Javaでは任意の Unicode 識別子を書くことが可能である。
 \VDMTools に組み入れられた Java 構文解析ツールでは、これはまだサポートされていない。

\newpage
\section{\JAVA\ から \vdmslpp\ 翻訳の詳細}\label{sec:translation}

This section explains how individual elements of a \JAVA\ program are
translated to \vdmslpp.
この節では、\JAVA\ プログラムの個々の要素がどのように \vdmslpp に翻訳されていくかを説明する。

\subsection{組込型}\label{types}

The various kinds of integers in Java are all translated to the type
`int' in VDM++, and the various kinds of real numbers are all
translated to the type `real'. Characters and booleans are translated
to the types `char' and `bool' respectively. These transformations are
summarised in the table in Figure‾\ref{fig:typexfs}.
Javaにおけるさまざまな種類の整数はすべて、VDM++では`int' 型に翻訳され、実数はすべて `real'型に翻訳される。
文字型とブール型はそれぞれ`char'型と `bool'型に翻訳される。
これらの変換は 図‾\ref{fig:typexfs}の表でまとめている。

\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|l|}
\hline
  \JAVA\   & \VDM\ \\ \hline \hline
  byte   & int \\ \hline
  short  & int \\ \hline
  int    & int \\ \hline
  long   & int \\ \hline
  float  & real \\ \hline
  double & real \\ \hline
  char  & char \\ \hline
  boolean  & bool \\ \hline
\end{longtable}    
    \caption{組込型変換}
    \label{fig:typexfs}
  \end{center}
\end{figure}

\subsection{リテラル}\label{literals}

Literal values belonging to the boolean, character and numeric types
all have exact counterparts in VDM++ so are translated
verbatim. JavaLangString literals are translated to equivalent values
belonging to the VDM++ class JavaLangString since the JavaLangString class in
Java belongs to the API‾(see Section‾\ref{names}). Some
examples of the translation of literals are given in
the table in Figure‾\ref{fig:litxfs}.  
ブール型、文字型、数値型に属するリテラル値はすべて、 一語一語文字通りにVDM++に翻訳される。
JavaLangString リテラルは、 VDM++ クラスである JavaLangStringに属する等価に翻訳されるが、Javaの JavaLangString クラスは API‾(第‾\ref{names}章参照)に属するからである。
リテラル変換のいくつかの例題は 図‾\ref{fig:litxfs}の表に挙げてある。

\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|l|l|}
\hline
Type &  \JAVA\   & \VDM\ \\ \hline \hline
  boolean   & true, false  & true, false   \\ \hline
  char      & 'A', 'B', ...    & 'A', 'B', ...  \\ \hline
  long/int/short/byte  & 255, -12, ...  & 255, -12, ...    \\ \hline
  float/double  & 1.1, 1e-5, ...  & 1.1, 1e-5, ...  \\ \hline
  JavaLangString    & "abc..."  & new JavaLangString("abc...") \\ \hline
\end{longtable}    
    \caption{Transformations of Literals}
    \label{fig:litxfs}
  \end{center}
\end{figure}

\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|l|l|}
\hline
型 &  \JAVA\   & \VDM\ \\ \hline \hline
  boolean   & true, false  & true, false   \\ \hline
  char      & 'A', 'B', ...    & 'A', 'B', ...  \\ \hline
  long/int/short/byte  & 255, -12, ...  & 255, -12, ...    \\ \hline
  float/double  & 1.1, 1e-5, ...  & 1.1, 1e-5, ...  \\ \hline
  JavaLangString    & "abc..."  & new JavaLangString("abc...") \\ \hline
\end{longtable}    
    \caption{リテラル変換}
    \label{fig:litxfs}
  \end{center}
\end{figure}



\subsection{名称}\label{names}

Names in \JAVA\ are translated to the same names in \vdmslpp\ with the
following two exceptions:
\JAVA\ の名称は、以下の例外を除いて、 \vdmslpp\ においても同じ名称に翻訳される:

\begin{enumerate}
\item where the name coincides with a \VDM\ keyword two underscores
  are appended to the name in \VDM. Thus, for example, a Java method
  named `bool' would become a method named `bool\_\_' in VDM++. 
\item where the name represents a class which is part of the \JAVA\
  API, the VDM++ name is prefixed by the (Java) package name in which
  the class is defined. Thus, for example, the Java class JavaLangObject
  becomes the class JavaLangObject in VDM++. 
\end{enumerate}
\begin{enumerate}
\item 名称が \VDM\ キーワードと一致する場合には、\VDM での名称に２つのアンダーバーを付け加える。このことからたとえば、Java メソッド `bool' ならば VDM++でのメソッド名称が `bool\_\_' となる。
\item 名称が \JAVA\ APIの一部となるクラスを表す場合には、VDM++ での名称にクラス定義がなされた (Java)パッケージ名称を前に付け加える。このことからたとえば、Java クラスJavaLangObject は VDM++ でのJavaLangObjectクラスとなる。
\end{enumerate}

The reason for the second property is that when we translate a Java
class to VDM++ we add some extra functionality, for instance to
simulate the \texttt{null} value (see Section‾\ref{null}). If we then
want to translate our VDM++ back to Java we must generate Java code
which corresponds to this added functionality because it is not
included in the Java API classes, and this would give us two Java
classes with the same name, the one already in the Java API and the
one generated by translating the extended version of this from VDM++
back to Java.  
２番目の特性が必要な理由は、Javaクラスから VDM++へ翻訳を行う場合、たとえば \texttt{null} 値 (第‾\ref{null}章を参照)をシミュレートするといったいくつか余分な機能追加を行うからだ。
このときに VDM++コードを Javaに逆翻訳しようとすると、この追加機能がJava APIクラスに含まれないので、相当する Javaコード生成が必要となり、 したがって同じ名称の２つの Javaクラス、１つはJava APIにあるもの、もう１つは VDM++からJavaへの逆拡張版の翻訳で生成されるもの、を持つこととなる。

\subsection{配列}\label{arrays}

An array in Java is translated to a map in VDM++, and accessing and
modifying values in an array are written in terms of map application
and map override. Some examples illustrating this are given in
the table in Figure‾\ref{fig:arrayxfs}. 
Javaの配列は VDM++では写像に翻訳され、配列中の値へのアクセスや修正は、写像アプリケーションや写像上書きに関することとして記載される。
これを描く例題いくつかが、 図‾\ref{fig:arrayxfs}の表で与えられている。
\newpage
\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|l|}
\hline
  \JAVA\   & \VDM\ \\ \hline \hline
  \texttt{Type a[]}   & \texttt{map int to Type} \\ \hline
  \texttt{... = a[0]}   & \texttt{... := a(0)} \\ \hline
  \texttt{a[0]=...}   & \texttt{a:=a++\{0|->...\}} \\ \hline
\end{longtable}    
    \caption{配列変換}
    \label{fig:arrayxfs}
  \end{center}
\end{figure}

Note that an array can be used as an instance of
\texttt{java.lang.JavaLangObject} in Java but if this is done the
VDM++ generated by the translator will contain a type error due to
mismatching of types. Arrays should therefore not be used in this way
in Java. 
配列はJavaでは\texttt{java.lang.JavaLangObject} のインスタンスとして用いることができるが、この場合は、翻訳で生成されるVDM++ に型不一致が原因の型エラーが含まれてしまうことに注意しよう。
したがって、Javaで配列のこのような用い方はすべきではない。

\subsection{クラス}\label{class}

A \JAVA\ class is translated to a \VDM\ class of the same name, and
the various elements of the class are translated as explained in the
following subsections.
 \JAVA\ クラスは同名の \VDM\ クラスに翻訳され、クラスの各要素は以下の節に示すように翻訳される。

\subsubsection{メソッドと要素}\label{methods}

Methods become operations while members become instance variables,
with static methods and members becoming static operations and 
instance variables. Methods whose result type is \texttt{void}
become operations with no result in VDM++. This is illustrated in
the following example:  
メソッドが操作となる一方で要素はインスタンス変数となるが、それに伴って静的なメソッドと要素が静的な操作とインスタンス変数になる。
結果型が \texttt{void}であるメソッドは、 VDM++では戻り値のない操作となる。
これは以下の例題で表わされている:  

\begin{small}
\begin{verbatim}
class A                            class A is subclass of JavaLangObject
{                                  instance variables
  int i = 0;                         i: int := 0;
  static int s = 1;                  static s : int := 1;
                                   operations
  int method(int)                    method : int ==> int
    { return i; }                      ( return i );
  static int smethod(int)            static smethod : int ==> int
    { return i; }                      ( return i );
  void op()                          op : () ==> ()
    {...}                              (  ...  );
  static int op1 (int j)             static op1 : int ==> int
    {...}                              (  ...  );
}                                    end A
\end{verbatim}
\end{small}

Note that in \JAVA\ a variable which is not explicitly initialised has
a value by default whereas in \VDM\ it is undefined. This can lead to
run-time errors in VDM++ so care should be taken to ensure that
instance variables in Java are initialised correctly where appropriate.
 \JAVA\ では明白な初期化がなされなかった変数は既定による値を１つもつが、一方で\VDM\ ではこれが未定義となる。
これは VDM++ において実行エラーを導く可能性があり、 Javaにおけるインスタンス変数は適切な箇所での確実な初期化を保証するように処理されるべきである。


\subsubsection{継承}\label{inheritance}

In \JAVA{}, a class can inherit from other classes by extension or by
implementation. VDM++ only supports a single form of inheritance,
however, namely subclassing. Both forms of inheritance in Java are 
therefore translated to subclassing in VDM++. Thus, for example, the
inheritance clause \texttt{class A extends B implements C,D} becomes
\texttt{class A is subclass of B, C, D} in VDM++.
 \JAVA\ では、１つのクラスは機能拡張あるいは実装によって他のクラスから継承を行うことが可能だ。
VDM++ では継承の単純な形式、サブクラス化と名づけているが、これをサポートしているだけである。
したがってJava における継承の両形式は、VDM++ではサブクラス化へと翻訳される。
このようにたとえば、 VDM++における継承節 \texttt{class A extends B implements C,D} は VDM++において\texttt{class A is subclass of B, C, D} となる。

Java classes which have no explicit inheritance clause are assumed to
inherit implicitly from java.lang.JavaLangObject. The translator makes this
dependency explicit, so that in \VDM\ such a class explicitly inherits
from JavaLangObject, the VDM++ counterpart of
\texttt{java.lang.JavaLangObject}. The example in Section‾\ref{methods}
illustrates this.
明白な継承節をもたないJava 節は、暗黙に java.lang.JavaLangObjectから継承すると仮定される。
翻訳ではこの依存性を明白にして、そのために \VDM\ ではこのようなクラスは明白に \texttt{java.lang.JavaLangObject}のVDM++ の対応部分である JavaLangObjectから継承を行う。
第‾\ref{methods}章の例題がこれを描写している。

Note that the fact that both extension and implementation in Java are
translated to subclasses in VDM++ can cause a problem if the VDM++ is
translated naively back to Java since VDM++ subclasses are by default
translated to extension in Java. The manual for the VDM++ to Java Coce
Generator‾\cite{CGJavaManPP-CSK} explains how to avoid this problem. 
Javaの機能拡張と実装の両方が VDM++ でのサブクラスに翻訳されるという実際からは、もし VDM++ が単純にJavaへ逆翻訳されたならば、 VDM++ のサブクラスは既定としてJavaの機能拡張に翻訳されるために、問題を起こす可能性があることに注意しよう。
 VDM++ から Java のコード生成‾\cite{CGJavaManPP-CSK} で、この問題をどのように避けるか説明している。 

\subsubsection{クラス修飾子}

Modifiers of a \JAVA\ class (e.g.\ abstract, final) have no
counterpart in VDM++ and are all ignored by the translator. 
 \JAVA\ クラスの修飾子 (例えば\ abstract, final) は VDM++では同等のものがないため、翻訳ですべてが無視される。

\subsubsection{アクセス修飾子}

Access modifiers are translated directly from Java to VDM++ as shown
in the table in Figure‾\ref{fig:accessxfs}. Note, however, that in Java the absence
of a modifier indicates that the construct can be accessed by any
class in the same package, whereas in VDM++ a construct with no access
modifier is assumed to be private. Omitting access modifiers in Java
can thus give rise to access violation errors when type checking the
translated VDM++. 
アクセス修飾子は 図‾\ref{fig:accessxfs}の表で示すように、Java から VDM++ へそのまま翻訳される。
しかしJavaで修飾子がない場合に、構造体は同じパッケージ内の任意のクラスからアクセス可能で、一方でVDM++ ではアクセス修飾子をもたない構造体は非公開であると仮定される。
Javaでアクセス修飾子を省くと、翻訳された VDM++を型検査するときにアクセス違反エラーを引き起こす可能性が生じる。

\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|l|}
\hline
  \JAVA\   & \VDM\ \\ \hline \hline
  no modifier         & no modifier        \\ \hline
  \texttt{public}     & \texttt{public}    \\ \hline
  \texttt{protected}  & \texttt{protected} \\ \hline
  \texttt{private}  & \texttt{private} \\ \hline
\end{longtable}    
    \caption{Transformations of Access Modifiers}
    \label{fig:accessxfs}
  \end{center}
\end{figure}
\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|l|}
\hline
  \JAVA\   & \VDM\ \\ \hline \hline
  修飾子なし         & 修飾子なし        \\ \hline
  \texttt{public}     & \texttt{public}    \\ \hline
  \texttt{protected}  & \texttt{protected} \\ \hline
  \texttt{private}  & \texttt{private} \\ \hline
\end{longtable}    
    \caption{アクセス修飾子変換}
    \label{fig:accessxfs}
  \end{center}
\end{figure}


\subsubsection{静的初期化子}

Static initialisers are supported by the translator although they have
no direct counterpart in VDM++. To implement these, the Java code for
all static initialisers in a class is collected together and
translated into the body of a static operation called
\texttt{j2v\_staticInitializer}. This operation takes no inputs and
its result is the special VDM++ quote value \texttt{<VOID>}. In
addition, a static instance variable called \texttt{dummy} is added to
the VDM++ class, the type of which is this same quote value
\texttt{<VOID>}, and the operation \texttt{j2v\_staticInitializer} is
defined as the initialisation of this variable. Thus, when the VDM++
class is initialised, the operation \texttt{j2v\_staticInitializer} is
invoked and simulates the effects of the original static initialisers
in the Java class. 
静的初期化子は、 VDM++には直接対応するものがないが、翻訳においてサポートされている。
これらを実装するために、クラス内のすべての静的初期化子に対する Java コードは集められ一緒に翻訳されて、\texttt{j2v\_staticInitializer}と呼ぶ静的操作の本体をつくる。 
この操作で入力値はとらず、結果は特殊 VDM++ 引用句である \texttt{<VOID>}である。 それに加えて、型がこの同じ引用句\texttt{<VOID>}である \texttt{dummy}という静的インスタンス変数が VDM++ クラスに加えられ、操作 \texttt{j2v\_staticInitializer} がこの変数の初期設定として定義される。
このようにVDM++クラスが初期化されると、操作 \texttt{j2v\_staticInitializer} は起動され、Javaクラスのもともとの静的初期化子の結果はシミュレートされる。

The following example illustrates this.
以下の例題がこれを示す。

\begin{small}
\begin{verbatim}
                      instance variables
static int i=1;         static i : int  := 1;
static int j=2;         static j : int  := 2;
static int k=3;         static k : int  := 3;

static {
  i=k+j;
}

int l;                  l : int ;
                        
static {                static dummy : <VOID> := j2v_staticInitializer()
  j=i+k;              
}                     operations
                        static j2v_staticInitializer : () ==> <VOID>
                          j2v_staticInitializer() ==
                          ( i := k+j;
                            ( j := i+k
                            ) ;
                            return  <VOID>
                          ) ;
\end{verbatim}
\end{small}



\subsubsection{クラスについての情報取得}\label{getclass}

In \JAVA\ every class inherits from \texttt{java.lang.JavaLangObject}.
This includes the method \texttt{getClass} which returns an instance
of \texttt{java.lang.Class}, and this in turn provides functionality
for obtaining various information about the class, e.g.\ the class
name, whether the class represents an interface type or a primitive
Java type, etc. 
 \JAVA\ では全クラスが \texttt{java.lang.JavaLangObject}から継承を行う。
これは\texttt{java.lang.Class}のインスタンスを返すメソッド \texttt{getClass} を含むもので、言い換えればクラスについての様々な情報を得るための機能、たとえば、クラス名称や、クラスがインターフェイス型に相当するかあるいは基本的Java型であるか、等々、を提供してくれる。 

The translator simulates part of this functionality using the class
\texttt{JavaLangClass} which is defined as follows:
翻訳においては、以下のように定義されたクラス\texttt{JavaLangClass} を用いて、この機能の一部をシミュレートする:

\begin{small}
\begin{verbatim}

class JavaLangClass ...
types
  CLASS ::
    name : seq of char
    cori : <CLASS> | <INTERFACE>
    isPrim : bool

instance variables
  private val : JavaLangClass`CLASS;

operations 

public  JavaLangClass :  seq1 of char * 
             (<CLASS> | <INTERFACE>) * bool ==> JavaLangClass
JavaLangClass(name, cori, prim) == 
( val.name := name;
  val.isPrim := prim;
  val.cori := cori;
);

public  getName : () ==> JavaLangString
getName() == 
  return new JavaLangString(val.name);

public  isArray : () ==> bool 
isArray() == 
  return false;

public  toString : () ==> JavaLangString
toString() == 
( dcl
    str: seq of char :=
      if isInterface()
      then "interface "
      else 
        if isPrimitive()
        then ""
        else "class ";
  str:=str^getName().toSeqOfChar();
 return new JavaLang(str)
);

public  isInterface : () ==> bool 
isInterface() == 
  return val.cori=<INTERFACE>;

public  isPrimitive : () ==> bool 
isPrimitive() == 
  return val.isPrim;

...

end JavaLangClass

\end{verbatim}
\end{small}

A constant \texttt{CLASS}, whose value is an appropriate instance of
this class, together with a (public) method \texttt{getClass} which
returns the value of this constant, are then added to each generated
\VDM\ class. This is illustrated by the example below. 
定数 \texttt{CLASS}は、その値がこのクラスに適合したインスタンスであり、この定数の値を返す (public) メソッド \texttt{getClass} と共に、各\VDM\ クラスが生成されたときに付加される。
これは以下の例題で表わされる。

\begin{small}
\begin{verbatim}
class A ...
values 
  CLASS : JavaLangClass = new  JavaLangClass("A", <CLASS>, false)
...

public  getClass : () ==> JavaLangClass
getClass() == 
return  CLASS;

end A
\end{verbatim}
\end{small}

\subsection{インターフェイス}\label{interface}

Interfaces in Java are translated to classes in VDM++. However, only
the signatures of the methods in a Java interface are given, while in
VDM++ a method must always have a body. The translator therefore sets
the bodies of methods in Java interfaces to \texttt{is not yet
  specified} in VDM++. 
Javaのインターフェイスは VDM++のクラスに翻訳される。
しかしJavaインターフェイスでメソッドのシグニチャのみが与えられる一方で、VDM++ではメソッドは常に本体をもたなければならない。 
したがって翻訳では、Javaインターフェイスのメソッド本体は VDM++での \texttt{is not yet specified} に設定する。

It might seem more natural to use \texttt{is subclass responsibility}
  here instead of \texttt{is not yet specified}. However, this does
  not work because of the way the value \texttt{null} is
  translated‾(see Section‾\ref{null}). To see this, consider the
  following Java example in which the value \texttt{null} is used in
  conjunction with objects of an interface type:
ここでは、 \texttt{is not yet specified}の代わりに \texttt{is subclass responsibility}を用いる方がより自然であろう。
しかし値 \texttt{null} が翻訳される方式のせいで、これは機能しない‾(第‾\ref{null}章参照)。 
この理解を行うために、１つのインターフェイス型のオブジェクトと結びついて値 \texttt{null}が用いられる以下の Java 例題を考えよう:

\begin{small}
\begin{verbatim}
interface IFace {...}
...
IFace iface = null;
\end{verbatim}
\end{small}

In this case the translator would translate \texttt{null} to
\texttt{new IFace(<NIL>)} as explained in 
Section‾\ref{null}, which includes an instantiation of the class
\texttt{IFace}. This means that the class \texttt{IFace} cannot be
abstract (otherwise this instantiation does not make sense), and thus
that we cannot use \texttt{is subclass responsibility} to represent
the bodies of interface methods.
この場合の翻訳では、第‾\ref{null}章で述べるように \texttt{null} を\texttt{new IFace(<NIL>)} に変換するが、\texttt{IFace}クラスの実体化を含むものである。 
これはクラス \texttt{IFace}が概念上のものではないはずということ (そうでなければこの実体化は意味をなさない)、したがってインターフェイスメソッドの本体を表すのに \texttt{is subclass responsibility} を用いることはできないことを意味する。

Recall also that translating an interface class from Java to VDM++ and
then re-translating the VDM++ back to Java can cause problems. See the
discussion at the end of Section‾\ref{inheritance} for details.
インターフェイスクラスを Java から VDM++ へ翻訳し、その後逆に VDM++ からJavaに再び翻訳することが、問題の原因となる可能性を思い出そう。
詳細は、第‾\ref{inheritance}章の最後の記述を参照すること。


\subsection{\texttt{null}}\label{null}

In Java it is possible to overload operations and invoke a particular
one of these operations with the (polymorphic) value \texttt{null} by
casting the value to the appropriate input type as in the examples
below: 
Javaでは下記の例題にあるように、(多様型の)値 \texttt{null}が適切な入力型となるようにその値をキャストすることによって、操作の上書きをし、またそれら操作の特定の１つを起動することも可能である: 

\begin{small}
\begin{verbatim}
void op(A a)  
 
void op(B b)   

op((A)null)

op((B)null)
\end{verbatim}
\end{small}

In VDM++ there is no polymorphic constant which belongs to all types
and which can be coerced to a specific class by tagging it with the
name of that class. (The closest is perhaps the value \texttt{nil},
which belongs to all optional types, though this cannot be coerced to
any one type.)
VDM++では、すべての型に属しつつ、そのクラス名称のタグ付けで特定クラスに振られるといった、多様型の定数は存在しない。
(最も近い値はたぶん \texttt{nil}で、これはすべての任意型に属し、しかもどのような型にも振られることはない。)

Instead, therefore, we make every translated VDM++ class a
subclass of a special class \texttt{Nullable} (by defining the class
\texttt{JavaLangObject} to be a subclass of the class
\texttt{Nullable}). The (boolean valued) instance variable
\texttt{isNil} in the class \texttt{Nullable} is then used to indicate
whether or not a particular object belonging to the class corresponds
to the Java value \texttt{null}. 
したがってこの代わりに、すべての翻訳済みの VDM++ クラスを特定クラス \texttt{Nullable} のサブクラスとする(クラス\texttt{JavaLangObject}をクラス\texttt{Nullable}のサブクラスと定義することにより)。 
したがって、クラス \texttt{Nullable} の (ブール値である) インスタンス変数\texttt{isNil} は、Java値である \texttt{null}に相当するクラスに属する特定オブジェクトかそうでないかを示すのに用いられる。 

\begin{small}
\begin{verbatim}
class JavaLangObject is subclass of Nullable
...

class Nullable
instance variables
  public isNil: bool := false
operations
  public IsNil: () ==> bool
  IsNil() == return isNil
end Nullable
\end{verbatim}
\end{small}

In addition, we introduce a new special value \texttt{<NIL>}
into the VDM++ specification and generate an additional constructor
for each \VDM\ class which creates instances which represent the
\texttt{<NIL>} value of that class. This is shown in the following
example: 
加えて、VDM++ 仕様に新しい特定値 \texttt{<NIL>}を 導入して、各 \VDM\ クラスに対してそのクラスの\texttt{<NIL>} 値を表すインスタンスをつくる追加のコンストラクタを生成する。
これは以下の例題でみることができる: 

\begin{small}
\begin{verbatim}
ClassName: <NIL> ==> ClassName
ClassName() ==
  isNil := true;
\end{verbatim}
\end{small}


To simulate the \texttt{null} value for arrays we use the empty map. 
配列に対する \texttt{null} 値をシミュレートするために、空写像を用いる。 

The examples in the table in Figure‾\ref{fig:nullxfs} illustrate how
\texttt{null} is translated in different contexts.
 図‾\ref{fig:nullxfs} にある表の例題は、\texttt{null} が異なる文脈でどのように翻訳されるかを表している。

\begin{figure}[htbp]
  \begin{center}
\begin{longtable}{|l|p{7cm}|}
\hline
  \JAVA\   & \VDM\ \\ \hline \hline
  \texttt{ClassType o = null;}      & \texttt{dcl o: ClassType := new ClassType(<NIL>)}    \\ \hline
  \texttt{ClassType o[2] = {null};} & \texttt{dcl o: map int to ClassType}
                                      \texttt{:= \{new ClassType(<NIL>) | i in set \{0,...,1\}\}}    \\ \hline
  \texttt{type o[] = null;}         & \texttt{o := \{|->\}}    \\ \hline
  \texttt{op(null);}                & \texttt{op(new ClassType(<NIL>))}    \\ \hline
  \texttt{o == null}                & \texttt{o.IsNil()}    \\ \hline
  \texttt{o != null}                & \texttt{not o.IsNil()}    \\ \hline
\end{longtable}    
    \caption{\texttt{null}変換}
    \label{fig:nullxfs}
  \end{center}
\end{figure}

It is important to note here that this treatment of \texttt{null} can
lead to endless loops at the VDM++ level. Consider the following
example in Java:
 \texttt{null} のこの取扱いは、 VDM++ レベルで終わりのないループを導く可能性があることを、注意しておくことが大切だ。
Javaの以下の例題を考えてみよう:

\begin{small}
\begin{verbatim}
class Database

{
    Database db = null ;
}
\end{verbatim}
\end{small}

This would be translated to the following in VDM++:
これは VDM++では以下のように翻訳されるだろう:

\begin{small}
\begin{verbatim}
class Database is subclass of JavaLangObject

instance variables
    db : Database = new Database(<NIL>) ;
\end{verbatim}
\end{small}

which contains an infinite loop -- each instantiation of the class
Database invokes another instantiation in order to set the value of
its instance variable. The same problem can also occur indirectly as
in the following example where the \texttt{Database} class has an
instance variable of type \texttt{Controller} and vice versa:
これは無限ループを含んでいる -- クラスデータベースの各初期化が、そのインスタンス変数の値を設定するために、もう１つの初期化を起動するのである。
 \texttt{Database} クラスが \texttt{Controller} 型のインスタンス変数をもち、またその逆でもあることで、以下の例題のように同じ問題が間接的に起きる可能性もある:
以下の例題では、\texttt{Database} クラスが型\texttt{Controller} のインスタンス変数をもっているし逆にもたれてもいる:

\begin{small}
\begin{verbatim}
JAVA:

class Controller
{
  Database database;
  Controller()
  {
          database = null;
  }
  static public Controller getController()
  {
          return new Controller();
  }
}

class Database

{
        Controller
                controller = Controller.getController();
}

VDM:

class Controller is ...
instance variables
        database: Database;
operations
        Controller: () ==> Controller
                database := new Database(<NIL>);

        static public getController: () ==> ()
        getController() ==
                return new Controller(<NIL>);
end Controller

class Database is ...
instance variables
        controller: Controller := Controller`getController();
end Database
\end{verbatim}
\end{small}

Care should therefore be taken to avoid such situations in the Java
code. 
したがってJavaコード中で、このような状態をさけるための注意が払われるべきである。
\subsection{式}\label{expressions}

In \JAVA\ it is possible to write an expression with side effects such
as \texttt{f(n) - mm[n++]}. This feature has no direct counterpart
in VDM++, and in general a sequence of VDM++ statements is required in
order to obtain something semantically equivalent. We deal with this
by introducing a \texttt{def} expression and generating local names
within this to store the values of the various components of the
expression. This is best illustrated by an example.
 \JAVA\ では、  \texttt{f(n) - mm[n++]}といった副次的作用をもつ式を書くことができる。
この特質は VDM++でちょうど一致するものはなく、一般的にも意味的に同等のものを得るためには、 VDM++ 文の連続が必要となる。
式の様々な構成要素の値を保存するために \texttt{def} 式を導入して、この中に局所的な名称を生成することで、これを扱う。
例題を用いるのが最もわかりやすい。

Consider the following fragment of an expression which has side
effects in Java:
以下のような、Javaで副次的作用をもつ式の断片を考えよう:

\begin{small}
\begin{verbatim}
  ... f(n)-mm[n++] ...
\end{verbatim}
\end{small}

This expression is part of an enclosing expression, so in the VDM++ we
introduce a \texttt{def} expression and the pattern name \texttt{l\_1}
to record its value. 
この式は囲った式の一部であり、 VDM++ではこの値を記録するために、 \texttt{def} 式とパターン名称 \texttt{l\_1}を導入する。

The expression itself is a binary expression, so two more pattern
names \texttt{l\_2} and \texttt{l\_3} are introduced to store the
values of its left and right operands respectively and \texttt{l\_1}
is defined appropriately in terms of \texttt{l\_2} and \texttt{l\_3}. 
式それ自体は２進式で、その左右両辺の値をそれぞれ保存するために、 さらに２つのパターン名称\texttt{l\_2} と \texttt{l\_3} が導入され、そして \texttt{l\_2} と \texttt{l\_3}の点から見て \texttt{l\_1}が適当なものとして定義される. 

Note that \texttt{l\_2} is only needed because
the right operand has side effects. We can not define \texttt{l\_1}
simply as \texttt{f(n) - l\_3} because its definition is preceeded
by the statements generated for the right operand which change \texttt{n}.
右辺が副次作用をもつために、 \texttt{l\_2} のみが必要とされていることに注意しよう。
\texttt{l\_1}を単純に \texttt{f(n) - l\_3} として定義することはできない、というのはこの定義では、\texttt{n}を変える右辺のために生成された文が、前に置かれているからである。

The final result is as follows:
最終結果は以下の通り:

\begin{small}
\begin{verbatim}
  def l_2 = f(n);
  l_4 = n;
  l_5 = l_4
  in ( n := l_4 + 1;
    def l_3 = mm(l_5);
    l_1 = l_2 - l_3
    in ... l_1 ...
  ) ;

\end{verbatim}
\end{small}


Expressions like \texttt{new ClassType(...);} and \texttt{op();} can
also be used as statements in Java, and it is possible to write
sequences of such expressions as in the following example:
\texttt{new ClassType(...);} や \texttt{op();} といった式は、Javaでは文としても用いられ得るし、以下の例題のようにこのような式の連続を書くことが可能である:

\begin{small}
\begin{verbatim}
new A();
op1();
op2();
\end{verbatim}
\end{small}

In Java, if an expression in such a sequence returns a result that
result is ignored and the execution passes to the next expression in
the sequence, but the semantics of VDM++ do not match this and instead
state that as soon as the execution encounters an expression that
returns a result the execution terminates and that result becomes the
result of the whole sequence. When translating such expressions,
therefore, we need to avoid this problem. This is done by using a
\texttt{let} statement to assign the result to a dummy (in fact
unnamed) variable and making the body of the \texttt{let} statement
the identity statement \texttt{skip}. The translation of the Java
example above is thus:
Javaでは、このような連続の式が結果を返すときは、その結果は無視されて実行は連続の次の式に渡されるが、 VDM++ の意味論はこれとは一致せず、かわりに実行が結果を戻す式に出会うやいなや実行は終了し、結果は全連続の結果となる。
したがって、このような式を翻訳するときは、この問題をさける必要がある。
\texttt{let}文を用いて結果をダミーに代入することで、対処する。
上記Java例題の翻訳はこのようになる:

\begin{small}
\begin{verbatim}
let - = new  A()
in 
  skip ;
let - = op1()
in 
  skip ;
let - = op2()
in 
  skip ;
\end{verbatim}
\end{small}

\subsection{文}

\subsubsection{If 文}

The translation of \texttt{if} statements is straightforward. The
component parts are simply translated as illustrated below:
\texttt{if} 文の翻訳はそのまま行われる。 
構成部分は、以下に示されるように素直に翻訳される:

\begin{small}
\begin{verbatim}
JAVA:

if condition
then thenStmt
else elseStmt

VDM:

if translatedCondition
then translatedThenStmt
else translatedElseStmt
\end{verbatim}
\end{small}

\subsubsection{Block 文}

A block in Java becomes a block statement in VDM++. The Java local
variable declarations become \texttt{dcl} statements within the block
and the body of the block in Java becomes the body of the block
statement in VDM++. The following example illustrates this:
Java のブロックは、 VDM++においてブロック文となる。
VDM++においてJava の局所的変数宣言は、ブロック内での \texttt{dcl} 文となり、Java のブロック本体は ブロック文の本体となる。
以下の例題ではこれを表わしている:

\begin{small}
\begin{verbatim}
JAVA:

{ int b, c; int d, e=0; ... }

VDM:

( dcl b : int ,
      c : int ,
      d : int ,
      e : int  := 0;
  ...
) ;
\end{verbatim}
\end{small}

\subsubsection{\texttt{for} 文}

A \texttt{for} statement in Java is translated to a block statement in
VDM++ in which the loop variables are introduced in \texttt{dcl}
statements and the body is a while loop. This is illustrated by the
following example: 
Javaの \texttt{for} 文はVDM++のブロック文に翻訳されるが、ここでループ変数が \texttt{dcl}文中に導入され本体は while ループとなる。
これは以下の例題で表される: 

\begin{small}
\begin{verbatim}
JAVA:

for(int i=0, j=10; i<10; i++, j--) {
  ...
}

VDM:

( dcl   i : int  := 0,
        j : int  := 10;
  while  i < 10 do  
  ( ...
    i := i+1;
    j := j-1
  ) 
) ;
\end{verbatim}
\end{small}

\subsubsection{\texttt{while} 文}

The translation of while loops is straightforward except where the
loop termination expression has side effects in which case it is
treated in the way described in Section‾\ref{expressions} both before
the loop is entered and at the end of each iteration. This is
illustrated in the following example:
while ループの翻訳は、ループ終了式が副次作用をもつ場所では、ループに入る前と各繰り返しの最後との両方で、Section‾\ref{expressions}に記されている方法で取り扱われるが、それ以外の場所ではそのまま素直な方法で取り扱われる。
これは以下の例題に表されている:

\begin{small}
\begin{verbatim}
JAVA:

while(mm[i++]>0) {
  ...
}

VDM:

( dcl   l_7 : bool ;
  def l_5 = i;
  l_4 = l_5
  in ( i := l_5+1;
    def l_2 = mm(l_4);
    l_1 = l_2 > 0
    in l_7 := l_1
  ) ;
  while  l_7 do  
  ( ...
    def l_5 = i;
    l_4 = l_5
    in ( i := l_5+1;
      def l_2 = mm(l_4);
      l_1 = l_2 > 0
      in l_7 := l_1
    ) 
  ) 
) ;
\end{verbatim}
\end{small}

\subsubsection{\texttt{do while} 文}

To translate a \texttt{do while} statement of the form 
次の形式の \texttt{do while} 文を翻訳するとする 

\begin{small}
\begin{verbatim}
do {
  i++; ... 
} while(mm[i]>0);
\end{verbatim}
\end{small}

we convert it to the equivalent \texttt{while} statement 
まずこれと同等な \texttt{while} 文に変換する

\begin{small}
\begin{verbatim}
( i := i+1; ...
) ;
while  mm(i) > 0 do  
( i := i+1; ...
) ;
\end{verbatim}
\end{small}

and translate this \texttt{while} statement.
そしてこれを \texttt{while} 文に翻訳する。

\subsubsection{\texttt{switch} 文}

A \texttt{break} in Java is translated to an exception throw in VDM++
because it can appear anywhere inside an alternative. The following
example, in which there is a \texttt{break} in \texttt{case 1:},
illustrates this.
Javaの \texttt{break}は VDM++の例外処理実行で翻訳されるが、 選択肢内どこにでも現れる可能性があるからだ。
以下の例題で、 \texttt{case 1:}に \texttt{break}があるが、これを表している。

\begin{small}
\begin{verbatim}
JAVA:

switch(a) {
  case 0:
    alternative1
  break;
  case 1:
    if(b<5) break;
    alternative2
  break;
  default:
    alternative3
  break;
}

VDM:

trap  j2v_break with  
  cases  true  : 
    (isofclass  (J2V_Break,j2v_break)) -> 
      skip 
    
  end  
in  
  ( cases  a: 
      (0) -> 
        ( translatedAlternative1
          exit  new  J2V_Break()
        ) ,
      (1) -> 
        ( if b<5 then exit  new  J2V_Break();
          translatedAlternative2
          exit  new  J2V_Break()
        ) ,
      others  -> 
        ( translatedAlternative3
          exit  new  J2V_Break()
        ) 
    end  
  ) ;
\end{verbatim}
\end{small}


\subsubsection{\texttt{try catch} 文}

A Java \texttt{try catch} statement is translated to a combination of
an \texttt{always} statement and a \texttt{trap} statement as
illustrated in the following example:
Javaの \texttt{try catch} 文は、以下の例題に表されるように \texttt{always}文と \texttt{trap} 文 との結合に翻訳される:

\begin{small}
\begin{verbatim}
JAVA:

class B extends JavaLangException { ... }

try { tryBody }
catch(B b) { catchBbody }
catch(JavaLangException e) { catchEbody }
finally{ finallyBody }

VDM:

class B is subclass of JavaLangException
...
end B

always  
  ( translatedFinallyBody 
  ) 
in  
  trap j2v_exception : JavaLangException with  
    cases true  : 
      (isofclass(B, j2v_exception) and not  j2v_exception.IsNil()) -> 
        ( dcl b : B := j2v_exception;
          translatedCatchBbody 
        ) ,
      (isofclass(JavaLangException, j2v_exception) or 
                                           j2v_exception.IsNil()) -> 
        ( dcl b : JavaLangException := j2v_exception;
          translatedCatchEbody 
        ) ,
      others  -> 
        exit  j2v_exception
    end  
  in  
    translatedTryBody
\end{verbatim}
\end{small}

\newpage
\section{VDM++ 変換群}
\label{xforms}

The transformations which are currently supported apply to certain
kinds of expressions (binary expressions) and certain kinds of
statements (if statements, block statements, and while loop
statements). The specific transformations are listed in
Table‾\ref{fig:xfs}, the first column of which shows the 
name of the transformation and the second the kind of expression or
statement to which it applies. A brief explanation and an example of
each transformation is given below.
現在サポートされている変換は、特定の式 (２進式)と特定の文 (if 文、block 文、whileループ文)に適用される。 
具体的な変換は表‾\ref{fig:xfs}に一覧されていて、その最初の欄には変換の名称が示され、第２欄は適用される式または文の種類が示されている。
短い説明と各変換例は以下に与えられている。

\begin{figure}[htbp]
  \begin{center}
\begin{tabular}{|l|l|}
\hline 
名称 & 適用\\ \hline \hline
isMapCompLoop & Block Stmt  \\ \hline
ifTestTrue & Block Stmt  \\ \hline
ifTestFalse & Block Stmt  \\ \hline
isRedundantIfBlock & Block Stmt \\ \hline
ifToAnd & Block Stmt  \\ \hline
isRedundantIfBlockNoElse & Block Stmt \\ \hline
isRedundantDcl & Block Stmt \\ \hline
ifToCases & If Stmt \\ \hline
ifToEquiv & If Stmt \\ \hline
nestedIfsNoElses & If Stmt  \\ \hline
whileIfTestTrue &  While Loop \\ \hline
%isRenamingDefStmt & Define Stmt \\ \hline
%isRedundantDef & Define Expr \\ \hline
%isRenamingDef & Define Expr \\ \hline
orToNotEquiv & Binary Expr \\ \hline
\end{tabular}    
    \caption{変換一覧}
    \label{fig:xfs}
  \end{center}
\end{figure}

The transformations are attempted in the order in which they appear in
the table, so in situations in which two different transformations
could in principle be applied to the same construct only the first of
these is actually applied. In addition, the transformations are only
applied once. This means that there could still be places in the VDM++
output where transformations could be applied, for example when one
transformation transforms the specification into something which
matches another transformation. 
変換は、表に現れる順に試みられるので、２つの異なる変換が同じ構築物に適用される状況では、原則的にはその最初の方のみが実際に適用される。
さらに、変換の適用は一度だけとなる。
これは VDM++の出力にさらに変換が適用され得ることを意味していて、例えばある変換が別の変換と合致するような仕様の変化を行うときである。

\subsection{isMapCompLoop (Block Stmt)} 
  Replaces stepwise construction of a map using a while loop with a
  map comprehension expression. Can deal with increasing and
  decreasing loop variables, inclusion or exclusion of equality in the
  test of the while loop, and arbitrary step sizes for the loop
  variable. Also allows arbitrary specification to appear after the
  loop. 
  写像の段階的な構築を whileループを用いて写像包含式に置き換える。
ループ変数の増加減少、 while ループテストでの相等の包含または排除、ループ変数の任意の刻み幅、を扱うことができる。
さらに、ループ後に現れる任意の仕様は許されている。

As an example, the following specification involving a while loop
例題として、 以下はwhileループを含む仕様である

\begin{verbatim}
  public Test : () ==> map nat to [nat]
  Test () ==
    ( dcl m : map nat to [nat] := 
                  {l |-> nil | l in set {0,...,12}};
      dcl b : bool := true;
        (dcl  i : int := 0;
         while i < 12 do
           ( m := m ++ {i |-> f(i)};
             i := i + 1 )
        );
      return m);
\end{verbatim}

would transform to this specification involving a map comprehension
写像包括を含めたこのような仕様への変換がなされるであろう

\begin{verbatim}
public Test : () ==> map nat to [nat]
  Test () ==
    ( dcl m : map nat to [nat] := 
                  { l |-> nil | l in set {0,...,12} },
          b : bool := true;
      ( dcl i : int := 0;
        m := m ++ { i |-> f(i) | 
                         i in set {0, ..., 12 - 1} }
      );
      return m);
\end{verbatim}


\subsection{ifTestTrue (Block Stmt)}
  Transforms a block which begins
  次に始まるブロックを変換する

\begin{verbatim}
  ( dcl ... , x : bool := true, ... ; 
    if x then y else z;
    ...
  )
\end{verbatim}

into one which begins
次に始まるようなものとなる

\begin{verbatim}
  ( dcl ... , x : bool := true, ... ; 
    y;
    ...
  )
\end{verbatim}

For example, the following specification
たとえば、以下の仕様は

\begin{verbatim}
  public Test : () ==> nat  
  Test () ==
    def n : nat = 5 in
        ( dcl x : bool := true;
          if x then return n else return 0 );
\end{verbatim}

is transformed to
次のように変換される

\begin{verbatim}
  public Test : () ==> nat  
  Test () ==
    def n : nat = 5 in
        ( dcl x : bool := true;
          return n );
\end{verbatim}

\subsection{ifTestFalse (Block Stmt)}

  Transforms a block which begins
 次に始まるブロックがある

\begin{verbatim}
  ( dcl ... , x : bool := false, ... ; 
    if x then y else z;
    ...
  )
\end{verbatim}

into one which begins
これは次のようになる

\begin{verbatim}
  ( dcl ... , x : bool := false, ... ; 
    z;
    ...
  )
\end{verbatim}

For example, the following specification
たとえば、以下の仕様がある

\begin{verbatim}
  public Test : () ==> nat  
  Test () ==
    def n : nat = 5 in
        ( dcl x : bool := false;
          if x then return n else return 0 );
\end{verbatim}

is transformed to
変換されると次のようになる

\begin{verbatim}
  public Test : () ==> nat  
  Test () ==
    def n : nat = 5 in
        ( dcl x : bool := false;
          return 0 );
\end{verbatim}


\subsection{isRedundantIfBlock (Block Stmt)}
  Replaces a block statement of the form 
  次の構造のブロック文を置き換える

\begin{verbatim}
  ( dcl ...,  b : bool  := false, ... ;
    if  test 
    then  
      ( b := true  
      ) 
    else  
      ( b := false  
      ) ;
    return  b
  ) ;
\end{verbatim}
  
with 

\begin{verbatim}
  return test;
\end{verbatim}

The block can be inside another block and the boolean type can be an
indirect reference as in the following example
ブロックはもう１つのブロックの中に置くことができるし、ブール型は以下の例題にあるように間接的な参照となる

\begin{verbatim}
  types T = bool;

  operations

    public Test : () ==> bool  
    Test() ==
      ( dcl b : seq of char;
        ( dcl b : bool := false;
          ( dcl b : T := true;
            dcl c : bool := b;
            if c
            then (b := true)
            else (b := false);
            ((return b;))
          );
          return b
        );
      );
\end{verbatim}

which transforms to
これは次のように変換される

\begin{verbatim}
  types T = bool;

  operations

    public Test : () ==> bool  
    Test() ==
      ( dcl b : seq of char;
         ( dcl b : bool := false;
            ( dcl b : T := true,
                  c : bool := b;
              return c
            );
           return b 
         ); 
      );
\end{verbatim}


\subsection{isRedundantIfBlockNoElse (Block Stmt)}
  Analogous to the above transform except that it applies to the case
  when the if statement has no else clause. Thus, for example, the
  following specification
if文がelse節を持たない場合に適用されるという以外は、上記変換に類似している。
このように、たとえば以下のような仕様がある

\begin{verbatim}
  public Test : () ==> bool  
  Test () ==
    ( dcl a : bool;
        ( dcl b : bool := false;
            ( dcl c : bool := false;
              if (2 > 1)
              then (b := true)
            );          
          return b
        );
    );
\end{verbatim}

is transformed to
これは次のように変換される

\begin{verbatim}
  public Test : () ==> bool  
  Test () ==
    ( dcl a : bool;
        ( dcl b : bool := false;
            ( dcl c : bool := false;
              return (2 > 1)
            );
        );
    );
\end{verbatim}

\subsection{ifToAnd (Block Stmt)}
  Transforms a consecutive pair of statements of the form
  次の形式の２文の連続を変換する

\begin{verbatim}
  if a then return b;
  return false;
\end{verbatim}

to the single statement
これを１文にする

\begin{verbatim}
  return a and b;
\end{verbatim}

Redundant blocks are also removed as in the following example
冗長ブロックもまた、以下の例題にあるように、取り除かれる

\begin{verbatim}
  public Test : () ==> bool
  Test () ==
    ( dcl x : nat := 12;
        ( if x < 3 then return x > 3);
        (((return false)))
                
    );
\end{verbatim}

which is transformed to
これは次のように変換される

\begin{verbatim}
  public Test : () ==> bool
  Test () ==
    ( dcl x : nat := 12;
      return x < 3 and  x > 3 
    ); 
\end{verbatim}

\subsection{isRedundantDcl (Block Stmt)}
  Replaces a block statement of the form
  次の形式のブロック文がある

\begin{verbatim}
   ( dcl x : A := y;
     return x
   );
\end{verbatim}

with the return statement
これをreturn 文で置き換える 

\begin{verbatim}
  return y;
\end{verbatim}

Thus, for example, the following specification
たとえば、以下のような仕様がある

\begin{verbatim}
  types

    public T = (nat * nat)

  operations

    public Test : () ==> T
    Test () ==
      (dcl r : T := def mk_(a,2) = mk_(1,2) in mk_(a,2);
       return r);
\end{verbatim}

is transformed to
これは次のように変換される

\begin{verbatim}
  types

    public T = (nat * nat);

  operations

    public Test : () ==> T
    Test() ==
      return def mk_(a,2) = mk_(1,2) in mk_(a,2);
\end{verbatim}

\subsection{ifToCases (If Stmt)}
  Transforms a multiply nested if statement of the form
  次の形式の多重ネストされた if 文を変換しよう
\begin{verbatim}
  if x = a1
  then r1
  else if x = a2
       then r2
       else if x = r3
            then r3
            else ....
\end{verbatim}

to a cases statement of the form
次の形式の cases 文に対して
\begin{verbatim}
  cases x :
    a1 -> r1,
    a2 -> r2,
    a3 -> r3,
    ...
\end{verbatim}
At the same time, redundant blocks are removed. Thus, for example, the operation同時に、冗長なブロックが取り除かれる。
たとえば、次のような操作がある

\begin{verbatim}
  public Test : () ==> nat  
  Test () ==
    ( dcl x : nat := 5;
      if x = 1 
      then return 1
      else if (x = 2) 
           then ((return 2))
           else if (((x = 3))) 
                then return (3) 
                else if x = 4 
                     then (return 4)
                     elseif (x = 5)
                     then return 5; 
      return x);
\end{verbatim}
is transformed to
これは次のように変換される
\begin{verbatim}
  public Test : () ==> nat
  Test() == 
    ( dcl x : nat := 5;
      cases x :
        1 -> return 1,
        2 -> return 2,
        3 -> return 3,
        4 -> return 4,
        5 -> return 5
      end;
    return x);
\end{verbatim}


\subsection{ifToEquiv (If Stmt)}
  Transforms an if statement of the form 
  次の形式の if 文を変換する 
\begin{verbatim}
  if a then (if b then x else y) else (if b then y else x) 
\end{verbatim}    
to the form
次の形式になる
\begin{verbatim} 
   if a <=> b then x else y
\end{verbatim}

As an example, the following operation
例題として、以下の操作があるとする
\begin{verbatim}
  public Test : nat * nat ==> nat  
  Test (x, y) ==
    ( if x > 2 
      then ( if y < 1 then return 1 else return 2 )
      else ( if y < 1 then return 2 else return 1 ) 
    );
\end{verbatim}
would be transformed to
これは次のようになるだろう
\begin{verbatim}
  public Test : nat * nat ==> nat  
  Test (x, y) ==
    ( if x > 2 <=> y < 1 
      then return 1 
      else return 2 
    );
\end{verbatim}

\subsection{nestedIfsNoElses (If Stmt)}
  Transforms a double if statement of the form
  次の形式の２つの if 文を変換する
\begin{verbatim}
  if a then (if b then c)
\end{verbatim}
to a single if statement
\begin{verbatim}
  if a and b then c
\end{verbatim}

Thus, for example, the operation
たとえば、次のような操作がある
\begin{verbatim}
  public Test : int * int ==> bool
  Test (x, y) ==
    ( for i in [1, 2, 3] do
        ( if x > i then if i > y then return false );
      return true;
    );
\end{verbatim}
would be transformed to
次のように変換されるだろう
\begin{verbatim}
  public Test : int * int ==> bool
  Test (x, y) ==
    ( for i in [1, 2, 3] do
        ( if x > i and i > y then return false );
      return true;
    );
\end{verbatim}

\subsection{whileIfTestTrue (While Loop)}
  Simplifies an if statement which occurs at the beginning of a while
  loop and which has the same test as the while loop. In general, the
  transformation converts a while loop of the form
 whileループの最初に現れて、whileループと同じ判定を行う、そのようなif 文を単純化する。
これは一般的に、次の形式の while ループの変換である
\begin{verbatim}
   while test do  
      ( if test then x else y; ... ) 
\end{verbatim}
to one of the form
これが次のようになる
\begin{verbatim}
   while test do  
      ( x; ... ) 
\end{verbatim}

For example, the following operation
たとえば、以下の操作は
\begin{verbatim}
  public Test : nat * int ==> nat
  Test (x, y) ==
    ( while x > 5 do
        ( if x > 5 then y := y + 1 else y := y - 1; 
          x := x - 1 );
      return y;
    );
\end{verbatim}
is transformed to
次のように変換される
\begin{verbatim}
  public Test : nat * int ==> nat
  Test (x, y) ==
    ( while x > 5 do
        ( y := y + 1; 
          x := x - 1 );
      return y;
    );

\end{verbatim}

%\subsection{isRenamingDefStmt (Define Stmt)}

% \subsection{isRedundantDef (Define Expr)}
%   Transforms a define expression of the form
% \begin{verbatim}
%   def x : A = y in x
% \end{verbatim}
% in which x is a simple name, to y. Thus, for example, the operation 
% \begin{verbatim}
%   public Test : () ==> real  
%   Test () ==
%     return ( def x : real = 
%       ( 12 - 7 ) in x ) + ( def y : real = 0 in y )
% \end{verbatim}
% transforms to
% \begin{verbatim}
%   public Test : () ==> real  
%   Test () ==
%     return ( 12 - 7 ) + 0 
% \end{verbatim}

%\subsection{isRenamingDef (Define Expr)}


\subsection{orToNotEquiv (Binary Expr)}
  Transforms an or expression of the form
  次の形式のand／or式を変換する
\begin{verbatim}
  not a and b or a and not b
\end{verbatim}
into the logically equivalent form
結果を次のような論理的に同等な形式とする
\begin{verbatim}
  not (a <=> b)
\end{verbatim}
At the same time, redundant brackets are removed. Thus, for example,
the operation
同時に、冗長な括弧は取り除かれる。
このように、たとえば次の操作は
\begin{verbatim}
  public Test : () ==> bool
  Test () ==
    ( return (((not (let a = true in a) and (false)) or 
               (((((let a = true in a) and not (false)))))))
    );
\end{verbatim}
is transformed to
次のように変換される
\begin{verbatim}
  public Test : () ==> bool
  Test () ==
    return (not ((let a = true in a) <=> false));
\end{verbatim}

\newpage
\section{\JAVA\ API クラス群の\VDM\ モデル}\label{javaapi}

\TjTov\ is supplied with \texttt{*-.java} files containing skeletons of a subset of 
\JAVA\ API classes. They might need to be in your project.
At least you need \texttt{java.lang.JavaLangObject} and all classes it references.
\TjTov\ は、 \JAVA\ API クラスのサブセットのスケルトンを含む\texttt{*-.java}ファイルと共に提供される。 
これらは、プロジェクト内に入れておく必要があるだろう。
少なくとも、 \texttt{java.lang.JavaLangObject}とそれが参照するすべてのクラスは必要である。

There is no need to translate them to \VDM\ because \tjTov\ is
also equipped with their \VDM\ counterparts. 
A \JAVA\ API class is represented at the \VDM\ level as a
plain \VDM\ class or a dynamically linkable class (\texttt{dlclass}).
Implementation of dlclasses is housed in \texttt{j2vdll.so}.
それらを \VDM\ に翻訳する必要はない、というのは\tjTov\ もまた \VDM\ に一致する部分を備えている。
\JAVA\ API クラスは \VDM\ レベルでは、単純 \VDM\ クラスまたは動的リンク可能クラス (\texttt{dlclass})として標識される。
動的リンク可能クラスの実装は、 \texttt{j2vdll.so}に格納されている。

\JAVA\ API is only partially covered at the \VDM\ level. 
Some methods could not be translated into \VDM\
because they use \JAVA\ features that are not available in \VDM{}.
For example, the method \texttt{JavaUtilVector.copyInto} has an array
as an output parameter which is impossible in \VDM\ because an array
is a map and a map is passed by value. There are also \JAVA\ API
classes which have overloaded methods which cannot be translated
because their signatures will coincide (e.g.\
\texttt{JavaLangString.valueOf(int) and
  JavaLangString.valueOf(long)}). 
\JAVA\ API は、部分的に過ぎないが \VDM\ レベルで保護されている。
いくつかの方法は \VDM\ で翻訳可能にはならない、これは \VDM{}では利用できない \JAVA\ 特性を用いているからである。
たとえばメソッド \texttt{JavaUtilVector.copyInto} は出力パラメータとして配列をもつが、これは \VDM\ では不可能であり、配列は写像で写像は値によって渡されるからである。
また \JAVA\ APIクラスで、それらのシグニチャが一致してしまうために上書きされてしまうメソッドをもつ、翻訳が不可能な \JAVA\ APIクラスもある (たとえば\\texttt{JavaLangString.valueOf(int) や  JavaLangString.valueOf(long)})。 

The following is the list of \VDM\ classes with their methods
which implement a subset of \JAVA\ API.
This documents gives only the list.
Actual documentation can be found in the \JAVA\ documentation.
以下は、\JAVA\ APIのサブセットを実装するメソッド群をもつ、 \VDM\ クラスの一覧である。
本書では、一覧表のみ示してある。
実際の説明は、 \JAVA\ 文書内に見つけることができる。

\subsection{\texttt{java.lang}クラス群}

\subsubsection{\texttt{JavaLangArrayIndexOutOfBoundsException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangArrayIndexOutOfBoundsException : 
          () ==> JavaLangArrayIndexOutOfBoundsException
public  JavaLangArrayIndexOutOfBoundsException : 
          int  ==> JavaLangArrayIndexOutOfBoundsException
public  JavaLangArrayIndexOutOfBoundsException : 
          <NIL> ==> JavaLangArrayIndexOutOfBoundsException
public  JavaLangArrayIndexOutOfBoundsException : 
          JavaLangString ==> JavaLangArrayIndexOutOfBoundsException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangBoolean}クラス}
\begin{small}
\begin{verbatim}
public  static TRUE : JavaLangBoolean := new JavaLangBoolean(true);
public  static FALSE : JavaLangBoolean := new JavaLangBoolean(false);
public  static TYPE : JavaLangClass := 
          new JavaLangClass("boolean", <CLASS>, true);
public  JavaLangBoolean : bool  ==> JavaLangBoolean
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  JavaLangBoolean : <NIL> ==> JavaLangBoolean
public  booleanValue : () ==> bool
public  equals : JavaLangObject ==> bool
public  JavaLangBoolean : JavaLangString ==> JavaLangBoolean
public  static valueOf : JavaLangString ==> JavaLangBoolean
public  static getBoolean : JavaLangString ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangCharacter}クラス}
\begin{small}
\begin{verbatim}
public static MIN_RADIX : int := 2;
public static MAX_RADIX : int := 36;
public static MIN_VALUE : char:= '0';
public static MAX_VALUE : char:= 'f';
public  static getType : char  ==> int
public  static isSpace : char  ==> bool
public  static isDefined : char  ==> bool
public  static forDigit : int  * int  ==> char
public  static isLowerCase : char  ==> bool
public  static isTitleCase : char  ==> bool
public  static isUpperCase : char  ==> bool
public  static toLowerCase : char  ==> char
public  static toTitleCase : char  ==> char
public  static toUpperCase : char  ==> char
public  static isISOControl : char  ==> bool
public  static isJavaLetter : char  ==> bool
public  JavaLangCharacter : <NIL> ==> JavaLangCharacter
public  static getNumericValue : char  ==> int
public  static isJavaLetterOrDigit : char  ==> bool
public  static isJavaIdentifierPart : char  ==> bool
public  static isIdentifierIgnorable : char  ==> bool
public  static isJavaIdentifierStart : char  ==> bool
public  static isUnicodeIdentifierPart : char  ==> bool
public  static isUnicodeIdentifierStart : char  ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangClass}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangClass : <NIL> ==> JavaLangClass
public  JavaLangClass :  seq1 of char * 
            (<CLASS> | <INTERFACE>) * bool ==> JavaLangClass
public  getName : () ==> JavaLangString
public  isArray : () ==> bool
public  toString : () ==> JavaLangString
public  getClasses : () ==> map  int  to  JavaLangClass
public  getSigners : () ==> map  int  to  JavaLangObject
public  isInterface : () ==> bool
public  isPrimitive : () ==> bool
public  newInstance : () ==> JavaLangObject
public  getInterfaces : () ==> map  int  to  JavaLangClass
public  static forName : JavaLangString ==> JavaLangClass
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangClassCastException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangClassCastException : 
          () ==> JavaLangClassCastException
public  JavaLangClassCastException : 
          <NIL> ==> JavaLangClassCastException
public  JavaLangClassCastException : 
          JavaLangString ==> JavaLangClassCastException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangClassNotFoundException}クラス}
\begin{small}
\begin{verbatim}
public  getException : () ==> JavaLangThrowable
public  printStackTrace : () ==> ()
public  JavaLangClassNotFoundException : 
          () ==> JavaLangClassNotFoundException
public  JavaLangClassNotFoundException : 
          <NIL> ==> JavaLangClassNotFoundException
public  printStackTrace : JavaIoPrintStream ==> ()
public  printStackTrace : JavaIoPrintWriter ==> ()
public  JavaLangClassNotFoundException : 
          JavaLangString ==> JavaLangClassNotFoundException
public  JavaLangClassNotFoundException : JavaLangString * 
              JavaLangThrowable ==> JavaLangClassNotFoundException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangComparable}クラス}
\begin{small}
\begin{verbatim}
public  compareTo : JavaLangObject ==> int

\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangConversionBufferFullException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangConversionBufferFullException : 
          () ==> JavaLangConversionBufferFullException
public  JavaLangConversionBufferFullException : 
          <NIL> ==> JavaLangConversionBufferFullException
public  JavaLangConversionBufferFullException : 
          JavaLangString ==> JavaLangConversionBufferFullException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangDouble}クラス}
\begin{small}
\begin{verbatim}
public  static POSITIVE_INFINITY : real :=0;
public  static NEGATIVE_INFINITY : real :=0;
public  static NaN : real :=0;
public  static MAX_VALUE : real := 1.79769313486231570e+308;
public  static MIN_VALUE : real := 4.94065645841246544e-324;
public  static TYPE : JavaLangClass := 
          new JavaLangClass("double", <CLASS>, true);
public  isNaN : () ==> bool
public  static isNaN : real  ==> bool
public  JavaLangDouble : real  ==> JavaLangDouble
public  hashCode : () ==> int
public  intValue : () ==> int
public  toString : () ==> JavaLangString
public  byteValue : () ==> int
public  longValue : () ==> int
public  static toString : real  ==> JavaLangString
public  floatValue : () ==> real
public  isInfinite : () ==> bool
public  shortValue : () ==> int
public  JavaLangDouble : <NIL> ==> JavaLangDouble
public  doubleValue : () ==> real
public  static isInfinite : real  ==> bool
public  JavaLangDouble : JavaLangString ==> JavaLangDouble
public  equals : JavaLangObject ==> bool
public  static valueOf : JavaLangString ==> JavaLangDouble
public  compareTo : JavaLangObject ==> int
public  static doubleToLongBits : real  ==> int
public  static longBitsToDouble : int  ==> real
public  static parseDouble : JavaLangString ==> real
public  static doubleToRawLongBits : real  ==> int
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangException : () ==> JavaLangException
public  JavaLangException : <NIL> ==> JavaLangException
public  JavaLangException : JavaLangString ==> JavaLangException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangIllegalAccessException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangIllegalAccessException : 
          () ==> JavaLangIllegalAccessException
public  JavaLangIllegalAccessException : 
          <NIL> ==> JavaLangIllegalAccessException
public  JavaLangIllegalAccessException : 
          JavaLangString ==> JavaLangIllegalAccessException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangIllegalArgumentException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangIllegalArgumentException : 
          () ==> JavaLangIllegalArgumentException
public  JavaLangIllegalArgumentException : 
          <NIL> ==> JavaLangIllegalArgumentException
public  JavaLangIllegalArgumentException : 
          JavaLangString ==> JavaLangIllegalArgumentException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangIllegalStateException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangIllegalStateException : 
          () ==> JavaLangIllegalStateException
public  JavaLangIllegalStateException : 
          <NIL> ==> JavaLangIllegalStateException
public  JavaLangIllegalStateException : 
          JavaLangString ==> JavaLangIllegalStateException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangIndexOutOfBoundsException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangIndexOutOfBoundsException : 
          () ==> JavaLangIndexOutOfBoundsException
public  JavaLangIndexOutOfBoundsException : 
          <NIL> ==> JavaLangIndexOutOfBoundsException
public  JavaLangIndexOutOfBoundsException : 
          JavaLangString ==> JavaLangIndexOutOfBoundsException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangInstantiationException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangInstantiationException : 
          () ==> JavaLangInstantiationException
public  JavaLangInstantiationException : 
          <NIL> ==> JavaLangInstantiationException
public  JavaLangInstantiationException : 
          JavaLangString ==> JavaLangInstantiationException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangInteger}クラス}
\begin{small}
\begin{verbatim}
public  CLASS : JavaLangClass = 
          new JavaLangClass("JavaLangInteger", <CLASS>, false);
public  TYPE : JavaLangClass =
          new JavaLangClass("int", <CLASS>, true);
public  MIN_VALUE : int=-2147483648;
public  digits : map  int  to  char
static  public MAX_VALUE : int:=2147483647;
public  JavaLangInteger : ()  ==> JavaLangInteger
public  JavaLangInteger : int  ==> JavaLangInteger
public  JavaLangInteger : char  ==> JavaLangInteger
public  JavaLangInteger : JavaLangString ==> JavaLangInteger
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  intValue : () ==> int
public  toString : () ==> JavaLangString
public  byteValue : () ==> int
public  longValue : () ==> int
public  charValue : () ==> char
static  public toString : int  ==> JavaLangString
public  floatValue : () ==> real
public  shortValue : () ==> int
public  doubleValue : () ==> real
public  static toString_ : int  * int  ==> JavaLangString
public  JavaLangInteger : <NIL> ==> JavaLangInteger
public  static toHexString : int  ==> JavaLangString
public  static decode : JavaLangString ==> JavaLangInteger
public  equals : JavaLangObject ==> bool
public  static toOctalString : int  ==> JavaLangString
public  static valueOf : JavaLangString ==> JavaLangInteger
public  parseInt : JavaLangString ==> int
public  compareTo : JavaLangObject ==> int
public  compareToInt : JavaLangInteger ==> int
public  static getInteger : JavaLangString ==> JavaLangInteger
public  parseInt : JavaLangString * int  ==> int
public  static getInteger : JavaLangString * int  ==> JavaLangInteger
public  static getInteger : 
          JavaLangString * JavaLangInteger ==> JavaLangInteger
\end{verbatim}
\end{small}

\subsubsection{\texttt{J2VUTIL}クラス}
\begin{small}
\begin{verbatim}
public  BitOp: int * (<AND> | <OR> | <EXCLOR>) * int ==> int
public  ConcatStr: JavaLangString * JavaLangString ==> JavaLangString
public  toString : 
          int  | real | char | JavaLangObject ==> JavaLangString
public  toChar : int  | real | char ==> char
public  toInt : int  | real | char ==> int
public  toFloat : int  | real | char ==> real
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangNullPointerException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangNullPointerException : 
          () ==> JavaLangNullPointerException
public  JavaLangNullPointerException : 
          <NIL> ==> JavaLangNullPointerException
public  JavaLangNullPointerException : 
          JavaLangString ==> JavaLangNullPointerException
\end{verbatim}
\end{small}

\subsubsection{\texttt{Nullable}クラス}
\begin{small}
\begin{verbatim}
public  IsNil: () ==> bool
public  isNil: bool := false
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangNumber}クラス}
\begin{small}
\begin{verbatim}
public  intValue : () ==> int
public  byteValue : () ==> int
public  longValue : () ==> int
public  floatValue : () ==> real
public  shortValue : () ==> int
public  JavaLangNumber : <NIL> ==> JavaLangNumber
public  doubleValue : () ==> real
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangNumberFormatException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangNumberFormatException : 
          () ==> JavaLangNumberFormatException
public  JavaLangNumberFormatException : 
          <NIL> ==> JavaLangNumberFormatException
public  JavaLangNumberFormatException : 
          JavaLangString ==> JavaLangNumberFormatException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangObject}クラス}
\begin{small}
\begin{verbatim}
public JavaLangObject: <NIL> ==> JavaLangObject
public  JavaLangObject : () ==> JavaLangObject
public  wait : () ==> ()
public  clone : () ==> JavaLangObject
public  wait : int  ==> ()
public  notify : () ==> ()
public  wait : int  * int  ==> ()
protected  finalize : () ==> ()
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  notifyAll : () ==> ()
public  equals : JavaLangObject ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangRuntimeException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangRuntimeException : () ==> JavaLangRuntimeException
public  JavaLangRuntimeException : <NIL> ==> JavaLangRuntimeException
public  JavaLangRuntimeException : 
          JavaLangString ==> JavaLangRuntimeException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangString}クラス}
\begin{small}
\begin{verbatim}
public  CLASS : JavaLangClass =
          new JavaLangClass("JavaLangString", <CLASS>, false);
public  JavaLangString : seq of  char  ==> JavaLangString
public  JavaLangString : JavaLangString ==> JavaLangString
public  getClass : () ==> JavaLangClass
public  toSeqOfChar : () ==> seq of  char
public  JavaLangString: <NIL> ==> JavaLangString
public  trim: () ==> JavaLangString
public  JavaLangString : () ==> JavaLangString
public  intern : () ==> JavaLangString
public  length : () ==> int
public  charAt : int  ==> char
public  getBytes : () ==> map  int  to  int
public  hashCode : () ==> int
public  indexOf : int | char ==> int
public  toString : () ==> JavaLangString
public  indexOf : int  * int  ==> int
public  replace : char  * char  ==> JavaLangString
public  substring : int * int ==> JavaLangString
public  substring : int  ==> JavaLangString
public  JavaLangString : map  int  to  char  ==> JavaLangString
public  JavaLangString : map  int  to  int  ==> JavaLangString
public  toCharArray : () ==> map  int  to  char
public  toLowerCase : () ==> JavaLangString
public  toUpperCase : () ==> JavaLangString
public  lastIndexOf : int  ==> int
public  JavaLangString : 
          map  int  to  int  * int  ==> JavaLangString
public  lastIndexOf : int  * int  ==> int
public  JavaLangString : 
          (map  int  to  char)  * int  * int  ==> JavaLangString
public  JavaLangString : 
          map  int  to  int  * int  * int  ==> JavaLangString
public  concat : JavaLangString ==> JavaLangString
public  concat' : seq of char ==> ()
public  static copyValueOf : map  int  to  char  ==> JavaLangString
public  equals: JavaLangObject ==> bool
public  JavaLangString : 
          map  int  to  int  * int  * int  * int  ==> JavaLangString
public  endsWith : JavaLangString ==> bool
public  getBytes : JavaLangString ==> map  int  to  int
public  compareTo : JavaLangObject ==> int
public  getBytes : int  * int  * map  int  to  int  * int  ==> ()
public  getChars : int  * int  * map  int  to  char  * int  ==> ()
public  indexOf : JavaLangString  ==> int
public  indexOf : JavaLangString * int  ==> int
public  static copyValueOf : 
          map  int  to  char  * int  * int  ==> JavaLangString
public  startsWith : JavaLangString * int  ==> bool
public  startsWith : JavaLangString ==> bool
public  lastIndexOf : JavaLangString ==> int
public  lastIndexOf : JavaLangString * int ==> int
public  JavaLangString : 
          map  int  to  int  * JavaLangString ==> JavaLangString
public  JavaLangString : map  int  to  int  * 
                   int  * int  * JavaLangString ==> JavaLangString
public  equalsIgnoreCase : JavaLangString ==> bool
public  compareToIgnoreCase: JavaLangString ==> int
public  regionMatches : int  * JavaLangString * int  * int  ==> bool
public  regionMatches : 
              bool  * int  * JavaLangString * int  * int  ==> bool
public  static  valueOf : 
              map  int  to  char  * int  * int  ==> JavaLangString
public  static  valueOf : map  int  to  char  ==> JavaLangString
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangStringBuffer}クラス}
\begin{small}
\begin{verbatim}
public  CLASS : JavaLangClass =
          new JavaLangClass("JavaLangString", <CLASS>, false);
public  JavaLangStringBuffer : <NIL> ==> JavaLangStringBuffer
public  getClass : () ==> JavaLangClass
public  toString : () ==> JavaLangString
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangSystem}クラス}
\begin{small}
\begin{verbatim}
private  static  props : JavaUtilProperties := 
           new JavaUtilProperties(<NIL>);
public  static  out : JavaIoPrintStream := 
  new JavaIoPrintStream(new JavaIoFileOutputStream("stdout", true), true);
public  static  err : JavaIoPrintStream := 
  new JavaIoPrintStream(new JavaIoFileOutputStream("stderr", true), true);
public  static  gc : () ==> ()
public  JavaLangSystem : () ==> JavaLangSystem
public  static  exit__ : int  ==> ()
public  static  load : JavaLangString ==> ()
public  static  getProperties : () ==> JavaUtilProperties
public  static  getenv : JavaLangString ==> JavaLangString
public  static  runFinalization : () ==> ()
public  static  currentTimeMillis : () ==> int
public  static  getProperty : JavaLangString ==> JavaLangString
public  static  loadLibrary : JavaLangString ==> ()
public  static  runFinalizersOnExit : bool  ==> ()
public  static  mapLibraryName : JavaLangString ==> JavaLangString
public  static  identityHashCode : JavaLangObject ==> int
public  static  getProperty : 
          JavaLangString * JavaLangString ==> JavaLangString
public  static  setProperty : 
          JavaLangString * JavaLangString ==> JavaLangString
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangThrowable}クラス}
\begin{small}
\begin{verbatim}
public  toString : () ==> JavaLangString
public  JavaLangThrowable : () ==> JavaLangThrowable
public  getMessage : () ==> JavaLangString
public  JavaLangThrowable : <NIL> ==> JavaLangThrowable
public  printStackTrace : () ==> ()
public  fillInStackTrace : () ==> JavaLangThrowable
public  JavaLangThrowable : JavaLangString ==> JavaLangThrowable
public  getLocalizedMessage : () ==> JavaLangString
public  printStackTrace : JavaIoPrintStream ==> ()
public  printStackTrace : JavaIoPrintWriter ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaLangUnsupportedOperationException}クラス}
\begin{small}
\begin{verbatim}
public  JavaLangUnsupportedOperationException : 
          () ==> JavaLangUnsupportedOperationException
public  JavaLangUnsupportedOperationException : 
          <NIL> ==> JavaLangUnsupportedOperationException
public  JavaLangUnsupportedOperationException : 
          JavaLangString ==> JavaLangUnsupportedOperationException
\end{verbatim}
\end{small}

\subsection{\texttt{java.util}クラス群}

\subsubsection{\texttt{JavaUtilALItr}クラス}
\begin{small}
\begin{verbatim}
protected  cursor : int := 0;
protected  lastRet : int := -1;
protected  expectedModCount : int;
protected  al : JavaUtilAbstractList;
public  hasNext : () ==> bool
public  next : () ==> JavaLangObject
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilALListItr}クラス}
\begin{small}
\begin{verbatim}
public  hasPrevious: () ==> bool
public  previous : () ==> JavaLangObject
public  nextIndex : () ==> int
public  previousIndex : () ==> int
public  set__ : JavaLangObject ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilAbstractCollection}クラス}
\begin{small}
\begin{verbatim}
public  clear : () ==> ()
public  isEmpty : () ==> bool
public  toArray : () ==> map  int  to  JavaLangObject
public  toString : () ==> JavaLangString
public  contains : JavaLangObject ==> bool
public  addAll : JavaUtilCollection ==> bool
public  removeAll : JavaUtilCollection ==> bool
public  retainAll : JavaUtilCollection ==> bool
public  JavaUtilAbstractCollection : 
          <NIL> ==> JavaUtilAbstractCollection
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilAbstractList}クラス}
\begin{small}
\begin{verbatim}
public  modCount : int  := 0
public  get : int  ==> JavaLangObject
public  clear : () ==> ()
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  iterator : () ==> JavaUtilIterator
public  add : JavaLangObject ==> bool
public  listIterator : () ==> JavaUtilListIterator
public  listIterator : int  ==> JavaUtilListIterator
public  equals : JavaLangObject ==> bool
protected  removeRange : int  * int  ==> ()
public  indexOf : JavaLangObject ==> int
public  set__ : int  * JavaLangObject ==> JavaLangObject
public  JavaUtilAbstractList : <NIL> ==> JavaUtilAbstractList
public  lastIndexOf : JavaLangObject ==> int
protected  cursor : int := 0;
protected  lastRet : int := -1;
protected  expectedModCount : int;
protected  al : JavaUtilAbstractList;
public  hasNext : () ==> bool
public  next : () ==> JavaLangObject
public  hasPrevious : () ==> bool
public  previous : () ==> JavaLangObject
public  nextIndex : () ==> int
public  previousIndex : () ==> int
public  set__ : JavaLangObject ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilAbstractMap}クラス}
\begin{small}
\begin{verbatim}
public  size : () ==> int
public  clear : () ==> ()
public  keySet : () ==> JavaUtilSet
public  isEmpty : () ==> bool
public  entrySet : () ==> JavaUtilSet
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  values__ : () ==> JavaUtilCollection
protected  JavaUtilAbstractMap : () ==> JavaUtilAbstractMap
public  get : JavaLangObject ==> JavaLangObject
public  putAll : JavaUtilMap ==> ()
public  equals : JavaLangObject ==> bool
public  remove : JavaLangObject ==> JavaLangObject
public  JavaUtilAbstractMap : <NIL> ==> JavaUtilAbstractMap
public  containsKey : JavaLangObject ==> bool
public  put : JavaLangObject * JavaLangObject ==> JavaLangObject
public  containsValue : JavaLangObject ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilAbstractSet}クラス}
\begin{small}
\begin{verbatim}
public  hashCode : () ==> int
public  JavaUtilAbstractSet : () ==> JavaUtilAbstractSet
public  equals : JavaLangObject ==> bool
public  JavaUtilAbstractSet : <NIL> ==> JavaUtilAbstractSet
public  removeAll : JavaUtilCollection ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilCollection}クラス}
\begin{small}
\begin{verbatim}
public  size : () ==> int
public  clear : () ==> ()
public  isEmpty : () ==> bool
public  hashCode : () ==> int
public  iterator : () ==> JavaUtilIterator
public  equals : JavaLangObject ==> bool
public  contains : JavaLangObject ==> bool
public  addAll : JavaUtilCollection ==> bool
public  removeAll : JavaUtilCollection ==> bool
public  retainAll : JavaUtilCollection ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilConcurrentModificationException}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilConcurrentModificationException : 
          () ==> JavaUtilConcurrentModificationException
public  JavaUtilConcurrentModificationException : 
          <NIL> ==> JavaUtilConcurrentModificationException
public  JavaUtilConcurrentModificationException : 
          JavaLangString ==> JavaUtilConcurrentModificationException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilDate}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilDate : () ==> JavaUtilDate
public  JavaUtilDate : int  ==> JavaUtilDate
public  clone : () ==> JavaLangObject
public  getDay : () ==> int
public  getDate : () ==> int
public  getTime : () ==> int
public  getYear : () ==> int
public  getHours : () ==> int
public  getMonth : () ==> int
public  hashCode : () ==> int
public  setDate : int  ==> ()
public  setTime : int  ==> ()
public  setYear : int  ==> ()
public  toString : () ==> JavaLangString
public  JavaUtilDate : <NIL> ==> JavaUtilDate
public  JavaUtilDate : int  * int  * int  ==> JavaUtilDate
public  setHours : int  ==> ()
public  setMonth : int  ==> ()
public  getMinutes : () ==> int
public  getSeconds : () ==> int
public  after : JavaUtilDate ==> bool
public  setMinutes : int  ==> ()
public  setSeconds : int  ==> ()
public  toGMTString : () ==> JavaLangString
public  JavaUtilDate : JavaLangString ==> JavaUtilDate
public  before : JavaUtilDate ==> bool
public  JavaUtilDate : int  * int  * int  * int  * int  ==> JavaUtilDate
public  static parse : JavaLangString ==> int
public  static UTC : int  * int  * int  * int  * int  * int  ==> int
public  equals : JavaLangObject ==> bool
public  toLocaleString : () ==> JavaLangString
public  JavaUtilDate : 
          int  * int  * int  * int  * int  * int  ==> JavaUtilDate
public  compareTo : JavaLangObject ==> int
public  getTimezoneOffset : () ==> int
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilDictionary}クラス}
\begin{small}
\begin{verbatim}
public  isEmpty : () ==> bool
public  JavaUtilDictionary : <NIL> ==> JavaUtilDictionary
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilEmptyEnumerator}クラス}
\begin{small}
\begin{verbatim}
public  nextElement : () ==> JavaLangObject
public  JavaUtilEmptyEnumerator : () ==> JavaUtilEmptyEnumerator
public  hasMoreElements : () ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilEmptyIterator}クラス}
\begin{small}
\begin{verbatim}
public  next : () ==> JavaLangObject
public  remove : () ==> ()
public  hasNext : () ==> bool
public  JavaUtilEmptyIterator : () ==> JavaUtilEmptyIterator
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilEmptyStackException}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilEmptyStackException : 
          () ==> JavaUtilEmptyStackException
public  JavaUtilEmptyStackException : 
          <NIL> ==> JavaUtilEmptyStackException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilEntry}クラス}
\begin{small}
\begin{verbatim}
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  equals : JavaLangObject ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilEnumeration}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilEnumeration : <NIL> ==> JavaUtilEnumeration
public  nextElement : () ==> JavaLangObject
public  hasMoreElements : () ==> bool
protected  expectedModCount : int;
public  remove : () ==> ()
public  hasNext : () ==> bool
public  nextElement : () ==> JavaLangObject
public  JavaUtilEnumerator : 
          int  * bool * JavaUtilHashtable ==> JavaUtilEnumerator
public  JavaUtilEnumerator : <NIL> ==> JavaUtilEnumerator
public  hasMoreElements : () ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilHTEntry}クラス}
\begin{small}
\begin{verbatim}
public  hash : int ;
public  key : JavaLangObject;
public  value__ : JavaLangObject;
public  next : JavaUtilHTEntry
public  clone : () ==> JavaLangObject
public  getKey : () ==> JavaLangObject
public  getValue : () ==> JavaLangObject
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  JavaUtilHTEntry : <NIL> ==> JavaUtilHTEntry
public  equals : JavaLangObject ==> bool
public  setValue : JavaLangObject ==> JavaLangObject
public  JavaUtilHTEntry : int  * JavaLangObject * 
                 JavaLangObject * JavaUtilHTEntry ==> JavaUtilHTEntry
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilHTKeySet}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilHTKeySet : JavaUtilHashtable ==> JavaUtilHTKeySet
public  iterator : () ==> JavaUtilIterator
public  size : () ==> int
public  contains : JavaLangObject ==> bool
public  remove : JavaLangObject ==> bool
public  clear : () ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilHashMap}クラス}
\begin{small}
\begin{verbatim}
public  hash : int;
public  key : JavaLangObject;
public  value__: JavaLangObject;
public  next : HMEntry;
public  HMEntry : <NIL> ==> HMEntry
public  clone : () ==> JavaLangObject
public  getKey : () ==> JavaLangObject
public  getValue : () ==> JavaLangObject
public  setValue : JavaLangObject ==> JavaLangObject
public  equals : JavaLangObject ==> bool
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  table : map int to HMEntry;
public  count : int :=0;
public  threshold : int;
public  loadFactor_ : real;
public  modCount : int := 0;
public  static  KEYS : int := 0;
public  static  VALUES : int := 1;
public  static  ENTRIES : int := 2;
public  size : () ==> int
public  clear : () ==> ()
public  clone : () ==> JavaLangObject
public  keySet : () ==> JavaUtilSet
public  getHashIterator : int ==> JavaUtilIterator
public  JavaUtilHashMap : () ==> JavaUtilHashMap
public  isEmpty : () ==> bool
public  JavaUtilHashMap : int  ==> JavaUtilHashMap
public  entrySet : () ==> JavaUtilSet
public  values__ : () ==> JavaUtilCollection
public  JavaUtilHashMap : int  * real  ==> JavaUtilHashMap
public  get : JavaLangObject ==> JavaLangObject
public  putAll : JavaUtilMap ==> ()
public  JavaUtilHashMap : JavaUtilMap ==> JavaUtilHashMap
public  JavaUtilHashMap : <NIL> ==> JavaUtilHashMap
public  remove : JavaLangObject ==> JavaLangObject
public  containsKey : JavaLangObject ==> bool
public  put : JavaLangObject * JavaLangObject ==> JavaLangObject
protected  rehash : () ==> ()
public  containsValue : JavaLangObject ==> bool
public  HMKeySet: JavaUtilHashMap ==> HMKeySet
public  iterator : () ==> JavaUtilIterator
public  size : () ==> int
public  contains : JavaLangObject ==> bool
public  remove : JavaLangObject ==> bool
public  clear : () ==> ()
public  HMEntrySet : JavaUtilHashMap ==> HMEntrySet
public  iterator : () ==> JavaUtilIterator
public  size : () ==> int
public  contains : JavaLangObject ==> bool
public  remove : JavaLangObject ==> bool
public  clear : () ==> ()
public  next : () ==> JavaLangObject
public  remove : () ==> ()
public  hasNext : () ==> bool
public  EmptyHashIterator : () ==> EmptyHashIterator
public  HashIterator: int * JavaUtilHashMap ==> HashIterator
public  hasNext : () ==> bool
public  next : () ==> JavaLangObject
public  remove : () ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilHashSet}クラス}
\begin{small}
\begin{verbatim}
public  size : () ==> int
public  clear : () ==> ()
public  clone : () ==> JavaLangObject
public  JavaUtilHashSet : () ==> JavaUtilHashSet
public  isEmpty : () ==> bool
public  JavaUtilHashSet : int  ==> JavaUtilHashSet
public  iterator : () ==> JavaUtilIterator
public  JavaUtilHashSet : int  * real  ==> JavaUtilHashSet
public  add : JavaLangObject ==> bool
public  JavaUtilHashSet : <NIL> ==> JavaUtilHashSet
public  remove : JavaLangObject ==> bool
public  contains : JavaLangObject ==> bool
public  JavaUtilHashSet : JavaUtilCollection ==> JavaUtilHashSet
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilHashtable}クラス}
\begin{small}
\begin{verbatim}
public  static  KEYS : int := 0;
public  static  VALUES : int := 1;
public  static  ENTRIES : int := 2;
public  table : map  int  to  JavaUtilHTEntry;
public  count : int := 0;
public  modCount : int  := 0;
public  keys : () ==> JavaUtilEnumeration
public  size : () ==> int
public  clear : () ==> ()
public  clone : () ==> JavaLangObject
public  keySet : () ==> JavaUtilSet
protected  rehash : () ==> ()
public  isEmpty : () ==> bool
public  elements : () ==> JavaUtilEnumeration
public  entrySet : () ==> JavaUtilSet
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  values__ : () ==> JavaUtilCollection
public  JavaUtilHashtable : () ==> JavaUtilHashtable
public  JavaUtilHashtable : int  ==> JavaUtilHashtable
public  get : JavaLangObject ==> JavaLangObject
public  putAll : JavaUtilMap ==> ()
public  JavaUtilHashtable : int * real  ==> JavaUtilHashtable
public  getIterator : int  ==> JavaUtilIterator
public  JavaUtilHashtable : <NIL> ==> JavaUtilHashtable
public  equals : JavaLangObject ==> bool
public  remove : JavaLangObject ==> JavaLangObject
public  contains : JavaLangObject ==> bool
public  containsKey : JavaLangObject ==> bool
public  put : JavaLangObject * JavaLangObject ==> JavaLangObject
public  containsValue : JavaLangObject ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilIterator}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilIterator : <NIL> ==> JavaUtilIterator
public  next : () ==> JavaLangObject
public  remove : () ==> ()
public  hasNext : () ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilList}クラス}
\begin{small}
\begin{verbatim}
public  get : int  ==> JavaLangObject
public  size : () ==> int
public  clear : () ==> ()
public  isEmpty : () ==> bool
public  toArray : () ==> map  int  to  JavaLangObject
public  hashCode : () ==> int
public  iterator : () ==> JavaUtilIterator
public  subList : int  * int  ==> JavaUtilList
public  equals : JavaLangObject ==> bool
public  indexOf : JavaLangObject ==> int
public  set__ : int  * JavaLangObject ==> JavaLangObject
public  contains : JavaLangObject ==> bool
public  addAll : JavaUtilCollection ==> bool
public  lastIndexOf : JavaLangObject ==> int
public  toArray : map  int  to  JavaLangObject ==> 
                                map  int  to  JavaLangObject
public  addAll : int  * JavaUtilCollection ==> bool
public  removeAll : JavaUtilCollection ==> bool
public  retainAll : JavaUtilCollection ==> bool
public  containsAll : JavaUtilCollection ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilListIterator}クラス}
\begin{small}
\begin{verbatim}
public  next : () ==> JavaLangObject
public  remove : () ==> ()
public  hasNext : () ==> bool
public  previous : () ==> JavaLangObject
public  nextIndex : () ==> int
public  add : JavaLangObject ==> ()
public  hasPrevious : () ==> bool
public  previousIndex : () ==> int
public  set__ : JavaLangObject ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilLocale}クラス}
\begin{small}
\begin{verbatim}
public  static  ENGLISH : [JavaUtilLocale] := nil;
public  static  FRENCH : [JavaUtilLocale] := nil;
public  static  GERMAN : [JavaUtilLocale] := nil;
public  static  ITALIAN : [JavaUtilLocale] := nil;
public  static  JAPANESE : [JavaUtilLocale] := nil;
public  static  KOREAN : [JavaUtilLocale] := nil;
public  static  CHINESE : [JavaUtilLocale] := nil;
public  static  SIMPLIFIED_CHINESE : [JavaUtilLocale] := nil;
public  static  TRADITIONAL_CHINESE : [JavaUtilLocale] := nil;
public  static  FRANCE : [JavaUtilLocale] := nil;
public  static  GERMANY : [JavaUtilLocale] := nil;
public  static  ITALY : [JavaUtilLocale] := nil;
public  static  JAPAN : [JavaUtilLocale] := nil;
public  static  KOREA : [JavaUtilLocale] := nil;
public  static  CHINA : [JavaUtilLocale] := nil;
public  static  PRC : [JavaUtilLocale] := nil;
public  static  TAIWAN : [JavaUtilLocale] := nil;
public  static  UK : [JavaUtilLocale] := nil;
public  static  US : [JavaUtilLocale] := nil;
public  static  CANADA : [JavaUtilLocale] := nil;
public  static  CANADA_FRENCH : [JavaUtilLocale] := nil;
public  clone : () ==> JavaLangObject
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  getCountry : () ==> JavaLangString
public  static  getDefault : () ==> JavaUtilLocale
public  getVariant : () ==> JavaLangString
public  JavaUtilLocale : <NIL> ==> JavaUtilLocale
public  getLanguage : () ==> JavaLangString
public  equals : JavaLangObject ==> bool
public  getDisplayName : () ==> JavaLangString
public  getISO3Country : () ==> JavaLangString
public  getISO3Language : () ==> JavaLangString
public  static  getISOCountries : () ==> map  int  to  JavaLangString
public  static  getISOLanguages : () ==> map  int  to  JavaLangString
public  getDisplayCountry : () ==> JavaLangString
public  getDisplayVariant : () ==> JavaLangString
public  getDisplayLanguage : () ==> JavaLangString
public  static setDefault : JavaUtilLocale ==> ()
public  static getAvailableLocales : 
          () ==> map  int  to  JavaUtilLocale
public  getDisplayName : JavaUtilLocale ==> JavaLangString
public  JavaUtilLocale : 
          JavaLangString * JavaLangString ==> JavaUtilLocale
public  getDisplayCountry : JavaUtilLocale ==> JavaLangString
public  getDisplayVariant : JavaUtilLocale ==> JavaLangString
public  getDisplayLanguage : JavaUtilLocale ==> JavaLangString
public  JavaUtilLocale : JavaLangString * JavaLangString * 
                                    JavaLangString ==> JavaUtilLocale
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilMap}クラス}
\begin{small}
\begin{verbatim}
public  size : () ==> int
public  clear : () ==> ()
public  keySet : () ==> JavaUtilSet
public  isEmpty : () ==> bool
public  get : JavaLangObject ==> JavaLangObject
public  containsKey : JavaLangObject ==> bool
public  put : JavaLangObject * JavaLangObject ==> JavaLangObject
public  containsValue : JavaLangObject ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilMissingResourceException}クラス}
\begin{small}
\begin{verbatim}
public  getKey : () ==> JavaLangString
public  getClassName : () ==> JavaLangString
public  JavaUtilMissingResourceException : 
          <NIL> ==> JavaUtilMissingResourceException
public  JavaUtilMissingResourceException : 
          JavaLangString * JavaLangString * JavaLangString ==> 
                                JavaUtilMissingResourceException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilNoSuchElementException}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilNoSuchElementException : 
          () ==> JavaUtilNoSuchElementException
public  JavaUtilNoSuchElementException : 
          <NIL> ==> JavaUtilNoSuchElementException
public  JavaUtilNoSuchElementException : 
          JavaLangString ==> JavaUtilNoSuchElementException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilObservable}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilObservable : () ==> JavaUtilObservable
public  hasChanged : () ==> bool
protected  setChanged : () ==> ()
protected  clearChanged : () ==> ()
public  countObservers : () ==> int
public  JavaUtilObservable : <NIL> ==> JavaUtilObservable
public  deleteObservers : () ==> ()
public  notifyObservers : () ==> ()
public  addObserver : JavaUtilObserver ==> ()
public  notifyObservers : JavaLangObject ==> ()
public  deleteObserver : JavaUtilObserver ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilObserver}クラス}
\begin{small}
\begin{verbatim}
public  JavaUtilObserver : <NIL> ==> JavaUtilObserver
public  update : JavaUtilObservable * JavaLangObject ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilProperties}クラス}
\begin{small}
\begin{verbatim}
protected  defaults : JavaUtilProperties;
public  JavaUtilProperties : () ==> JavaUtilProperties
public  propertyNames : () ==> JavaUtilEnumeration
public  JavaUtilProperties : <NIL> ==> JavaUtilProperties
public  list : JavaIoPrintStream ==> ()
public  load : JavaIoInputStream ==> ()
public  getProperty : JavaLangString ==> JavaLangString
public  JavaUtilProperties : JavaUtilProperties ==> JavaUtilProperties
public  save : JavaIoOutputStream * JavaLangString ==> ()
public  getProperty : JavaLangString * JavaLangString ==> JavaLangString
public  setProperty : JavaLangString * JavaLangString ==> JavaLangObject
public  store : JavaIoOutputStream * JavaLangString ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilResourceBundle}クラス}
\begin{small}
\begin{verbatim}
protected  parent : JavaUtilResourceBundle
public  getKeys : () ==> JavaUtilEnumeration
public  getLocale : () ==> JavaUtilLocale
public  JavaUtilResourceBundle : () ==> JavaUtilResourceBundle
public  static getBundle : JavaLangString ==> JavaUtilResourceBundle
public  getObject : JavaLangString ==> JavaLangObject
public  getString : JavaLangString ==> JavaLangString
public  JavaUtilResourceBundle : <NIL> ==> JavaUtilResourceBundle
public  getStringArray : JavaLangString ==> map  int  to  JavaLangString
protected  handleGetObject : JavaLangString ==> JavaLangObject
protected  setParent : JavaUtilResourceBundle ==> ()
public  static  getBundle : JavaLangString * 
                       JavaUtilLocale ==> JavaUtilResourceBundle
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilSet}クラス}
\begin{small}
\begin{verbatim}
public  clear : () ==> ()
public  isEmpty : () ==> bool
public  toArray : () ==> map  int  to  JavaLangObject
public  hashCode : () ==> int
public  iterator : () ==> JavaUtilIterator
public  add : JavaLangObject ==> bool
public  equals : JavaLangObject ==> bool
public  contains : JavaLangObject ==> bool
public  addAll : JavaUtilCollection ==> bool
public  toArray : map  int  to  JavaLangObject ==> 
                                map  int  to  JavaLangObject
public  removeAll : JavaUtilCollection ==> bool
public  retainAll : JavaUtilCollection ==> bool
public  containsAll : JavaUtilCollection ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilStack}クラス}
\begin{small}
\begin{verbatim}
public  pop : () ==> JavaLangObject
public  peek : () ==> JavaLangObject
public  JavaUtilStack : () ==> JavaUtilStack
public  empty : () ==> bool
public  getClass : () ==> JavaLangClass
public  JavaUtilStack : <NIL> ==> JavaUtilStack
public  push : JavaLangObject ==> JavaLangObject
public  search : JavaLangObject ==> int
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilStringTokenizer}クラス}
\begin{small}
\begin{verbatim}
public  nextToken : () ==> JavaLangString
public  countTokens : () ==> int
public  nextElement : () ==> JavaLangObject
public  hasMoreTokens : () ==> bool
public  hasMoreElements : () ==> bool
public  nextToken : JavaLangString ==> JavaLangString
public  JavaUtilStringTokenizer : <NIL> ==> JavaUtilStringTokenizer
public  JavaUtilStringTokenizer : 
          JavaLangString ==> JavaUtilStringTokenizer
public  JavaUtilStringTokenizer : J
          avaLangString * JavaLangString ==> JavaUtilStringTokenizer
public  JavaUtilStringTokenizer : JavaLangString * 
              JavaLangString * bool  ==> JavaUtilStringTokenizer
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaUtilVector}クラス}
\begin{small}
\begin{verbatim}
public  insertElementAt : JavaLangObject * int ==> ()
public  clear : () ==> ()
public  clone : () ==> JavaLangObject
public  contains : JavaLangObject ==> bool
public  containsAll : JavaUtilCollection ==> bool
public  elementAt : int ==> JavaLangObject
public  firstElement : () ==> JavaLangObject
public  get : int ==> JavaLangObject
public  isEmpty : () ==> bool
public  indexOf : JavaLangObject ==> int
public  indexOfFrom : JavaLangObject * int ==> int
public  lastElement : () ==> JavaLangObject
public  remove : int ==> JavaLangObject
public  remove' : JavaLangObject ==> bool
public  removeElementAt : int ==> ()
public  removeElement : JavaLangObject ==> bool
public  removeAll : JavaUtilCollection ==> bool
public  retainAll : JavaUtilCollection ==> bool
public  subList : int * int ==> JavaUtilList
public  elements : () ==> JavaUtilEnumeration
public  VEnumeration : JavaUtilVector ==> VEnumeration
public  hasMoreElements : () ==> bool
public  nextElement : () ==> JavaLangObject
\end{verbatim}
\end{small}

\subsection{\texttt{java.io}クラス群}

\subsubsection{\texttt{JavaIoBufferedInputStream}クラス}
\begin{small}
\begin{verbatim}
protected  buf : map  int  to  int ;
protected  count : int ;
protected  pos : int ;
protected  markpos : int  := -1;
protected  marklimit : int
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  reset : () ==> ()
public  skip__ : int  ==> int
public  getClass : () ==> JavaLangClass
public  available : () ==> int
public  markSupported : () ==> bool
public  read : map  int  to  int  * int  * int  ==> int
public  readMIIIntInt' : map  int  to  int  * 
                     int  * int  ==> int * map  int  to  int
public  JavaIoBufferedInputStream : 
          <NIL> ==> JavaIoBufferedInputStream
public  JavaIoBufferedInputStream : 
          JavaIoInputStream ==> JavaIoBufferedInputStream
public  JavaIoBufferedInputStream : 
          JavaIoInputStream * int  ==> JavaIoBufferedInputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoBufferedOutputStream}クラス}
\begin{small}
\begin{verbatim}
protected  buf : map  int  to  int ;
protected  count : int
public  flush : () ==> ()
public  write : int  ==> ()
public  getClass : () ==> JavaLangClass
public  write2 : map  int  to  int  * int  * int  ==> ()
public  JavaIoBufferedOutputStream : 
          <NIL> ==> JavaIoBufferedOutputStream
public  JavaIoBufferedOutputStream : 
          JavaIoOutputStream ==> JavaIoBufferedOutputStream
public  JavaIoBufferedOutputStream : 
          JavaIoOutputStream * int  ==> JavaIoBufferedOutputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoBufferedReader}クラス}
\begin{small}
\begin{verbatim}
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  ready : () ==> bool
public  reset : () ==> ()
public  skip__ : int  ==> int
public  readLine : () ==> JavaLangString
public  markSupported : () ==> bool
public  read : map  int  to  char  * int  * int  ==> int
public  read' : map  int  to  char  * 
               int  * int  ==> int * map  int  to  char
public  JavaIoBufferedReader : <NIL> ==> JavaIoBufferedReader
public  JavaIoBufferedReader : JavaIoReader ==> JavaIoBufferedReader
public  JavaIoBufferedReader : 
          JavaIoReader * int  ==> JavaIoBufferedReader
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoBufferedWriter}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  flush : () ==> ()
public  write : int  ==> ()
public  newLine : () ==> ()
public  flushBuffer : () ==> ()
public  write : (map  int  to  char | JavaLangString)  * 
                                                 int  * int  ==> ()
public  writeICMIntInt : map  int  to  char  * int  * int  ==> ()
public  writeStrIntInt : JavaLangString * int  * int  ==> ()
public  JavaIoBufferedWriter : <NIL> ==> JavaIoBufferedWriter
public  JavaIoBufferedWriter : JavaIoWriter ==> JavaIoBufferedWriter
public  JavaIoBufferedWriter : 
          JavaIoWriter * int  ==> JavaIoBufferedWriter
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoByteArrayInputStream}クラス}
\begin{small}
\begin{verbatim}
protected  buf : map  int  to  int ;
protected  pos : int ;
protected  mark_ : int  := 0;
protected  count : int
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  reset : () ==> ()
public  skip__ : int  ==> int
public  getClass : () ==> JavaLangClass
public  available : () ==> int
public  markSupported : () ==> bool
public  read : map  int  to  int  * int  * int  ==> int
public  readMIIIntInt' : map  int  to  int  * int  * int  ==> 
                                             int * map  int  to  int
public  JavaIoByteArrayInputStream : 
          map  int  to  int  ==> JavaIoByteArrayInputStream
public  JavaIoByteArrayInputStream : <NIL> ==> JavaIoByteArrayInputStream
public  JavaIoByteArrayInputStream : 
          map  int  to  int  * int  * int  ==> JavaIoByteArrayInputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoCharArrayReader}クラス}
\begin{small}
\begin{verbatim}
protected  buf : map  int  to  char ;
protected  pos : int ;
protected  markedPos : int  := 0;
protected  count : int
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  ready : () ==> bool
public  reset : () ==> ()
public  skip__ : int  ==> int
public  getClass : () ==> JavaLangClass
public  markSupported : () ==> bool
public  read : map  int  to  char  * int  * int  ==> 
                                      int * map  int  to  char
public  JavaIoCharArrayReader : 
          map  int  to  char  ==> JavaIoCharArrayReader
public  JavaIoCharArrayReader : <NIL> ==> JavaIoCharArrayReader
public  JavaIoCharArrayReader : 
          map  int  to  char  * int  * int  ==> JavaIoCharArrayReader
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFile}クラス}
\begin{small}
\begin{verbatim}
public  static  separatorChar : char  := fs.getSeparator();
public  static  separator : JavaLangString := 
            new JavaLangString([fs.getSeparator()]);
public  static  pathSeparatorChar : char  := 
                              fs.getPathSeparator();
public  static  pathSeparator : JavaLangString := 
             new JavaLangString([fs.getPathSeparator()]);
public  list : () ==> map  int  to  JavaLangString
public  mkdir : () ==> bool
public  toURL : () ==> JavaNetURL
public  delete : () ==> bool
public  isFile : () ==> bool
public  length : () ==> int
public  mkdirs : () ==> bool
public  canRead : () ==> bool
public  getName : () ==> JavaLangString
public  getPath : () ==> JavaLangString
public  canWrite : () ==> bool
public  exists__ : () ==> bool
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  isHidden : () ==> bool
public  toString : () ==> JavaLangString
public  JavaIoFile : <NIL> ==> JavaIoFile
public  getParent : () ==> JavaLangString
public  listFiles : () ==> map  int  to  JavaIoFile
public  static listRoots : () ==> map  int  to  JavaIoFile
public  isAbsolute : () ==> bool
public  isDirectory : () ==> bool
public  setReadOnly : () ==> bool
public  JavaIoFile : JavaLangString ==> JavaIoFile
public  deleteOnExit : () ==> ()
public  lastModified : () ==> int
public  createNewFile : () ==> bool
public  getParentFile : () ==> JavaIoFile
public  JavaIoFile : JavaLangString * int  ==> JavaIoFile
public  JavaIoFile : JavaIoFile * JavaLangString ==> JavaIoFile
public  equals : JavaLangObject ==> bool
public  renameTo : JavaIoFile ==> bool
public  getAbsoluteFile : () ==> JavaIoFile
public  getAbsolutePath : () ==> JavaLangString
public  getCanonicalFile : () ==> JavaIoFile
public  getCanonicalPath : () ==> JavaLangString
public  setLastModified : int  ==> bool
public  compareTo : JavaLangObject ==> int
public  JavaIoFile : JavaLangString * JavaLangString ==> JavaIoFile
public  static createTempFile : 
          JavaLangString * JavaLangString ==> JavaIoFile
public  static createTempFile : 
          JavaLangString * JavaLangString * JavaIoFile ==> JavaIoFile
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileDescriptor}クラス}
\begin{small}
\begin{verbatim}
public  valid : () ==> bool
public  sync__ : () ==> ()
public  JavaIoFileDescriptor : () ==> JavaIoFileDescriptor
public  JavaIoFileDescriptor : <NIL> ==> JavaIoFileDescriptor
public  getClass : () ==> JavaLangClass
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileInputStream}クラス}
\begin{small}
\begin{verbatim}
public  read : () ==> int
public  close : () ==> ()
public  getFD : () ==> JavaIoFileDescriptor
public  skip__ : int  ==> int
protected  finalize : () ==> ()
public  available : () ==> int
public  readMIIIntInt' : map  int  to  int  * int  * int  ==> 
                                                int * map  int  to  int
public  JavaIoFileInputStream : JavaIoFile ==> JavaIoFileInputStream
public  JavaIoFileInputStream : JavaLangString ==> JavaIoFileInputStream
public  JavaIoFileInputStream : seq of char ==> JavaIoFileInputStream
public  JavaIoFileInputStream : 
          JavaIoFileDescriptor ==> JavaIoFileInputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileNotFoundException}クラス}
\begin{small}
\begin{verbatim}
public  JavaIoFileNotFoundException : () ==> JavaIoFileNotFoundException
public  JavaIoFileNotFoundException : 
          <NIL> ==> JavaIoFileNotFoundException
public  JavaIoFileNotFoundException : 
          JavaLangString ==> JavaIoFileNotFoundException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileOutputStream}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  getFD : () ==> JavaIoFileDescriptor
public  write : int  ==> ()
protected  finalize : () ==> ()
public  JavaIoFileOutputStream : JavaIoFile ==> JavaIoFileOutputStream
public  JavaIoFileOutputStream : JavaLangString ==> JavaIoFileOutputStream
public  JavaIoFileOutputStream : 
          JavaLangString * bool  ==> JavaIoFileOutputStream
public  JavaIoFileOutputStream : 
          seq of char * bool  ==> JavaIoFileOutputStream
public  JavaIoFileOutputStream : 
          JavaIoFileDescriptor ==> JavaIoFileOutputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileReader}クラス}
\begin{small}
\begin{verbatim}
public  JavaIoFileReader : <NIL> ==> JavaIoFileReader
public  JavaIoFileReader : JavaIoFile ==> JavaIoFileReader
public  JavaIoFileReader : JavaLangString ==> JavaIoFileReader
public  JavaIoFileReader : JavaIoFileDescriptor ==> JavaIoFileReader
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileSystem}クラス}
\begin{small}
\begin{verbatim}
public  static  BA_EXISTS : int :=1;
public  static  BA_REGULAR : int :=2;
public  static  BA_DIRECTORY : int :=4;
public  static  BA_HIDDEN : int :=8
public  listRoots : () ==> map  int  to  JavaIoFile
public  list : JavaIoFile ==> map  int  to  JavaLangString
public  delete : JavaIoFile ==> bool
public  getSeparator : () ==> char
public  static  getFileSystem : () ==> JavaIoFileSystem
public  resolve : JavaIoFile ==> JavaLangString
public  hashCode : JavaIoFile ==> int
public  getLength : JavaIoFile ==> int
public  getDefaultParent : () ==> JavaLangString
public  getPathSeparator : () ==> char
public  isAbsolute : JavaIoFile ==> bool
public  normalize : JavaLangString ==> JavaLangString
public  setReadOnly : JavaIoFile ==> bool
public  deleteOnExit : JavaIoFile ==> bool
public  checkAccess : JavaIoFile * bool  ==> bool
public  rename : JavaIoFile * JavaIoFile ==> bool
public  canonicalize : JavaLangString ==> JavaLangString
public  compare : JavaIoFile * JavaIoFile ==> int
public  prefixLength : JavaLangString ==> int
public  createDirectory : JavaIoFile ==> bool
public  resolve : JavaLangString * JavaLangString ==> JavaLangString
public  getLastModifiedTime : JavaIoFile ==> int
public  getBooleanAttributes : JavaIoFile ==> int
public  setLastModifiedTime : JavaIoFile * int  ==> bool
public  createFileExclusively : JavaLangString ==> bool
public  J2VFileSystem : <NIL> ==> J2VFileSystem
public  listRoots : () ==> map  int  to  JavaIoFile
public  list : JavaIoFile ==> map  int  to  JavaLangString
public  delete : JavaIoFile ==> bool
public  getSeparator : () ==> char
public  static  getFileSystem : () ==> JavaIoFileSystem
public  resolve : JavaIoFile ==> JavaLangString
public  hashCode : JavaIoFile ==> int
public  getLength : JavaIoFile ==> int
public  getDefaultParent : () ==> JavaLangString
public  getPathSeparator : () ==> char
public  isAbsolute : JavaIoFile ==> bool
public  normalize : JavaLangString ==> JavaLangString
public  setReadOnly : JavaIoFile ==> bool
public  deleteOnExit : JavaIoFile ==> bool
public  checkAccess : JavaIoFile * bool  ==> bool
public  rename : JavaIoFile * JavaIoFile ==> bool
public  canonicalize : JavaLangString ==> JavaLangString
public  compare : JavaIoFile * JavaIoFile ==> int
public  prefixLength : JavaLangString ==> int
public  createDirectory : JavaIoFile ==> bool
public  resolve : JavaLangString * JavaLangString ==> JavaLangString
public  getLastModifiedTime : JavaIoFile ==> int
public  getBooleanAttributes : JavaIoFile ==> int
public  setLastModifiedTime : JavaIoFile * int  ==> bool
public  createFileExclusively : JavaLangString ==> bool
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFileWriter}クラス}
\begin{small}
\begin{verbatim}
public  JavaIoFileWriter : <NIL> ==> JavaIoFileWriter
public  JavaIoFileWriter : JavaLangString ==> JavaIoFileWriter
public  JavaIoFileWriter : JavaLangString * bool  ==> JavaIoFileWriter
public  JavaIoFileWriter : JavaIoFileDescriptor ==> JavaIoFileWriter
public  JavaIoFileWriter : JavaIoFile ==> JavaIoFileWriter
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFilterInputStream}クラス}
\begin{small}
\begin{verbatim}
protected  in__ : JavaIoInputStream
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  reset : () ==> ()
public  skip__ : int  ==> int
public  getClass : () ==> JavaLangClass
public  available : () ==> int
public  read : map  int  to  int  ==> int
public  markSupported : () ==> bool
public  read : map  int  to  int  * int  * int  ==> int
public  JavaIoFilterInputStream : <NIL> ==> JavaIoFilterInputStream
protected  JavaIoFilterInputStream : 
             JavaIoInputStream ==> JavaIoFilterInputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoFilterOutputStream}クラス}
\begin{small}
\begin{verbatim}
protected  out : JavaIoOutputStream
public  close : () ==> ()
public  flush : () ==> ()
public  write : int  ==> ()
public  write1 : map  int  to  int  ==> ()
public  write2 : map  int  to  int  * int  * int  ==> ()
public  JavaIoFilterOutputStream : 
          JavaIoOutputStream ==> JavaIoFilterOutputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoIOException}クラス}
\begin{small}
\begin{verbatim}
public  JavaIoIOException : () ==> JavaIoIOException
public  JavaIoIOException : <NIL> ==> JavaIoIOException
public  JavaIoIOException : JavaLangString ==> JavaIoIOException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoInputStream}クラス}
\begin{small}
\begin{verbatim}
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  reset : () ==> ()
public  skip__ : int  ==> int
public  getClass : () ==> JavaLangClass
public  available : () ==> int
public  read : map  int  to  int  ==> int
public  markSupported : () ==> bool
public  readMIIIntInt : map  int  to  int  * int  * int  ==> int
public  readMIIIntInt' : map  int  to  int  * 
                  int  * int  ==> int * map  int  to  int
public  JavaIoInputStream : <NIL> ==> JavaIoInputStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoInputStreamReader}クラス}
\begin{small}
\begin{verbatim}
public  read : () ==> int
public  close : () ==> ()
public  ready : () ==> bool
public  getClass : () ==> JavaLangClass
public  getEncoding : () ==> JavaLangString
public  readMICIntInt : map  int  to  char  * int  * int  ==> int
public  readMICIntInt' : map  int  to  char  * 
                            int  * int  ==> int * map  int  to  char
public  JavaIoInputStreamReader : <NIL> ==> JavaIoInputStreamReader
public  JavaIoInputStreamReader : 
          JavaIoInputStream ==> JavaIoInputStreamReader
public  JavaIoInputStreamReader : JavaIoInputStream * 
                          JavaLangString ==> JavaIoInputStreamReader
public  ByteToCharConverter : <NIL> ==> ByteToCharConverter
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoOutputStream}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  flush : () ==> ()
public  write : int  ==> ()
public  write1 : map  int  to  int  ==> ()
public  write2 : map  int  to  int  * int  * int  ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoOutputStreamWriter}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  flush : () ==> ()
public  write : int  ==> ()
public  flushBuffer : () ==> ()
public  getEncoding : () ==> JavaLangString
public  writeICMIntInt : map  int  to  char  * int  * int  ==> ()
public  writeStrIntInt : JavaLangString * int  * int  ==> ()
public  JavaIoOutputStreamWriter : <NIL> ==> JavaIoOutputStreamWriter
public  JavaIoOutputStreamWriter : 
          JavaIoOutputStream ==> JavaIoOutputStreamWriter
public  JavaIoOutputStreamWriter : 
          JavaIoOutputStream * JavaLangString ==> JavaIoOutputStreamWriter
public  CharToByteConverter : <NIL> ==> CharToByteConverter
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoPrintStream}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  flush : () ==> ()
public  print : bool | char | int | real | 
                        (map  int  to  char ) | JavaLangObject ==> ()
public  write : int  ==> ()
public  println : () ==> ()
public  println : bool | char | int | real | 
                        (map  int  to  char ) | JavaLangObject ==> ()
protected  setError : () ==> ()
public  checkError : () ==> bool
public  write : map  int  to  int  * int  * int  ==> ()
public  JavaIoPrintStream : 
          JavaIoOutputStream * bool  ==> JavaIoPrintStream
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoPrintWriter}クラス}
\begin{small}
\begin{verbatim}
protected  out : JavaIoWriter;
public  close : () ==> ()
public  flush : () ==> ()
public  write : int | map  int  to  char ==> ()
public  println : () ==> ()
public  println : bool | char | int | real | 
          (map  int  to  char ) | JavaLangObject  ==> ()
public  print : bool | char | int | real | 
          (map  int  to  char ) | JavaLangObject ==> ()
protected  setError : () ==> ()
public  checkError : () ==> bool
public  write : JavaLangString ==> ()
public  write : map  int  to  char  * int  * int  ==> ()
public  JavaIoPrintWriter : <NIL> ==> JavaIoPrintWriter
public  write : JavaLangString * int  * int  ==> ()
public  JavaIoPrintWriter : JavaIoWriter ==> JavaIoPrintWriter
public  JavaIoPrintWriter : JavaIoWriter * bool  ==> JavaIoPrintWriter
public  JavaIoPrintWriter : JavaIoOutputStream ==> JavaIoPrintWriter
public  JavaIoPrintWriter : 
          JavaIoOutputStream * bool  ==> JavaIoPrintWriter
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoReader}クラス}
\begin{small}
\begin{verbatim}
public  read : () ==> int
public  close : () ==> ()
public  mark : int  ==> ()
public  ready : () ==> bool
public  reset : () ==> ()
public  JavaIoReader : () ==> JavaIoReader
public  skip__ : int  ==> int
public  getClass : () ==> JavaLangClass
public  readMIC : map  int  to  char  ==> int
public  JavaIoReader : <NIL> ==> JavaIoReader
public  markSupported : () ==> bool
public  readMICIntInt : map  int  to  char  * int  * int  ==> int
public  readMICIntInt' : map  int  to  char  * 
                          int  * int  ==> int * map  int  to  char
protected  JavaIoReader : JavaLangObject ==> JavaIoReader
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoStreamTokenizer}クラス}
\begin{small}
\begin{verbatim}
public  ttype : int  := TT_NOTHING;
public  static  TT_EOF : int  := -1;
public  static  TT_EOL : int  := J2VUTIL`toInt('\n');
public  static  TT_NUMBER : int  := -2;
public  static  TT_WORD : int  := -3;
public  sval : JavaLangString;
public  nval : real
public  lineno : () ==> int
public  pushBack : () ==> ()
public  toString : () ==> JavaLangString
public  nextToken : () ==> int
public  quoteChar : int  ==> ()
public  resetSyntax : () ==> ()
public  commentChar : int  ==> ()
public  parseNumbers : () ==> ()
public  wordChars : int  * int  ==> ()
public  ordinaryChar : int  ==> ()
public  lowerCaseMode : bool  ==> ()
public  ordinaryChars : int  * int  ==> ()
public  eolIsSignificant : bool  ==> ()
public  slashStarComments : bool  ==> ()
public  whitespaceChars : int  * int  ==> ()
public  slashSlashComments : bool  ==> ()
public  JavaIoStreamTokenizer : <NIL> ==> JavaIoStreamTokenizer
public  JavaIoStreamTokenizer : JavaIoReader ==> JavaIoStreamTokenizer
public  JavaIoStreamTokenizer : 
          JavaIoInputStream ==> JavaIoStreamTokenizer
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoStringWriter}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  flush : () ==> ()
public  write : int  ==> ()
public  toString : () ==> JavaLangString
public  getBuffer : () ==> JavaLangStringBuffer
public  JavaIoStringWriter : () ==> JavaIoStringWriter
public  JavaIoStringWriter : int  ==> JavaIoStringWriter
public  write : JavaLangString ==> ()
public  write : map  int  to  char  * int  * int  ==> ()
public  JavaIoStringWriter : <NIL> ==> JavaIoStringWriter
public  write : JavaLangString * int  * int  ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoUnsupportedEncodingException}クラス}
\begin{small}
\begin{verbatim}
public  JavaIoUnsupportedEncodingException : 
          () ==> JavaIoUnsupportedEncodingException
public  JavaIoUnsupportedEncodingException : 
          <NIL> ==> JavaIoUnsupportedEncodingException
public  JavaIoUnsupportedEncodingException : 
          JavaLangString ==> JavaIoUnsupportedEncodingException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaIoWriter}クラス}
\begin{small}
\begin{verbatim}
public  JavaIoWriter : <NIL> ==> JavaIoWriter
public  close : () ==> ()
public  flush : () ==> ()
protected  JavaIoWriter : () ==> JavaIoWriter
public  write : int | map  int  to  char ==> ()
public  writeInt : int  ==> ()
public  getClass : () ==> JavaLangClass
public  writeMIC : map  int  to  char  ==> ()
public  writeICMIntInt : map  int  to  char  * int  * int  ==> ()
public  writeStr : JavaLangString ==> ()
protected  JavaIoWriter : JavaLangObject ==> JavaIoWriter
public  writeStrIntInt : JavaLangString * int  * int  ==> ()
\end{verbatim}
\end{small}

\subsection{\texttt{java.net}クラス群}

\subsubsection{\texttt{JavaNetURL}クラス}
\begin{small}
\begin{verbatim}
public JavaNetURL : <NIL> ==> JavaNetURL
\end{verbatim}
\end{small}

\subsection{\texttt{java.text}クラス群}

\subsubsection{\texttt{JavaTextDateFormat}クラス}
\begin{small}
\begin{verbatim}
public  getClass : () ==> JavaLangClass
protected  JavaTextDateFormat : () ==> JavaTextDateFormat
public  format : JavaUtilDate ==> JavaLangString
public  JavaTextDateFormat : <NIL> ==> JavaTextDateFormat
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextDecimalFormat}クラス}
\begin{small}
\begin{verbatim}
public  static  currentSerialVersion : int := 2;
public  static  DOUBLE_INTEGER_DIGITS : int := 309;
public  static  DOUBLE_FRACTION_DIGITS : int := 340;
public  clone : () ==> JavaLangObject
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  toPattern : () ==> JavaLangString
public  JavaTextDecimalFormat : () ==> JavaTextDecimalFormat
public  getMultiplier : () ==> int
public  equals : JavaLangObject ==> bool
public  setMultiplier : int  ==> ()
public  getGroupingSize : () ==> int
public  setGroupingSize : int  ==> ()
public  getNegativePrefix : () ==> JavaLangString
public  getNegativeSuffix : () ==> JavaLangString
public  getPositivePrefix : () ==> JavaLangString
public  getPositiveSuffix : () ==> JavaLangString
public  JavaTextDecimalFormat : <NIL> ==> JavaTextDecimalFormat
public  toLocalizedPattern : () ==> JavaLangString
public  applyPattern : JavaLangString ==> ()
public  JavaTextDecimalFormat : 
          JavaLangString ==> JavaTextDecimalFormat
public  getDecimalFormatSymbols : 
          () ==> JavaTextDecimalFormatSymbols
public  setMaximumIntegerDigits : int  ==> ()
public  setMinimumIntegerDigits : int  ==> ()
public  setMaximumFractionDigits : int  ==> ()
public  setMinimumFractionDigits : int  ==> ()
public  setNegativePrefix : JavaLangString ==> ()
public  setNegativeSuffix : JavaLangString ==> ()
public  setPositivePrefix : JavaLangString ==> ()
public  setPositiveSuffix : JavaLangString ==> ()
public  applyLocalizedPattern : JavaLangString ==> ()
public  isDecimalSeparatorAlwaysShown : () ==> bool
public  parse : JavaLangString * JavaTextParsePosition ==> JavaLangNumber
public  setDecimalSeparatorAlwaysShown : bool  ==> ()
public  format'' : real  * JavaLangStringBuffer * 
                           JavaTextFieldPosition ==> JavaLangStringBuffer
public  JavaTextDecimalFormat : JavaLangString * 
                   JavaTextDecimalFormatSymbols ==> JavaTextDecimalFormat
public  setDecimalFormatSymbols : JavaTextDecimalFormatSymbols ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextDecimalFormatSymbols}クラス}
\begin{small}
\begin{verbatim}
public  clone : () ==> JavaLangObject
public  getNaN : () ==> JavaLangString
public  getClass : () ==> JavaLangClass
public  getDigit : () ==> char
public  hashCode : () ==> int
public  setDigit : char  ==> ()
public  getPerMill : () ==> char
public  getPercent : () ==> char
public  getInfinity : () ==> JavaLangString
public  setPerMill : char  ==> ()
public  setPercent : char  ==> ()
public  getMinusSign : () ==> char
public  getZeroDigit : () ==> char
public  setMinusSign : char  ==> ()
public  setZeroDigit : char  ==> ()
public  equals : JavaLangObject ==> bool
public  setNaN : JavaLangString ==> ()
public  getCurrencySymbol : () ==> JavaLangString
public  getDecimalSeparator : () ==> char
public  getPatternSeparator : () ==> char
public  setInfinity : JavaLangString ==> ()
public  JavaTextDecimalFormatSymbols : () ==> JavaTextDecimalFormatSymbols
public  getGroupingSeparator : () ==> char
public  setDecimalSeparator : char  ==> ()
public  setPatternSeparator : char  ==> ()
public  setGroupingSeparator : char  ==> ()
public  JavaTextDecimalFormatSymbols : 
          <NIL> ==> JavaTextDecimalFormatSymbols
public  setCurrencySymbol : JavaLangString ==> ()
public  getMonetaryDecimalSeparator : () ==> char
public  JavaTextDecimalFormatSymbols : 
          JavaUtilLocale ==> JavaTextDecimalFormatSymbols
public  setMonetaryDecimalSeparator : char  ==> ()
public  getInternationalCurrencySymbol : () ==> JavaLangString
public  setInternationalCurrencySymbol : JavaLangString ==> ()
public  getClass : () ==> JavaLangClass
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextFieldPosition}クラス}
\begin{small}
\begin{verbatim}
public  getField : () ==> int
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  getEndIndex : () ==> int
public  setEndIndex : int  ==> ()
public  getBeginIndex : () ==> int
public  JavaTextFieldPosition : int  ==> JavaTextFieldPosition
public  equals : JavaLangObject ==> bool
public  setBeginIndex : int  ==> ()
public  JavaTextFieldPosition : <NIL> ==> JavaTextFieldPosition
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextFormat}クラス}
\begin{small}
\begin{verbatim}
public  clone : () ==> JavaLangObject
public  getClass : () ==> JavaLangClass
public  JavaTextFormat : <NIL> ==> JavaTextFormat
public  formatObject : JavaLangObject ==> JavaLangString
public  parseObject : JavaLangString ==> JavaLangObject
public  parseObject : 
          JavaLangString * JavaTextParsePosition ==> JavaLangObject
public  format' : JavaLangObject * JavaLangStringBuffer * 
                     JavaTextFieldPosition ==> JavaLangStringBuffer
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextMessageFormat}クラス}
\begin{small}
\begin{verbatim}
public  clone : () ==> JavaLangObject
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  getLocale : () ==> JavaUtilLocale
public  toPattern : () ==> JavaLangString
public  getFormats : () ==> map  int  to  JavaTextFormat
public  parse : JavaLangString ==> map  int  to  JavaLangObject
public  equals : JavaLangObject ==> bool
public  setLocale : JavaUtilLocale ==> ()
public  JavaTextMessageFormat : <NIL> ==> JavaTextMessageFormat
public  setFormat : int  * JavaTextFormat ==> ()
public  applyPattern : JavaLangString ==> ()
public  JavaTextMessageFormat : JavaLangString ==> JavaTextMessageFormat
public  setFormats : map  int  to  JavaTextFormat ==> ()
public  static  format : 
        JavaLangString * map  int  to  JavaLangObject ==> JavaLangString
public  parse : JavaLangString * JavaTextParsePosition ==> 
                                             map  int  to  JavaLangObject
public  JavaTextMessageFormat : JavaLangString * JavaUtilLocale ==> 
                                                    JavaTextMessageFormat
public  parseObject : JavaLangString * JavaTextParsePosition ==> 
                                                           JavaLangObject
public  format' : JavaLangObject * JavaLangStringBuffer * 
                           JavaTextFieldPosition ==> JavaLangStringBuffer
public  formatObjects : map  int  to  JavaLangObject * 
    JavaLangStringBuffer * JavaTextFieldPosition ==> JavaLangStringBuffer
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextNumberFormat}クラス}
\begin{small}
\begin{verbatim}
public  static  INTEGER_FIELD : int  := 0;
public  static  FRACTION_FIELD : int  := 1;
public  static  cachedLocaleData : 
          JavaUtilHashtable := new  JavaUtilHashtable(3);
public  static  NUMBERSTYLE : int  := 0;
public  static  CURRENCYSTYLE : int  := 1;
public  static  PERCENTSTYLE : int  := 2;
public  static  SCIENTIFICSTYLE : int  := 3;
public  clone : () ==> JavaLangObject
public  format : real  ==> JavaLangString
public  getClass : () ==> JavaLangClass
public  hashCode : () ==> int
public  static  getInstance : () ==> JavaTextNumberFormat
public  parse : JavaLangString ==> JavaLangNumber
public  equals : JavaLangObject ==> bool
public  isGroupingUsed : () ==> bool
public  setGroupingUsed : bool  ==> ()
public  JavaTextNumberFormat : <NIL> ==> JavaTextNumberFormat
public  static getNumberInstance : () ==> JavaTextNumberFormat
public  static getPercentInstance : () ==> JavaTextNumberFormat
public  isParseIntegerOnly : () ==> bool
public  static getAvailableLocales : () ==> map  int  to  JavaUtilLocale
public  static getCurrencyInstance : () ==> JavaTextNumberFormat
public  static getInstance : JavaUtilLocale ==> JavaTextNumberFormat
public  setParseIntegerOnly : bool  ==> ()
public  static getInstance : 
          JavaUtilLocale * int  ==> JavaTextNumberFormat
public  getMaximumIntegerDigits : () ==> int
public  getMinimumIntegerDigits : () ==> int
public  getMaximumFractionDigits : () ==> int
public  getMinimumFractionDigits : () ==> int
public  setMaximumIntegerDigits : int  ==> ()
public  setMinimumIntegerDigits : int  ==> ()
public  static  getNumberInstance : 
          JavaUtilLocale ==> JavaTextNumberFormat
public  setMaximumFractionDigits : int  ==> ()
public  setMinimumFractionDigits : int  ==> ()
public  static  getPercentInstance : 
          JavaUtilLocale ==> JavaTextNumberFormat
public  static  getCurrencyInstance : 
          JavaUtilLocale ==> JavaTextNumberFormat
public  parse : 
          JavaLangString * JavaTextParsePosition ==> JavaLangNumber
public  parseObject : 
          JavaLangString * JavaTextParsePosition ==> JavaLangObject
public  format'' : real  * JavaLangStringBuffer * 
                      JavaTextFieldPosition ==> JavaLangStringBuffer
public  format' : JavaLangObject * JavaLangStringBuffer * 
                      JavaTextFieldPosition ==> JavaLangStringBuffer
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextParseException}クラス}
\begin{small}
\begin{verbatim}
public  getClass : () ==> JavaLangClass
public  getErrorOffset : () ==> int
public  JavaTextParseException : <NIL> ==> JavaTextParseException
public  JavaTextParseException : 
          JavaLangString * int  ==> JavaTextParseException
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextParsePosition}クラス}
\begin{small}
\begin{verbatim}
public index : int  := 0;
public errorIndex : int  := -1
public  getClass : () ==> JavaLangClass
public  getIndex : () ==> int
public  hashCode : () ==> int
public  toString : () ==> JavaLangString
public  setIndex : int  ==> ()
public  getErrorIndex : () ==> int
public  JavaTextParsePosition : int  ==> JavaTextParsePosition
public  equals : JavaLangObject ==> bool
public  setErrorIndex : int  ==> ()
public  JavaTextParsePosition : <NIL> ==> JavaTextParsePosition
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaTextSimpleDateFormat}クラス}
\begin{small}
\begin{verbatim}
public  getClass : () ==> JavaLangClass
public  JavaTextSimpleDateFormat : <NIL> ==> JavaTextSimpleDateFormat
public  JavaTextSimpleDateFormat : 
          JavaLangString ==> JavaTextSimpleDateFormat
\end{verbatim}
\end{small}

\subsection{\texttt{java.sql}クラス群}

\subsubsection{\texttt{JavaSqlConnection}クラス}
\begin{small}
\begin{verbatim}
public  static  TRANSACTION_NONE : int :=0;
public  static  TRANSACTION_READ_UNCOMMITTED : int :=0;
public  static  TRANSACTION_READ_COMMITTED : int :=0;
public  static  TRANSACTION_REPEATABLE_READ : int :=0;
public  static  TRANSACTION_SERIALIZABLE : int :=0
public  JavaSqlConnection : <NIL> ==> JavaSqlConnection
public  close : () ==> ()
public  commit : () ==> ()
public  getClass : () ==> JavaLangClass
public  isClosed : () ==> bool
public  rollback : () ==> ()
public  getCatalog : () ==> JavaLangString
public  getTypeMap : () ==> JavaUtilMap
public  isReadOnly : () ==> bool
public  setReadOnly : bool  ==> ()
public  clearWarnings : () ==> ()
public  getAutoCommit : () ==> bool
public  setAutoCommit : bool  ==> ()
public  createStatement : () ==> JavaSqlStatement
public  nativeSQL : JavaLangString ==> JavaLangString
public  createStatement : int  * int  ==> JavaSqlStatement
public  setCatalog : JavaLangString ==> ()
public  getTransactionIsolation : () ==> int
public  setTransactionIsolation : int  ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaSqlDriverManager}クラス}
\begin{small}
\begin{verbatim}
public  getClass : () ==> JavaLangClass
public  static  getConnection : JavaLangString ==> JavaSqlConnection
public  static  getConnection : JavaLangString * JavaLangString * 
                                   JavaLangString ==> JavaSqlConnection
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaSqlResultSet}クラス}
\begin{small}
\begin{verbatim}
public  static  FETCH_FORWARD : int := 1000;
public  static  FETCH_REVERSE : int := 1001;
public  static  FETCH_UNKNOWN : int := 1002;
public  static  TYPE_FORWARD_ONLY : int := 1003;
public  static  TYPE_SCROLL_INSENSITIVE : int := 1004;
public  static  TYPE_SCROLL_SENSITIVE : int := 1005;
public  static  CONCUR_READ_ONLY : int := 1007;
public  static  CONCUR_UPDATABLE : int := 1008
public  last : () ==> bool
public  next : () ==> bool
public  close : () ==> ()
public  first : () ==> bool
public  getRow : () ==> int
public  isLast : () ==> bool
public  getInt : int  ==> int
public  getType : () ==> int
public  isFirst : () ==> bool
public  wasNull : () ==> bool
public  getByte : int  ==> int
public  getClass : () ==> JavaLangClass
public  getLong : int  ==> int
public  previous : () ==> bool
public  absolute : int  ==> bool
public  afterLast : () ==> ()
public  deleteRow : () ==> ()
public  getBytes : int  ==> map  int  to  int
public  getFloat : int  ==> real
public  getShort : int  ==> int
public  insertRow : () ==> ()
public  relative : int  ==> bool
public  updateRow : () ==> ()
public  getDouble : int  ==> real
public  getString : int  ==> JavaLangString
public  refreshRow : () ==> ()
public  rowDeleted : () ==> bool
public  rowUpdated : () ==> bool
public  beforeFirst : () ==> ()
public  getBoolean : int  ==> bool
public  isAfterLast : () ==> bool
public  rowInserted : () ==> bool
public  updateNull : int  ==> ()
public  getFetchSize : () ==> int
public  getStatement : () ==> JavaSqlStatement
public  updateInt : int  * int  ==> ()
public  clearWarnings : () ==> ()
public  getCursorName : () ==> JavaLangString
public  isBeforeFirst : () ==> bool
public  setFetchSize : int  ==> ()
public  updateByte : int  * int  ==> ()
public  updateLong : int  * int  ==> ()
public  getConcurrency : () ==> int
public  getInt : JavaLangString ==> int
public  updateFloat : int  * real  ==> ()
public  updateShort : int  * int  ==> ()
public  getByte : JavaLangString ==> int
public  getLong : JavaLangString ==> int
public  moveToInsertRow : () ==> ()
public  updateDouble : int  * real  ==> ()
public  cancelRowUpdates : () ==> ()
public  getBytes : JavaLangString ==> map  int  to  int
public  getFloat : JavaLangString ==> real
public  getShort : JavaLangString ==> int
public  moveToCurrentRow : () ==> ()
public  updateBoolean : int  * bool  ==> ()
public  getDouble : JavaLangString ==> real
public  getFetchDirection : () ==> int
public  getObject : JavaLangString ==> JavaLangObject
public  getString : JavaLangString ==> JavaLangString
public  findColumn : JavaLangString ==> int
public  getBoolean : JavaLangString ==> bool
public  setFetchDirection : int  ==> ()
public  updateBytes : int  * map  int  to  int  ==> ()
public  updateNull : JavaLangString ==> ()
public  updateInt : JavaLangString * int  ==> ()
public  updateByte : JavaLangString * int  ==> ()
public  updateLong : JavaLangString * int  ==> ()
public  updateFloat : JavaLangString * real  ==> ()
public  updateShort : JavaLangString * int  ==> ()
public  updateDouble : JavaLangString * real  ==> ()
public  updateObject : int  * JavaLangObject ==> ()
public  updateString : int  * JavaLangString ==> ()
public  updateBoolean : JavaLangString * bool  ==> ()
public  updateBytes : JavaLangString * map  int  to  int  ==> ()
public  updateString : JavaLangString * JavaLangString ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaSqlSQLException}クラス}
\begin{small}
\begin{verbatim}
public  getClass : () ==> JavaLangClass
public  getSQLState : () ==> JavaLangString
public  JavaSqlSQLException : () ==> JavaSqlSQLException
public  getErrorCode : () ==> int
public  getNextException : () ==> JavaSqlSQLException
public  JavaSqlSQLException : <NIL> ==> JavaSqlSQLException
public  JavaSqlSQLException : JavaLangString ==> JavaSqlSQLException
public  JavaSqlSQLException : 
          JavaLangString * JavaLangString ==> JavaSqlSQLException
public  setNextException : JavaSqlSQLException ==> ()
public  JavaSqlSQLException : JavaLangString * 
                        JavaLangString * int  ==> JavaSqlSQLException
\end{verbatim}
\end{small}

\subsubsection{\texttt{SqlConnection}クラス}
\begin{small}
\begin{verbatim}
public  static  TRANSACTION_NONE : int := 0;
public  static  TRANSACTION_READ_UNCOMMITTED : int := 0;
public  static  TRANSACTION_READ_COMMITTED : int := 0;
public  static  TRANSACTION_REPEATABLE_READ : int := 0;
public  static  TRANSACTION_SERIALIZABLE : int := 0
public  close : () ==> ()
public  commit : () ==> ()
public  getClass : () ==> JavaLangClass
public  isClosed : () ==> bool
public  rollback : () ==> ()
public  getCatalog : () ==> JavaLangString
public  getTypeMap : () ==> JavaUtilMap
public  isReadOnly : () ==> bool
public  setReadOnly : bool  ==> ()
public  clearWarnings : () ==> ()
public  getAutoCommit : () ==> bool
public  setAutoCommit : bool  ==> ()
public  createStatement : () ==> JavaSqlStatement
public  nativeSQL : JavaLangString ==> JavaLangString
public  createStatement : int  * int  ==> JavaSqlStatement
public  setCatalog : JavaLangString ==> ()
public  getTransactionIsolation : () ==> int
public  setTransactionIsolation : int  ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{SqlResultSet}クラス}
\begin{small}
\begin{verbatim}
public  getColumns : () ==> map seq of char to int * int * int * int
public  last : () ==> bool
public  next : () ==> bool
public  close : () ==> ()
public  first : () ==> bool
public  getRow : () ==> int
public  isLast : () ==> bool
public  getInt : int  ==> int
public  getType : () ==> int
public  isFirst : () ==> bool
public  wasNull : () ==> bool
public  getByte : int  ==> int
public  getClass : () ==> JavaLangClass
public  getLong : int  ==> int
public  previous : () ==> bool
public  absolute : int  ==> bool
public  afterLast : () ==> ()
public  deleteRow : () ==> ()
public  getBytes : int  ==> map  int  to  int
public  getFloat : int  ==> real
public  getShort : int  ==> int
public  insertRow : () ==> ()
public  relative : int  ==> bool
public  updateRow : () ==> ()
public  getDouble : int  ==> real
public  getString : int  ==> JavaLangString
public  refreshRow : () ==> ()
public  rowDeleted : () ==> bool
public  rowUpdated : () ==> bool
public  beforeFirst : () ==> ()
public  getBoolean : int  ==> bool
public  isAfterLast : () ==> bool
public  rowInserted : () ==> bool
public  updateNull : int  ==> ()
public  getFetchSize : () ==> int
public  getStatement : () ==> JavaSqlStatement
public  updateInt : int  * int  ==> ()
public  clearWarnings : () ==> ()
public  getCursorName : () ==> JavaLangString
public  isBeforeFirst : () ==> bool
public  setFetchSize : int  ==> ()
public  updateByte : int  * int  ==> ()
public  updateLong : int  * int  ==> ()
public  getConcurrency : () ==> int
public  getInt : JavaLangString ==> int
public  updateFloat : int  * real  ==> ()
public  updateShort : int  * int  ==> ()
public  getByte : JavaLangString ==> int
public  getLong : JavaLangString ==> int
public  moveToInsertRow : () ==> ()
public  updateDouble : int  * real  ==> ()
public  cancelRowUpdates : () ==> ()
public  getBytes : JavaLangString ==> map  int  to  int
public  getFloat : JavaLangString ==> real
public  getShort : JavaLangString ==> int
public  moveToCurrentRow : () ==> ()
public  updateBoolean : int  * bool  ==> ()
public  getDouble : JavaLangString ==> real
public  getFetchDirection : () ==> int
public  getObject : JavaLangString ==> JavaLangObject
public  getString : JavaLangString ==> JavaLangString
public  findColumn : JavaLangString ==> int
public  getBoolean : JavaLangString ==> bool
public  setFetchDirection : int  ==> ()
public  updateBytes : int  * map  int  to  int  ==> ()
public  updateNull : JavaLangString ==> ()
public  updateInt : JavaLangString * int  ==> ()
public  updateByte : JavaLangString * int  ==> ()
public  updateLong : JavaLangString * int  ==> ()
public  updateFloat : JavaLangString * real  ==> ()
public  updateShort : JavaLangString * int  ==> ()
public  updateDouble : JavaLangString * real  ==> ()
public  updateObject : int  * JavaLangObject ==> ()
public  updateString : int  * JavaLangString ==> ()
public  updateBoolean : JavaLangString * bool  ==> ()
public  updateBytes : JavaLangString * map  int  to  int  ==> ()
public  updateString : JavaLangString * JavaLangString ==> ()
\end{verbatim}
\end{small}

\subsubsection{\texttt{SqlStatement}クラス}
\begin{small}
\begin{verbatim}
public  close : () ==> ()
public  getClass : () ==> JavaLangClass
public  executeQuery : JavaLangString ==> JavaSqlResultSet
public  executeUpdate : JavaLangString ==> int
\end{verbatim}
\end{small}

\subsubsection{\texttt{JavaSqlStatement}クラス}
\begin{small}
\begin{verbatim}
public close : () ==> ()
public  cancel : () ==> ()
public  getClass : () ==> JavaLangClass
public  clearBatch : () ==> ()
public  getMaxRows : () ==> int
public  setMaxRows : int  ==> ()
public  executeBatch : () ==> map  int  to  int
public  getFetchSize : () ==> int
public  getResultSet : () ==> JavaSqlResultSet
public  clearWarnings : () ==> ()
public  getConnection : () ==> JavaSqlConnection
public  setFetchSize : int  ==> ()
public  getMoreResults : () ==> bool
public  getUpdateCount : () ==> int
public  execute : JavaLangString ==> bool
public  getMaxFieldSize : () ==> int
public  getQueryTimeout : () ==> int
public  addBatch : JavaLangString ==> ()
public  getResultSetType : () ==> int
public  setMaxFieldSize : int  ==> ()
public  setQueryTimeout : int  ==> ()
public  getFetchDirection : () ==> int
public  setFetchDirection : int  ==> ()
public  executeQuery : JavaLangString ==> JavaSqlResultSet
public  setEscapeProcessing : bool  ==> ()
public  executeUpdate : JavaLangString ==> int
public  setCursorName : JavaLangString ==> ()
public  getResultSetConcurrency : () ==> int
\end{verbatim}
\end{small}

\appendix

\newpage
\bibliographystyle{iptes}
\bibliography{ifad}

\newpage
\addcontentsline{toc}{section}{Index}
\printindex
\end{document}
